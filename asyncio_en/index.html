
<!doctype html>
<html lang="zh" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
        <meta name="description" content="FastApi 最佳实践-中文版">
      
      
      
      
        <link rel="prev" href="../asyncio/">
      
      
        <link rel="next" href="../network/internet_protocol_suite_part_i/">
      
      <link rel="icon" href="../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.4.3, mkdocs-material-9.1.15">
    
    
      
        <title>英文完整指南 - FastApi 最佳实践-中文版</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/main.26e3688c.min.css">
      
      

    
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
    <script>__md_scope=new URL("..",location),__md_hash=e=>[...e].reduce((e,_)=>(e<<5)-e+_.charCodeAt(0),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
   <link href="../assets/stylesheets/glightbox.min.css" rel="stylesheet"/><style>
        html.glightbox-open { overflow: initial; height: 100%; }
        .gslide-title { margin-top: 0px; user-select: text; }
        .gslide-desc { color: #666; user-select: text; }
        .gslide-image img { background: white; }
        
            .gscrollbar-fixer { padding-right: 15px; }
            .gdesc-inner { font-size: 0.75rem; }
            body[data-md-color-scheme="slate"] .gdesc-inner { background: var(--md-default-bg-color);}
            body[data-md-color-scheme="slate"] .gslide-title { color: var(--md-default-fg-color);}
            body[data-md-color-scheme="slate"] .gslide-desc { color: var(--md-default-fg-color);}
            </style> <script src="../assets/javascripts/glightbox.min.js"></script></head>
  
  
    <body dir="ltr">
  
    
    
      <script>var palette=__md_get("__palette");if(palette&&"object"==typeof palette.color)for(var key of Object.keys(palette.color))document.body.setAttribute("data-md-color-"+key,palette.color[key])</script>
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#python-asyncio-完整指南" class="md-skip">
          跳转至
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow md-header--lifted" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="页眉">
    <a href=".." title="FastApi 最佳实践-中文版" class="md-header__button md-logo" aria-label="FastApi 最佳实践-中文版" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2Z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            FastApi 最佳实践-中文版
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              英文完整指南
            
          </span>
        </div>
      </div>
    </div>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="搜索" placeholder="搜索" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12Z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="查找">
        
        <button type="reset" class="md-search__icon md-icon" title="清空当前内容" aria-label="清空当前内容" tabindex="-1">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41Z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            正在初始化搜索引擎
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
      <div class="md-header__source">
        <a href="https://github.com/hellowac/fastapi-best-practices-zh-cn/" title="前往仓库" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.4.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2023 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"/></svg>
  </div>
  <div class="md-source__repository">
    FastApi 最佳实践-中文版
  </div>
</a>
      </div>
    
  </nav>
  
    
      
<nav class="md-tabs" aria-label="标签" data-md-component="tabs">
  <div class="md-grid">
    <ul class="md-tabs__list">
      
        
  
  


  <li class="md-tabs__item">
    <a href=".." class="md-tabs__link">
      最佳实践
    </a>
  </li>

      
        
  
  


  <li class="md-tabs__item">
    <a href="../raw_en/" class="md-tabs__link">
      英文原版
    </a>
  </li>

      
        
  
  
    
  


  
  
  
    <li class="md-tabs__item">
      <a href="../asyncio/" class="md-tabs__link md-tabs__link--active">
        Asyncio
      </a>
    </li>
  

      
        
  
  


  
  
  
    <li class="md-tabs__item">
      <a href="../network/internet_protocol_suite_part_i/" class="md-tabs__link">
        互联网协议
      </a>
    </li>
  

      
        
  
  


  
  
  
    <li class="md-tabs__item">
      <a href="../http/" class="md-tabs__link">
        HTTP
      </a>
    </li>
  

      
        
  
  


  
  
  
    <li class="md-tabs__item">
      <a href="../rest-ful/restapi/" class="md-tabs__link">
        REST ful
      </a>
    </li>
  

      
        
  
  


  
  
  
    <li class="md-tabs__item">
      <a href="../git/git-branch-manage/" class="md-tabs__link">
        Git
      </a>
    </li>
  

      
        
  
  


  
  
  
    <li class="md-tabs__item">
      <a href="../system-design/perm_design/" class="md-tabs__link">
        系统设计
      </a>
    </li>
  

      
        
  
  


  <li class="md-tabs__item">
    <a href="../about/" class="md-tabs__link">
      关于
    </a>
  </li>

      
    </ul>
  </div>
</nav>
    
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

  


<nav class="md-nav md-nav--primary md-nav--lifted" aria-label="导航栏" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href=".." title="FastApi 最佳实践-中文版" class="md-nav__button md-logo" aria-label="FastApi 最佳实践-中文版" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    FastApi 最佳实践-中文版
  </label>
  
    <div class="md-nav__source">
      <a href="https://github.com/hellowac/fastapi-best-practices-zh-cn/" title="前往仓库" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.4.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2023 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"/></svg>
  </div>
  <div class="md-source__repository">
    FastApi 最佳实践-中文版
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href=".." class="md-nav__link">
        最佳实践
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../raw_en/" class="md-nav__link">
        英文原版
      </a>
    </li>
  

    
      
      
      

  
  
    
  
  
    
    <li class="md-nav__item md-nav__item--active md-nav__item--nested">
      
      
      
      
      <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3" checked>
      
      
        
          
        
          
        
      
      
        <label class="md-nav__link" for="__nav_3" id="__nav_3_label" tabindex="0">
          Asyncio
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_3_label" aria-expanded="true">
        <label class="md-nav__title" for="__nav_3">
          <span class="md-nav__icon md-icon"></span>
          Asyncio
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../asyncio/" class="md-nav__link">
        中文简单指南
      </a>
    </li>
  

            
          
            
              
  
  
    
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" type="checkbox" id="__toc">
      
      
        
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          英文完整指南
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="./" class="md-nav__link md-nav__link--active">
        英文完整指南
      </a>
      
        

<nav class="md-nav md-nav--secondary" aria-label="目录">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      目录
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#1-什么是异步编程" class="md-nav__link">
    1. 什么是异步编程
  </a>
  
    <nav class="md-nav" aria-label="1. 什么是异步编程">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#11-异步任务" class="md-nav__link">
    1.1 异步任务
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#12-异步编程" class="md-nav__link">
    1.2 异步编程
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#13-python-异步编程" class="md-nav__link">
    1.3 Python 异步编程
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#2-asyncio-是什么" class="md-nav__link">
    2. Asyncio 是什么
  </a>
  
    <nav class="md-nav" aria-label="2. Asyncio 是什么">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#21-对-python-进行更改以添加对协程的支持" class="md-nav__link">
    2.1 对 Python 进行更改以添加对协程的支持
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#22-asyncio-模块" class="md-nav__link">
    2.2 asyncio 模块
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#3-asyncio-在什么时候使用" class="md-nav__link">
    3. Asyncio 在什么时候使用
  </a>
  
    <nav class="md-nav" aria-label="3. Asyncio 在什么时候使用">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#31-使用python-asyncio的原因" class="md-nav__link">
    3.1 使用Python Asyncio的原因
  </a>
  
    <nav class="md-nav" aria-label="3.1 使用Python Asyncio的原因">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#311-原因-1-使用协程" class="md-nav__link">
    3.1.1 原因 1: 使用协程
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#312-原因-2-使用异步编程" class="md-nav__link">
    3.1.2 原因 2: 使用异步编程
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#313-原因-3-使用非阻塞io" class="md-nav__link">
    3.1.3 原因 3: 使用非阻塞I/O
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#32-使用asyncio的其他原因" class="md-nav__link">
    3.2 使用Asyncio的其他原因
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#33-asyncio在什么时候不适用" class="md-nav__link">
    3.3 Asyncio在什么时候不适用
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#4-python-中的协程" class="md-nav__link">
    4. Python 中的协程
  </a>
  
    <nav class="md-nav" aria-label="4. Python 中的协程">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#41-什么是协程" class="md-nav__link">
    4.1 什么是协程
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#42-协程与例程和子例程" class="md-nav__link">
    4.2 协程与例程和子例程
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#43-协程与生成器" class="md-nav__link">
    4.3 协程与生成器
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#44-协程与任务" class="md-nav__link">
    4.4 协程与任务
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#45-协程与线程" class="md-nav__link">
    4.5 协程与线程
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#46-协程与进程" class="md-nav__link">
    4.6 协程与进程
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#47-python-何时添加了协程" class="md-nav__link">
    4.7 Python 何时添加了协程
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#5-定义创建和运行协程" class="md-nav__link">
    5. 定义、创建和运行协程
  </a>
  
    <nav class="md-nav" aria-label="5. 定义、创建和运行协程">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#51-如何定义协程" class="md-nav__link">
    5.1 如何定义协程
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#52-如何创建协程" class="md-nav__link">
    5.2 如何创建协程
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#53-python中如何运行协程" class="md-nav__link">
    5.3 Python中如何运行协程
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#6-事件循环是什么" class="md-nav__link">
    6. 事件循环是什么
  </a>
  
    <nav class="md-nav" aria-label="6. 事件循环是什么">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#61-asyncio-的事件循环是什么" class="md-nav__link">
    6.1 Asyncio 的事件循环是什么
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#62-事件循环如何获取和启动" class="md-nav__link">
    6.2 事件循环如何获取和启动
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#63-事件循环对象是什么" class="md-nav__link">
    6.3 事件循环对象是什么
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#64-为什么要访问事件循环" class="md-nav__link">
    6.4 为什么要访问事件循环
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#7-asyncio-任务的创建和运行" class="md-nav__link">
    7. Asyncio 任务的创建和运行
  </a>
  
    <nav class="md-nav" aria-label="7. Asyncio 任务的创建和运行">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#71-asyncio-任务是什么" class="md-nav__link">
    7.1 Asyncio 任务是什么
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#72-怎么创建任务" class="md-nav__link">
    7.2 怎么创建任务
  </a>
  
    <nav class="md-nav" aria-label="7.2 怎么创建任务">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#721-使用高级-api-创建任务" class="md-nav__link">
    7.2.1 使用高级 API 创建任务
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#722-使用低级-api-创建任务" class="md-nav__link">
    7.2.2 使用低级 API 创建任务
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#73-何时运行任务" class="md-nav__link">
    7.3 何时运行任务？
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#8-使用和查询任务" class="md-nav__link">
    8. 使用和查询任务
  </a>
  
    <nav class="md-nav" aria-label="8. 使用和查询任务">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#81-任务的生命周期" class="md-nav__link">
    8.1 任务的生命周期
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#82-如何检查任务的状态" class="md-nav__link">
    8.2 如何检查任务的状态
  </a>
  
    <nav class="md-nav" aria-label="8.2 如何检查任务的状态">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#821-检查任务是否完成" class="md-nav__link">
    8.2.1 检查任务是否完成
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#822-检查任务是否被取消" class="md-nav__link">
    8.2.2 检查任务是否被取消
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#83-如何获取任务结果" class="md-nav__link">
    8.3 如何获取任务结果
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#84-如何获取任务异常" class="md-nav__link">
    8.4 如何获取任务异常
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#85-如何取消任务" class="md-nav__link">
    8.5 如何取消任务
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#86-如何在任务中使用回调" class="md-nav__link">
    8.6 如何在任务中使用回调
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#87-如何设置任务名称" class="md-nav__link">
    8.7 如何设置任务名称
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#9-当前和正在运行的任务" class="md-nav__link">
    9. 当前和正在运行的任务
  </a>
  
    <nav class="md-nav" aria-label="9. 当前和正在运行的任务">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#91-如何获取当前任务" class="md-nav__link">
    9.1 如何获取当前任务
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#92-如何获取所有任务" class="md-nav__link">
    9.2 如何获取所有任务
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#10-同时运行多个协程" class="md-nav__link">
    10. 同时运行多个协程
  </a>
  
    <nav class="md-nav" aria-label="10. 同时运行多个协程">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#101-什么是-asyncio-gather" class="md-nav__link">
    10.1 什么是 Asyncio Gather()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#102-如何使用-asyncio-gather" class="md-nav__link">
    10.2 如何使用 Asyncio Gather()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#103-对于列表中的多个协程的-gather-示例" class="md-nav__link">
    10.3 对于列表中的多个协程的 Gather() 示例
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#11-等待任务的集合" class="md-nav__link">
    11. 等待任务的集合
  </a>
  
    <nav class="md-nav" aria-label="11. 等待任务的集合">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#111-什么是-asynciowait" class="md-nav__link">
    11.1 什么是 asyncio.wait()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#112-如何使用-asynciowait" class="md-nav__link">
    11.2 如何使用 asyncio.wait()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#113-等待所有任务的示例" class="md-nav__link">
    11.3 等待所有任务的示例
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#12-等待有时间限制的协程" class="md-nav__link">
    12. 等待有时间限制的协程
  </a>
  
    <nav class="md-nav" aria-label="12. 等待有时间限制的协程">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#121-什么是-asyncio-wait_for" class="md-nav__link">
    12.1 什么是 Asyncio wait_for()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#122-如何使用-asyncio-wait_for" class="md-nav__link">
    12.2 如何使用 Asyncio wait_for()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#123-带有超时的-asyncio-wait_for-示例" class="md-nav__link">
    12.3 带有超时的 Asyncio wait_for() 示例
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#13-防止任务被取消" class="md-nav__link">
    13. 防止任务被取消
  </a>
  
    <nav class="md-nav" aria-label="13. 防止任务被取消">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#131-什么是-asyncio-shield" class="md-nav__link">
    13.1 什么是 Asyncio shield()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#132-如何使用-asyncioshield" class="md-nav__link">
    13.2 如何使用 Asyncioshield()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#133-任务的-asyncioshield-示例" class="md-nav__link">
    13.3 任务的 Asyncioshield() 示例
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#14-在-asyncio-中运行阻塞任务" class="md-nav__link">
    14. 在 Asyncio 中运行阻塞任务
  </a>
  
    <nav class="md-nav" aria-label="14. 在 Asyncio 中运行阻塞任务">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#141-需要在-asyncio-中运行阻塞任务" class="md-nav__link">
    14.1 需要在 Asyncio 中运行阻塞任务
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#142-如何运行阻塞任务" class="md-nav__link">
    14.2 如何运行阻塞任务
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#143-使用-to_thread-在-asyncio-中运行-io-密集型任务的示例" class="md-nav__link">
    14.3 使用 to_thread() 在 Asyncio 中运行 I/O 密集型任务的示例
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#15-异步迭代器" class="md-nav__link">
    15. 异步迭代器
  </a>
  
    <nav class="md-nav" aria-label="15. 异步迭代器">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#151-什么是异步迭代器" class="md-nav__link">
    15.1 什么是异步迭代器
  </a>
  
    <nav class="md-nav" aria-label="15.1 什么是异步迭代器">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#1511-迭代器" class="md-nav__link">
    15.1.1 迭代器
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1512-异步迭代器" class="md-nav__link">
    15.1.2 异步迭代器
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#152-什么是async-for循环" class="md-nav__link">
    15.2 什么是“async for”循环？
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#153-如何使用异步迭代器" class="md-nav__link">
    15.3 如何使用异步迭代器
  </a>
  
    <nav class="md-nav" aria-label="15.3 如何使用异步迭代器">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#1531-定义异步迭代器" class="md-nav__link">
    15.3.1 定义异步迭代器
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1532-创建异步迭代器" class="md-nav__link">
    15.3.2 创建异步迭代器
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1533-单步执行异步迭代器" class="md-nav__link">
    15.3.3 单步执行异步迭代器
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1534-遍历异步迭代器" class="md-nav__link">
    15.3.4 遍历异步迭代器
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#154-异步迭代器的示例" class="md-nav__link">
    15.4 异步迭代器的示例
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#16-异步生成器" class="md-nav__link">
    16. 异步生成器
  </a>
  
    <nav class="md-nav" aria-label="16. 异步生成器">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#161-什么是异步生成器" class="md-nav__link">
    16.1 什么是异步生成器
  </a>
  
    <nav class="md-nav" aria-label="16.1 什么是异步生成器">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#1611-生成器" class="md-nav__link">
    16.1.1 生成器
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1612-异步生成器" class="md-nav__link">
    16.1.2 异步生成器
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#162-如何使用异步生成器" class="md-nav__link">
    16.2 如何使用异步生成器
  </a>
  
    <nav class="md-nav" aria-label="16.2 如何使用异步生成器">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#1621-定义异步生成器" class="md-nav__link">
    16.2.1 定义异步生成器
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1622-创建异步生成器" class="md-nav__link">
    16.2.2 创建异步生成器
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1623-使用异步生成器" class="md-nav__link">
    16.2.3 使用异步生成器
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1624-遍历异步生成器" class="md-nav__link">
    16.2.4 遍历异步生成器
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#163-异步生成器示例" class="md-nav__link">
    16.3 异步生成器示例
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#17-异步上下文管理器" class="md-nav__link">
    17. 异步上下文管理器
  </a>
  
    <nav class="md-nav" aria-label="17. 异步上下文管理器">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#171-什么是异步上下文管理器" class="md-nav__link">
    17.1 什么是异步上下文管理器
  </a>
  
    <nav class="md-nav" aria-label="17.1 什么是异步上下文管理器">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#1711--上下文管理器" class="md-nav__link">
    17.1.1  上下文管理器
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1712-异步上下文管理器" class="md-nav__link">
    17.1.2 异步上下文管理器
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#172-如何使用异步上下文管理器" class="md-nav__link">
    17.2 如何使用异步上下文管理器
  </a>
  
    <nav class="md-nav" aria-label="17.2 如何使用异步上下文管理器">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#1721-定义异步上下文管理器" class="md-nav__link">
    17.2.1 定义异步上下文管理器
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1722-使用异步上下文管理器" class="md-nav__link">
    17.2.2 使用异步上下文管理器
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#173-异步上下文管理器和async-with的示例" class="md-nav__link">
    17.3 异步上下文管理器和“async with”的示例
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#18-异步推导式" class="md-nav__link">
    18. 异步推导式
  </a>
  
    <nav class="md-nav" aria-label="18. 异步推导式">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#181-什么是异步推导式" class="md-nav__link">
    18.1 什么是异步推导式
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#182-推导式" class="md-nav__link">
    18.2 推导式
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#183-异步推导式" class="md-nav__link">
    18.3 异步推导式
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#184-await-推导式" class="md-nav__link">
    18.4 Await 推导式
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#19-在非阻塞子进程中运行命令" class="md-nav__link">
    19. 在非阻塞子进程中运行命令
  </a>
  
    <nav class="md-nav" aria-label="19. 在非阻塞子进程中运行命令">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#191-什么是-asynciosubprocessprocess" class="md-nav__link">
    19.1 什么是 asyncio.subprocess.Process
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#192-如何直接运行命令" class="md-nav__link">
    19.2 如何直接运行命令
  </a>
  
    <nav class="md-nav" aria-label="19.2 如何直接运行命令">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#1921-如何使用-asyncio-的-create_subprocess_exec" class="md-nav__link">
    19.2.1 如何使用 Asyncio 的 create_subprocess_exec()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1922-asyncio-的-create_subprocess_exec-的示例" class="md-nav__link">
    19.2.2 Asyncio 的 create_subprocess_exec() 的示例
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#193-如何跟shell一起运行一个命令" class="md-nav__link">
    19.3 如何跟shell一起运行一个命令
  </a>
  
    <nav class="md-nav" aria-label="19.3 如何跟shell一起运行一个命令">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#1931-如何使用-asyncio-的-create_subprocess_shell" class="md-nav__link">
    19.3.1 如何使用 Asyncio 的 create_subprocess_shell()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1932-asyncio-的-create_subprocess_shell-的示例" class="md-nav__link">
    19.3.2 Asyncio 的 create_subprocess_shell() 的示例
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#20-非阻塞流" class="md-nav__link">
    20. 非阻塞流
  </a>
  
    <nav class="md-nav" aria-label="20. 非阻塞流">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#201-asyncio-的流" class="md-nav__link">
    20.1 Asyncio 的流
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#202-如何打开一个连接" class="md-nav__link">
    20.2 如何打开一个连接
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#203-如何启动一个侦听服务" class="md-nav__link">
    20.3 如何启动一个侦听服务
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#204-如何使用-streamwriter-写入数据" class="md-nav__link">
    20.4 如何使用 StreamWriter 写入数据
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#205-如何使用-streamreader-读取数据" class="md-nav__link">
    20.5 如何使用 StreamReader 读取数据
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#206-如何关闭连接" class="md-nav__link">
    20.6 如何关闭连接
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#21-检查网站状态的示例" class="md-nav__link">
    21. 检查网站状态的示例
  </a>
  
    <nav class="md-nav" aria-label="21. 检查网站状态的示例">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#211-如何使用-asyncio-检查-http-状态" class="md-nav__link">
    21.1 如何使用 Asyncio 检查 HTTP 状态
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#212-打开-http-连接" class="md-nav__link">
    21.2 打开 HTTP 连接
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#213-写入-http-请求" class="md-nav__link">
    21.3 写入 HTTP 请求
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#214-读取-http-响应" class="md-nav__link">
    21.4 读取 HTTP 响应
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#215-关闭-http-连接" class="md-nav__link">
    21.5 关闭 HTTP 连接
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#216-按顺序检查-http-状态的示例" class="md-nav__link">
    21.6 按顺序检查 HTTP 状态的示例
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#217-并发检查网站状态的示例" class="md-nav__link">
    21.7 并发检查网站状态的示例
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#22-python-asyncio-常见错误" class="md-nav__link">
    22. Python Asyncio 常见错误
  </a>
  
    <nav class="md-nav" aria-label="22. Python Asyncio 常见错误">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#221-错误-1-尝试通过函数调用的方式来运行协程" class="md-nav__link">
    22.1 错误 1: 尝试通过函数调用的方式来运行协程
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#222-错误-2-不在事件循环中运行协程" class="md-nav__link">
    22.2 错误 2: 不在事件循环中运行协程
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#223-错误-3-使用低级的-asyncio-api" class="md-nav__link">
    22.3 错误 3: 使用低级的 Asyncio API
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#224-错误-4-退出主协程太早" class="md-nav__link">
    22.4 错误 4: 退出主协程太早
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#225-错误-5-假设竞争条件和死锁是不可能的" class="md-nav__link">
    22.5 错误 5: 假设竞争条件和死锁是不可能的
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#23-python-asyncio-常见问题" class="md-nav__link">
    23. Python Asyncio 常见问题
  </a>
  
    <nav class="md-nav" aria-label="23. Python Asyncio 常见问题">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#231-如何停止任务" class="md-nav__link">
    23.1 如何停止任务？
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#232-如何等待任务完成" class="md-nav__link">
    23.2 如何等待任务完成？
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#233-如何获取任务的返回值" class="md-nav__link">
    23.3 如何获取任务的返回值？
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#234-如何在后台运行任务" class="md-nav__link">
    23.4 如何在后台运行任务？
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#235-如何等待所有后台任务" class="md-nav__link">
    23.5 如何等待所有后台任务？
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#236-正在运行的任务是否会阻止事件循环退出" class="md-nav__link">
    23.6 正在运行的任务是否会阻止事件循环退出？
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#237-如何显示运行任务的进度" class="md-nav__link">
    23.7 如何显示运行任务的进度？
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#238-如何在延迟后运行任务" class="md-nav__link">
    23.8 如何在延迟后运行任务？
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#239-如何运行后续任务" class="md-nav__link">
    23.9 如何运行后续任务？
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2310-如何在-asyncio-中执行阻塞-io-或-cpu-密集型函数" class="md-nav__link">
    23.10 如何在 Asyncio 中执行阻塞 I/O 或 CPU 密集型函数？
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#24-使用-asyncio-的常见反对意见" class="md-nav__link">
    24. 使用 Asyncio 的常见反对意见
  </a>
  
    <nav class="md-nav" aria-label="24. 使用 Asyncio 的常见反对意见">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#241-全局解释器锁-gil-怎么样" class="md-nav__link">
    24.1 全局解释器锁 (GIL) 怎么样？
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#242-python-协程是真实的吗" class="md-nav__link">
    24.2 Python 协程是“真实的”吗？
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#243-python-的并发性不是有问题吗" class="md-nav__link">
    24.3 Python 的并发性不是有问题吗？
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#244-对于并发来说python-不是一个糟糕的选择吗" class="md-nav__link">
    24.4 对于并发来说，Python 不是一个糟糕的选择吗？
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#255-为什么不使用线程来代替" class="md-nav__link">
    25.5 为什么不使用线程来代替？
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#25-进一步阅读" class="md-nav__link">
    25. 进一步阅读
  </a>
  
    <nav class="md-nav" aria-label="25. 进一步阅读">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#251-python-异步书籍" class="md-nav__link">
    25.1 Python 异步书籍
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#252-apis" class="md-nav__link">
    25.2 APIs
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#253-参考" class="md-nav__link">
    25.3 参考
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#26-结论" class="md-nav__link">
    26. 结论
  </a>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
      
      
      <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_4" >
      
      
        
          
        
          
        
      
      
        <label class="md-nav__link" for="__nav_4" id="__nav_4_label" tabindex="0">
          互联网协议
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_4_label" aria-expanded="false">
        <label class="md-nav__title" for="__nav_4">
          <span class="md-nav__icon md-icon"></span>
          互联网协议
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../network/internet_protocol_suite_part_i/" class="md-nav__link">
        互联网协议入门（一）
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../network/internet_protocol_suite_part_ii/" class="md-nav__link">
        互联网协议入门（二）
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
      
      
      <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_5" >
      
      
        
          
            
          
        
          
        
          
        
      
      
        
        
        <div class="md-nav__link md-nav__link--index ">
          <a href="../http/">HTTP</a>
          
            <label for="__nav_5">
              <span class="md-nav__icon md-icon"></span>
            </label>
          
        </div>
      
      <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_5_label" aria-expanded="false">
        <label class="md-nav__title" for="__nav_5">
          <span class="md-nav__icon md-icon"></span>
          HTTP
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../http/http-referer/" class="md-nav__link">
        HTTP Referer 教程
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../http/https/" class="md-nav__link">
        HTTPS 升级指南
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
      
      
      <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_6" >
      
      
        
          
        
          
        
      
      
        <label class="md-nav__link" for="__nav_6" id="__nav_6_label" tabindex="0">
          REST ful
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_6_label" aria-expanded="false">
        <label class="md-nav__title" for="__nav_6">
          <span class="md-nav__icon md-icon"></span>
          REST ful
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../rest-ful/restapi/" class="md-nav__link">
        Restful API 设计指南
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../rest-ful/restapibsetp/" class="md-nav__link">
        RESTful API 最佳实践
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
      
      
      <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_7" >
      
      
        
          
        
          
        
          
        
          
        
          
        
      
      
        <label class="md-nav__link" for="__nav_7" id="__nav_7_label" tabindex="0">
          Git
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_7_label" aria-expanded="false">
        <label class="md-nav__title" for="__nav_7">
          <span class="md-nav__icon md-icon"></span>
          Git
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../git/git-branch-manage/" class="md-nav__link">
        Git分支管理策略
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../git/git-remote/" class="md-nav__link">
        Git远程操作详解
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../git/git-use-process/" class="md-nav__link">
        Git 使用规范流程
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../git/git-cheat-sheet/" class="md-nav__link">
        常用 Git 命令清单
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../git/git-work-flow/" class="md-nav__link">
        Git 协作流程
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
      
      
      <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_8" >
      
      
        
          
        
      
      
        <label class="md-nav__link" for="__nav_8" id="__nav_8_label" tabindex="0">
          系统设计
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_8_label" aria-expanded="false">
        <label class="md-nav__title" for="__nav_8">
          <span class="md-nav__icon md-icon"></span>
          系统设计
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../system-design/perm_design/" class="md-nav__link">
        权限系统的设计
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../about/" class="md-nav__link">
        关于
      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="目录">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      目录
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#1-什么是异步编程" class="md-nav__link">
    1. 什么是异步编程
  </a>
  
    <nav class="md-nav" aria-label="1. 什么是异步编程">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#11-异步任务" class="md-nav__link">
    1.1 异步任务
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#12-异步编程" class="md-nav__link">
    1.2 异步编程
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#13-python-异步编程" class="md-nav__link">
    1.3 Python 异步编程
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#2-asyncio-是什么" class="md-nav__link">
    2. Asyncio 是什么
  </a>
  
    <nav class="md-nav" aria-label="2. Asyncio 是什么">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#21-对-python-进行更改以添加对协程的支持" class="md-nav__link">
    2.1 对 Python 进行更改以添加对协程的支持
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#22-asyncio-模块" class="md-nav__link">
    2.2 asyncio 模块
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#3-asyncio-在什么时候使用" class="md-nav__link">
    3. Asyncio 在什么时候使用
  </a>
  
    <nav class="md-nav" aria-label="3. Asyncio 在什么时候使用">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#31-使用python-asyncio的原因" class="md-nav__link">
    3.1 使用Python Asyncio的原因
  </a>
  
    <nav class="md-nav" aria-label="3.1 使用Python Asyncio的原因">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#311-原因-1-使用协程" class="md-nav__link">
    3.1.1 原因 1: 使用协程
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#312-原因-2-使用异步编程" class="md-nav__link">
    3.1.2 原因 2: 使用异步编程
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#313-原因-3-使用非阻塞io" class="md-nav__link">
    3.1.3 原因 3: 使用非阻塞I/O
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#32-使用asyncio的其他原因" class="md-nav__link">
    3.2 使用Asyncio的其他原因
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#33-asyncio在什么时候不适用" class="md-nav__link">
    3.3 Asyncio在什么时候不适用
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#4-python-中的协程" class="md-nav__link">
    4. Python 中的协程
  </a>
  
    <nav class="md-nav" aria-label="4. Python 中的协程">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#41-什么是协程" class="md-nav__link">
    4.1 什么是协程
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#42-协程与例程和子例程" class="md-nav__link">
    4.2 协程与例程和子例程
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#43-协程与生成器" class="md-nav__link">
    4.3 协程与生成器
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#44-协程与任务" class="md-nav__link">
    4.4 协程与任务
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#45-协程与线程" class="md-nav__link">
    4.5 协程与线程
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#46-协程与进程" class="md-nav__link">
    4.6 协程与进程
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#47-python-何时添加了协程" class="md-nav__link">
    4.7 Python 何时添加了协程
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#5-定义创建和运行协程" class="md-nav__link">
    5. 定义、创建和运行协程
  </a>
  
    <nav class="md-nav" aria-label="5. 定义、创建和运行协程">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#51-如何定义协程" class="md-nav__link">
    5.1 如何定义协程
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#52-如何创建协程" class="md-nav__link">
    5.2 如何创建协程
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#53-python中如何运行协程" class="md-nav__link">
    5.3 Python中如何运行协程
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#6-事件循环是什么" class="md-nav__link">
    6. 事件循环是什么
  </a>
  
    <nav class="md-nav" aria-label="6. 事件循环是什么">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#61-asyncio-的事件循环是什么" class="md-nav__link">
    6.1 Asyncio 的事件循环是什么
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#62-事件循环如何获取和启动" class="md-nav__link">
    6.2 事件循环如何获取和启动
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#63-事件循环对象是什么" class="md-nav__link">
    6.3 事件循环对象是什么
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#64-为什么要访问事件循环" class="md-nav__link">
    6.4 为什么要访问事件循环
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#7-asyncio-任务的创建和运行" class="md-nav__link">
    7. Asyncio 任务的创建和运行
  </a>
  
    <nav class="md-nav" aria-label="7. Asyncio 任务的创建和运行">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#71-asyncio-任务是什么" class="md-nav__link">
    7.1 Asyncio 任务是什么
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#72-怎么创建任务" class="md-nav__link">
    7.2 怎么创建任务
  </a>
  
    <nav class="md-nav" aria-label="7.2 怎么创建任务">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#721-使用高级-api-创建任务" class="md-nav__link">
    7.2.1 使用高级 API 创建任务
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#722-使用低级-api-创建任务" class="md-nav__link">
    7.2.2 使用低级 API 创建任务
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#73-何时运行任务" class="md-nav__link">
    7.3 何时运行任务？
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#8-使用和查询任务" class="md-nav__link">
    8. 使用和查询任务
  </a>
  
    <nav class="md-nav" aria-label="8. 使用和查询任务">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#81-任务的生命周期" class="md-nav__link">
    8.1 任务的生命周期
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#82-如何检查任务的状态" class="md-nav__link">
    8.2 如何检查任务的状态
  </a>
  
    <nav class="md-nav" aria-label="8.2 如何检查任务的状态">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#821-检查任务是否完成" class="md-nav__link">
    8.2.1 检查任务是否完成
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#822-检查任务是否被取消" class="md-nav__link">
    8.2.2 检查任务是否被取消
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#83-如何获取任务结果" class="md-nav__link">
    8.3 如何获取任务结果
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#84-如何获取任务异常" class="md-nav__link">
    8.4 如何获取任务异常
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#85-如何取消任务" class="md-nav__link">
    8.5 如何取消任务
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#86-如何在任务中使用回调" class="md-nav__link">
    8.6 如何在任务中使用回调
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#87-如何设置任务名称" class="md-nav__link">
    8.7 如何设置任务名称
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#9-当前和正在运行的任务" class="md-nav__link">
    9. 当前和正在运行的任务
  </a>
  
    <nav class="md-nav" aria-label="9. 当前和正在运行的任务">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#91-如何获取当前任务" class="md-nav__link">
    9.1 如何获取当前任务
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#92-如何获取所有任务" class="md-nav__link">
    9.2 如何获取所有任务
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#10-同时运行多个协程" class="md-nav__link">
    10. 同时运行多个协程
  </a>
  
    <nav class="md-nav" aria-label="10. 同时运行多个协程">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#101-什么是-asyncio-gather" class="md-nav__link">
    10.1 什么是 Asyncio Gather()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#102-如何使用-asyncio-gather" class="md-nav__link">
    10.2 如何使用 Asyncio Gather()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#103-对于列表中的多个协程的-gather-示例" class="md-nav__link">
    10.3 对于列表中的多个协程的 Gather() 示例
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#11-等待任务的集合" class="md-nav__link">
    11. 等待任务的集合
  </a>
  
    <nav class="md-nav" aria-label="11. 等待任务的集合">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#111-什么是-asynciowait" class="md-nav__link">
    11.1 什么是 asyncio.wait()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#112-如何使用-asynciowait" class="md-nav__link">
    11.2 如何使用 asyncio.wait()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#113-等待所有任务的示例" class="md-nav__link">
    11.3 等待所有任务的示例
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#12-等待有时间限制的协程" class="md-nav__link">
    12. 等待有时间限制的协程
  </a>
  
    <nav class="md-nav" aria-label="12. 等待有时间限制的协程">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#121-什么是-asyncio-wait_for" class="md-nav__link">
    12.1 什么是 Asyncio wait_for()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#122-如何使用-asyncio-wait_for" class="md-nav__link">
    12.2 如何使用 Asyncio wait_for()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#123-带有超时的-asyncio-wait_for-示例" class="md-nav__link">
    12.3 带有超时的 Asyncio wait_for() 示例
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#13-防止任务被取消" class="md-nav__link">
    13. 防止任务被取消
  </a>
  
    <nav class="md-nav" aria-label="13. 防止任务被取消">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#131-什么是-asyncio-shield" class="md-nav__link">
    13.1 什么是 Asyncio shield()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#132-如何使用-asyncioshield" class="md-nav__link">
    13.2 如何使用 Asyncioshield()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#133-任务的-asyncioshield-示例" class="md-nav__link">
    13.3 任务的 Asyncioshield() 示例
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#14-在-asyncio-中运行阻塞任务" class="md-nav__link">
    14. 在 Asyncio 中运行阻塞任务
  </a>
  
    <nav class="md-nav" aria-label="14. 在 Asyncio 中运行阻塞任务">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#141-需要在-asyncio-中运行阻塞任务" class="md-nav__link">
    14.1 需要在 Asyncio 中运行阻塞任务
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#142-如何运行阻塞任务" class="md-nav__link">
    14.2 如何运行阻塞任务
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#143-使用-to_thread-在-asyncio-中运行-io-密集型任务的示例" class="md-nav__link">
    14.3 使用 to_thread() 在 Asyncio 中运行 I/O 密集型任务的示例
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#15-异步迭代器" class="md-nav__link">
    15. 异步迭代器
  </a>
  
    <nav class="md-nav" aria-label="15. 异步迭代器">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#151-什么是异步迭代器" class="md-nav__link">
    15.1 什么是异步迭代器
  </a>
  
    <nav class="md-nav" aria-label="15.1 什么是异步迭代器">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#1511-迭代器" class="md-nav__link">
    15.1.1 迭代器
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1512-异步迭代器" class="md-nav__link">
    15.1.2 异步迭代器
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#152-什么是async-for循环" class="md-nav__link">
    15.2 什么是“async for”循环？
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#153-如何使用异步迭代器" class="md-nav__link">
    15.3 如何使用异步迭代器
  </a>
  
    <nav class="md-nav" aria-label="15.3 如何使用异步迭代器">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#1531-定义异步迭代器" class="md-nav__link">
    15.3.1 定义异步迭代器
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1532-创建异步迭代器" class="md-nav__link">
    15.3.2 创建异步迭代器
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1533-单步执行异步迭代器" class="md-nav__link">
    15.3.3 单步执行异步迭代器
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1534-遍历异步迭代器" class="md-nav__link">
    15.3.4 遍历异步迭代器
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#154-异步迭代器的示例" class="md-nav__link">
    15.4 异步迭代器的示例
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#16-异步生成器" class="md-nav__link">
    16. 异步生成器
  </a>
  
    <nav class="md-nav" aria-label="16. 异步生成器">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#161-什么是异步生成器" class="md-nav__link">
    16.1 什么是异步生成器
  </a>
  
    <nav class="md-nav" aria-label="16.1 什么是异步生成器">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#1611-生成器" class="md-nav__link">
    16.1.1 生成器
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1612-异步生成器" class="md-nav__link">
    16.1.2 异步生成器
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#162-如何使用异步生成器" class="md-nav__link">
    16.2 如何使用异步生成器
  </a>
  
    <nav class="md-nav" aria-label="16.2 如何使用异步生成器">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#1621-定义异步生成器" class="md-nav__link">
    16.2.1 定义异步生成器
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1622-创建异步生成器" class="md-nav__link">
    16.2.2 创建异步生成器
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1623-使用异步生成器" class="md-nav__link">
    16.2.3 使用异步生成器
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1624-遍历异步生成器" class="md-nav__link">
    16.2.4 遍历异步生成器
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#163-异步生成器示例" class="md-nav__link">
    16.3 异步生成器示例
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#17-异步上下文管理器" class="md-nav__link">
    17. 异步上下文管理器
  </a>
  
    <nav class="md-nav" aria-label="17. 异步上下文管理器">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#171-什么是异步上下文管理器" class="md-nav__link">
    17.1 什么是异步上下文管理器
  </a>
  
    <nav class="md-nav" aria-label="17.1 什么是异步上下文管理器">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#1711--上下文管理器" class="md-nav__link">
    17.1.1  上下文管理器
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1712-异步上下文管理器" class="md-nav__link">
    17.1.2 异步上下文管理器
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#172-如何使用异步上下文管理器" class="md-nav__link">
    17.2 如何使用异步上下文管理器
  </a>
  
    <nav class="md-nav" aria-label="17.2 如何使用异步上下文管理器">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#1721-定义异步上下文管理器" class="md-nav__link">
    17.2.1 定义异步上下文管理器
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1722-使用异步上下文管理器" class="md-nav__link">
    17.2.2 使用异步上下文管理器
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#173-异步上下文管理器和async-with的示例" class="md-nav__link">
    17.3 异步上下文管理器和“async with”的示例
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#18-异步推导式" class="md-nav__link">
    18. 异步推导式
  </a>
  
    <nav class="md-nav" aria-label="18. 异步推导式">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#181-什么是异步推导式" class="md-nav__link">
    18.1 什么是异步推导式
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#182-推导式" class="md-nav__link">
    18.2 推导式
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#183-异步推导式" class="md-nav__link">
    18.3 异步推导式
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#184-await-推导式" class="md-nav__link">
    18.4 Await 推导式
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#19-在非阻塞子进程中运行命令" class="md-nav__link">
    19. 在非阻塞子进程中运行命令
  </a>
  
    <nav class="md-nav" aria-label="19. 在非阻塞子进程中运行命令">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#191-什么是-asynciosubprocessprocess" class="md-nav__link">
    19.1 什么是 asyncio.subprocess.Process
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#192-如何直接运行命令" class="md-nav__link">
    19.2 如何直接运行命令
  </a>
  
    <nav class="md-nav" aria-label="19.2 如何直接运行命令">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#1921-如何使用-asyncio-的-create_subprocess_exec" class="md-nav__link">
    19.2.1 如何使用 Asyncio 的 create_subprocess_exec()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1922-asyncio-的-create_subprocess_exec-的示例" class="md-nav__link">
    19.2.2 Asyncio 的 create_subprocess_exec() 的示例
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#193-如何跟shell一起运行一个命令" class="md-nav__link">
    19.3 如何跟shell一起运行一个命令
  </a>
  
    <nav class="md-nav" aria-label="19.3 如何跟shell一起运行一个命令">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#1931-如何使用-asyncio-的-create_subprocess_shell" class="md-nav__link">
    19.3.1 如何使用 Asyncio 的 create_subprocess_shell()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1932-asyncio-的-create_subprocess_shell-的示例" class="md-nav__link">
    19.3.2 Asyncio 的 create_subprocess_shell() 的示例
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#20-非阻塞流" class="md-nav__link">
    20. 非阻塞流
  </a>
  
    <nav class="md-nav" aria-label="20. 非阻塞流">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#201-asyncio-的流" class="md-nav__link">
    20.1 Asyncio 的流
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#202-如何打开一个连接" class="md-nav__link">
    20.2 如何打开一个连接
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#203-如何启动一个侦听服务" class="md-nav__link">
    20.3 如何启动一个侦听服务
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#204-如何使用-streamwriter-写入数据" class="md-nav__link">
    20.4 如何使用 StreamWriter 写入数据
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#205-如何使用-streamreader-读取数据" class="md-nav__link">
    20.5 如何使用 StreamReader 读取数据
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#206-如何关闭连接" class="md-nav__link">
    20.6 如何关闭连接
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#21-检查网站状态的示例" class="md-nav__link">
    21. 检查网站状态的示例
  </a>
  
    <nav class="md-nav" aria-label="21. 检查网站状态的示例">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#211-如何使用-asyncio-检查-http-状态" class="md-nav__link">
    21.1 如何使用 Asyncio 检查 HTTP 状态
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#212-打开-http-连接" class="md-nav__link">
    21.2 打开 HTTP 连接
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#213-写入-http-请求" class="md-nav__link">
    21.3 写入 HTTP 请求
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#214-读取-http-响应" class="md-nav__link">
    21.4 读取 HTTP 响应
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#215-关闭-http-连接" class="md-nav__link">
    21.5 关闭 HTTP 连接
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#216-按顺序检查-http-状态的示例" class="md-nav__link">
    21.6 按顺序检查 HTTP 状态的示例
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#217-并发检查网站状态的示例" class="md-nav__link">
    21.7 并发检查网站状态的示例
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#22-python-asyncio-常见错误" class="md-nav__link">
    22. Python Asyncio 常见错误
  </a>
  
    <nav class="md-nav" aria-label="22. Python Asyncio 常见错误">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#221-错误-1-尝试通过函数调用的方式来运行协程" class="md-nav__link">
    22.1 错误 1: 尝试通过函数调用的方式来运行协程
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#222-错误-2-不在事件循环中运行协程" class="md-nav__link">
    22.2 错误 2: 不在事件循环中运行协程
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#223-错误-3-使用低级的-asyncio-api" class="md-nav__link">
    22.3 错误 3: 使用低级的 Asyncio API
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#224-错误-4-退出主协程太早" class="md-nav__link">
    22.4 错误 4: 退出主协程太早
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#225-错误-5-假设竞争条件和死锁是不可能的" class="md-nav__link">
    22.5 错误 5: 假设竞争条件和死锁是不可能的
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#23-python-asyncio-常见问题" class="md-nav__link">
    23. Python Asyncio 常见问题
  </a>
  
    <nav class="md-nav" aria-label="23. Python Asyncio 常见问题">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#231-如何停止任务" class="md-nav__link">
    23.1 如何停止任务？
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#232-如何等待任务完成" class="md-nav__link">
    23.2 如何等待任务完成？
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#233-如何获取任务的返回值" class="md-nav__link">
    23.3 如何获取任务的返回值？
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#234-如何在后台运行任务" class="md-nav__link">
    23.4 如何在后台运行任务？
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#235-如何等待所有后台任务" class="md-nav__link">
    23.5 如何等待所有后台任务？
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#236-正在运行的任务是否会阻止事件循环退出" class="md-nav__link">
    23.6 正在运行的任务是否会阻止事件循环退出？
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#237-如何显示运行任务的进度" class="md-nav__link">
    23.7 如何显示运行任务的进度？
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#238-如何在延迟后运行任务" class="md-nav__link">
    23.8 如何在延迟后运行任务？
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#239-如何运行后续任务" class="md-nav__link">
    23.9 如何运行后续任务？
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2310-如何在-asyncio-中执行阻塞-io-或-cpu-密集型函数" class="md-nav__link">
    23.10 如何在 Asyncio 中执行阻塞 I/O 或 CPU 密集型函数？
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#24-使用-asyncio-的常见反对意见" class="md-nav__link">
    24. 使用 Asyncio 的常见反对意见
  </a>
  
    <nav class="md-nav" aria-label="24. 使用 Asyncio 的常见反对意见">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#241-全局解释器锁-gil-怎么样" class="md-nav__link">
    24.1 全局解释器锁 (GIL) 怎么样？
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#242-python-协程是真实的吗" class="md-nav__link">
    24.2 Python 协程是“真实的”吗？
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#243-python-的并发性不是有问题吗" class="md-nav__link">
    24.3 Python 的并发性不是有问题吗？
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#244-对于并发来说python-不是一个糟糕的选择吗" class="md-nav__link">
    24.4 对于并发来说，Python 不是一个糟糕的选择吗？
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#255-为什么不使用线程来代替" class="md-nav__link">
    25.5 为什么不使用线程来代替？
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#25-进一步阅读" class="md-nav__link">
    25. 进一步阅读
  </a>
  
    <nav class="md-nav" aria-label="25. 进一步阅读">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#251-python-异步书籍" class="md-nav__link">
    25.1 Python 异步书籍
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#252-apis" class="md-nav__link">
    25.2 APIs
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#253-参考" class="md-nav__link">
    25.3 参考
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#26-结论" class="md-nav__link">
    26. 结论
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  

  
  


<h1 id="python-asyncio-完整指南">Python Asyncio: 完整指南<a class="headerlink" href="#python-asyncio-完整指南" title="Permanent link">&para;</a></h1>
<p><strong>Python Asyncio: The Complete Guide</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="1:2"><input checked="checked" id="__tabbed_1_1" name="__tabbed_1" type="radio" /><input id="__tabbed_1_2" name="__tabbed_1" type="radio" /><div class="tabbed-labels"><label for="__tabbed_1_1">English</label><label for="__tabbed_1_2">Chinese</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<p><strong>Asyncio</strong> allows us to use asynchronous programming with coroutine-based concurrency in Python.</p>
<p>Although asyncio has been available in Python for many years now, it remains one of the most interesting and yet one of the most frustrating areas of Python.</p>
<p>It is just plain hard to get started with asyncio for new developers.</p>
<p>This guide provides a detailed and comprehensive(全面的) review of asyncio in Python, including how to define, create and run coroutines, what is asynchronous programming, what is non-blocking-io, concurrency primitives(原始并发) used with coroutines, common questions, and best practices.</p>
<p>This is a massive 29,000+ word guide. You may want to bookmark it so you can refer to it as you develop your concurrent programs.</p>
<p>Let’s dive in.</p>
</div>
<div class="tabbed-block">
<p><strong>Asyncio</strong> 允许我们在 Python 中使用基于协程的并发的异步编程。</p>
<p>尽管 asyncio 已经在 Python 中使用很多年了，但它仍然是 Python 中最有趣但也是最令人沮丧的领域之一。</p>
<p>对于新开发人员来说，开始使用 asyncio 非常困难。</p>
<p>本指南对 Python 中的 asyncio 进行了详细而全面的回顾，包括如何定义、创建和运行协程、什么是异步编程、什么是非阻塞 io、与协程一起使用的并发原语、 常见问题和最佳实践。</p>
<p>这是一本超过 29,000 字的海量指南。 您可能需要为其添加书签，以便在开发并发程序时可以参考它。</p>
<p>让我们深入了解一下。</p>
</div>
</div>
</div>
<h2 id="1-什么是异步编程">1. 什么是异步编程<a class="headerlink" href="#1-什么是异步编程" title="Permanent link">&para;</a></h2>
<p><strong>1. What is Asynchronous Programming</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="2:2"><input checked="checked" id="__tabbed_2_1" name="__tabbed_2" type="radio" /><input id="__tabbed_2_2" name="__tabbed_2" type="radio" /><div class="tabbed-labels"><label for="__tabbed_2_1">English</label><label for="__tabbed_2_2">Chinese</label></div>
<div class="tabbed-content">
<div class="tabbed-block"></div>
<div class="tabbed-block"></div>
</div>
</div>
<h3 id="11-异步任务">1.1 异步任务<a class="headerlink" href="#11-异步任务" title="Permanent link">&para;</a></h3>
<p><strong>1.1 Asynchronous Tasks</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="3:2"><input checked="checked" id="__tabbed_3_1" name="__tabbed_3" type="radio" /><input id="__tabbed_3_2" name="__tabbed_3" type="radio" /><div class="tabbed-labels"><label for="__tabbed_3_1">English</label><label for="__tabbed_3_2">Chinese</label></div>
<div class="tabbed-content">
<div class="tabbed-block"></div>
<div class="tabbed-block"></div>
</div>
</div>
<h3 id="12-异步编程">1.2 异步编程<a class="headerlink" href="#12-异步编程" title="Permanent link">&para;</a></h3>
<p><strong>1.2 Asynchronous Programming</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="4:2"><input checked="checked" id="__tabbed_4_1" name="__tabbed_4" type="radio" /><input id="__tabbed_4_2" name="__tabbed_4" type="radio" /><div class="tabbed-labels"><label for="__tabbed_4_1">English</label><label for="__tabbed_4_2">Chinese</label></div>
<div class="tabbed-content">
<div class="tabbed-block"></div>
<div class="tabbed-block"></div>
</div>
</div>
<h3 id="13-python-异步编程">1.3 Python 异步编程<a class="headerlink" href="#13-python-异步编程" title="Permanent link">&para;</a></h3>
<p><strong>1.3 Asynchronous Programming in Python</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="5:2"><input checked="checked" id="__tabbed_5_1" name="__tabbed_5" type="radio" /><input id="__tabbed_5_2" name="__tabbed_5" type="radio" /><div class="tabbed-labels"><label for="__tabbed_5_1">English</label><label for="__tabbed_5_2">Chinese</label></div>
<div class="tabbed-content">
<div class="tabbed-block"></div>
<div class="tabbed-block"></div>
</div>
</div>
<h2 id="2-asyncio-是什么">2. Asyncio 是什么<a class="headerlink" href="#2-asyncio-是什么" title="Permanent link">&para;</a></h2>
<p><strong>2. What is Asyncio</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="6:2"><input checked="checked" id="__tabbed_6_1" name="__tabbed_6" type="radio" /><input id="__tabbed_6_2" name="__tabbed_6" type="radio" /><div class="tabbed-labels"><label for="__tabbed_6_1">English</label><label for="__tabbed_6_2">Chinese</label></div>
<div class="tabbed-content">
<div class="tabbed-block"></div>
<div class="tabbed-block"></div>
</div>
</div>
<h3 id="21-对-python-进行更改以添加对协程的支持">2.1 对 Python 进行更改以添加对协程的支持<a class="headerlink" href="#21-对-python-进行更改以添加对协程的支持" title="Permanent link">&para;</a></h3>
<p><strong>2.1 Changes to Python to add Support for Coroutines</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="7:2"><input checked="checked" id="__tabbed_7_1" name="__tabbed_7" type="radio" /><input id="__tabbed_7_2" name="__tabbed_7" type="radio" /><div class="tabbed-labels"><label for="__tabbed_7_1">English</label><label for="__tabbed_7_2">Chinese</label></div>
<div class="tabbed-content">
<div class="tabbed-block"></div>
<div class="tabbed-block"></div>
</div>
</div>
<h3 id="22-asyncio-模块">2.2 asyncio 模块<a class="headerlink" href="#22-asyncio-模块" title="Permanent link">&para;</a></h3>
<p><strong>2.2 The asyncio Module</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="8:2"><input checked="checked" id="__tabbed_8_1" name="__tabbed_8" type="radio" /><input id="__tabbed_8_2" name="__tabbed_8" type="radio" /><div class="tabbed-labels"><label for="__tabbed_8_1">English</label><label for="__tabbed_8_2">Chinese</label></div>
<div class="tabbed-content">
<div class="tabbed-block"></div>
<div class="tabbed-block"></div>
</div>
</div>
<h2 id="3-asyncio-在什么时候使用">3. Asyncio 在什么时候使用<a class="headerlink" href="#3-asyncio-在什么时候使用" title="Permanent link">&para;</a></h2>
<p><strong>3. When to Use Asyncio</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="9:2"><input checked="checked" id="__tabbed_9_1" name="__tabbed_9" type="radio" /><input id="__tabbed_9_2" name="__tabbed_9" type="radio" /><div class="tabbed-labels"><label for="__tabbed_9_1">English</label><label for="__tabbed_9_2">Chinese</label></div>
<div class="tabbed-content">
<div class="tabbed-block"></div>
<div class="tabbed-block"></div>
</div>
</div>
<h3 id="31-使用python-asyncio的原因">3.1 使用Python Asyncio的原因<a class="headerlink" href="#31-使用python-asyncio的原因" title="Permanent link">&para;</a></h3>
<p><strong>3.1 Reasons to Use Asyncio in Python</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="10:2"><input checked="checked" id="__tabbed_10_1" name="__tabbed_10" type="radio" /><input id="__tabbed_10_2" name="__tabbed_10" type="radio" /><div class="tabbed-labels"><label for="__tabbed_10_1">English</label><label for="__tabbed_10_2">Chinese</label></div>
<div class="tabbed-content">
<div class="tabbed-block"></div>
<div class="tabbed-block"></div>
</div>
</div>
<h4 id="311-原因-1-使用协程">3.1.1 原因 1: 使用协程<a class="headerlink" href="#311-原因-1-使用协程" title="Permanent link">&para;</a></h4>
<p><strong>3.1.1 Reason 1: To Use Coroutines</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="11:2"><input checked="checked" id="__tabbed_11_1" name="__tabbed_11" type="radio" /><input id="__tabbed_11_2" name="__tabbed_11" type="radio" /><div class="tabbed-labels"><label for="__tabbed_11_1">English</label><label for="__tabbed_11_2">Chinese</label></div>
<div class="tabbed-content">
<div class="tabbed-block"></div>
<div class="tabbed-block"></div>
</div>
</div>
<h4 id="312-原因-2-使用异步编程">3.1.2 原因 2: 使用异步编程<a class="headerlink" href="#312-原因-2-使用异步编程" title="Permanent link">&para;</a></h4>
<p><strong>3.1.2 Reason 2: To Use Asynchronous Programming</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="12:2"><input checked="checked" id="__tabbed_12_1" name="__tabbed_12" type="radio" /><input id="__tabbed_12_2" name="__tabbed_12" type="radio" /><div class="tabbed-labels"><label for="__tabbed_12_1">English</label><label for="__tabbed_12_2">Chinese</label></div>
<div class="tabbed-content">
<div class="tabbed-block"></div>
<div class="tabbed-block"></div>
</div>
</div>
<h4 id="313-原因-3-使用非阻塞io">3.1.3 原因 3: 使用非阻塞I/O<a class="headerlink" href="#313-原因-3-使用非阻塞io" title="Permanent link">&para;</a></h4>
<p><strong>3.1.3 Reason 3: To Use Non-Blocking I/O</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="13:2"><input checked="checked" id="__tabbed_13_1" name="__tabbed_13" type="radio" /><input id="__tabbed_13_2" name="__tabbed_13" type="radio" /><div class="tabbed-labels"><label for="__tabbed_13_1">English</label><label for="__tabbed_13_2">Chinese</label></div>
<div class="tabbed-content">
<div class="tabbed-block"></div>
<div class="tabbed-block"></div>
</div>
</div>
<h3 id="32-使用asyncio的其他原因">3.2 使用Asyncio的其他原因<a class="headerlink" href="#32-使用asyncio的其他原因" title="Permanent link">&para;</a></h3>
<p><strong>3.2 Other Reasons to Use Asyncio</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="14:2"><input checked="checked" id="__tabbed_14_1" name="__tabbed_14" type="radio" /><input id="__tabbed_14_2" name="__tabbed_14" type="radio" /><div class="tabbed-labels"><label for="__tabbed_14_1">English</label><label for="__tabbed_14_2">Chinese</label></div>
<div class="tabbed-content">
<div class="tabbed-block"></div>
<div class="tabbed-block"></div>
</div>
</div>
<h3 id="33-asyncio在什么时候不适用">3.3 Asyncio在什么时候不适用<a class="headerlink" href="#33-asyncio在什么时候不适用" title="Permanent link">&para;</a></h3>
<p><strong>3.3 When to Not Use Asyncio</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="15:2"><input checked="checked" id="__tabbed_15_1" name="__tabbed_15" type="radio" /><input id="__tabbed_15_2" name="__tabbed_15" type="radio" /><div class="tabbed-labels"><label for="__tabbed_15_1">English</label><label for="__tabbed_15_2">Chinese</label></div>
<div class="tabbed-content">
<div class="tabbed-block"></div>
<div class="tabbed-block"></div>
</div>
</div>
<h2 id="4-python-中的协程">4. Python 中的协程<a class="headerlink" href="#4-python-中的协程" title="Permanent link">&para;</a></h2>
<p><strong>4. Coroutines in Python</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="16:2"><input checked="checked" id="__tabbed_16_1" name="__tabbed_16" type="radio" /><input id="__tabbed_16_2" name="__tabbed_16" type="radio" /><div class="tabbed-labels"><label for="__tabbed_16_1">English</label><label for="__tabbed_16_2">Chinese</label></div>
<div class="tabbed-content">
<div class="tabbed-block"></div>
<div class="tabbed-block"></div>
</div>
</div>
<h3 id="41-什么是协程">4.1 什么是协程<a class="headerlink" href="#41-什么是协程" title="Permanent link">&para;</a></h3>
<p><strong>4.1 What is a Coroutine</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="17:2"><input checked="checked" id="__tabbed_17_1" name="__tabbed_17" type="radio" /><input id="__tabbed_17_2" name="__tabbed_17" type="radio" /><div class="tabbed-labels"><label for="__tabbed_17_1">English</label><label for="__tabbed_17_2">Chinese</label></div>
<div class="tabbed-content">
<div class="tabbed-block"></div>
<div class="tabbed-block"></div>
</div>
</div>
<h3 id="42-协程与例程和子例程">4.2 协程与例程和子例程<a class="headerlink" href="#42-协程与例程和子例程" title="Permanent link">&para;</a></h3>
<p><strong>4.2 Coroutine vs Routine and Subroutine</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="18:2"><input checked="checked" id="__tabbed_18_1" name="__tabbed_18" type="radio" /><input id="__tabbed_18_2" name="__tabbed_18" type="radio" /><div class="tabbed-labels"><label for="__tabbed_18_1">English</label><label for="__tabbed_18_2">Chinese</label></div>
<div class="tabbed-content">
<div class="tabbed-block"></div>
<div class="tabbed-block"></div>
</div>
</div>
<h3 id="43-协程与生成器">4.3 协程与生成器<a class="headerlink" href="#43-协程与生成器" title="Permanent link">&para;</a></h3>
<p><strong>4.3 Coroutine vs Generator</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="19:2"><input checked="checked" id="__tabbed_19_1" name="__tabbed_19" type="radio" /><input id="__tabbed_19_2" name="__tabbed_19" type="radio" /><div class="tabbed-labels"><label for="__tabbed_19_1">English</label><label for="__tabbed_19_2">Chinese</label></div>
<div class="tabbed-content">
<div class="tabbed-block"></div>
<div class="tabbed-block"></div>
</div>
</div>
<h3 id="44-协程与任务">4.4 协程与任务<a class="headerlink" href="#44-协程与任务" title="Permanent link">&para;</a></h3>
<p><strong>4.4 Coroutine vs Task</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="20:2"><input checked="checked" id="__tabbed_20_1" name="__tabbed_20" type="radio" /><input id="__tabbed_20_2" name="__tabbed_20" type="radio" /><div class="tabbed-labels"><label for="__tabbed_20_1">English</label><label for="__tabbed_20_2">Chinese</label></div>
<div class="tabbed-content">
<div class="tabbed-block"></div>
<div class="tabbed-block"></div>
</div>
</div>
<h3 id="45-协程与线程">4.5 协程与线程<a class="headerlink" href="#45-协程与线程" title="Permanent link">&para;</a></h3>
<p><strong>4.5 Coroutine vs Thread</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="21:2"><input checked="checked" id="__tabbed_21_1" name="__tabbed_21" type="radio" /><input id="__tabbed_21_2" name="__tabbed_21" type="radio" /><div class="tabbed-labels"><label for="__tabbed_21_1">English</label><label for="__tabbed_21_2">Chinese</label></div>
<div class="tabbed-content">
<div class="tabbed-block"></div>
<div class="tabbed-block"></div>
</div>
</div>
<h3 id="46-协程与进程">4.6 协程与进程<a class="headerlink" href="#46-协程与进程" title="Permanent link">&para;</a></h3>
<p><strong>4.6 Coroutine vs Process</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="22:2"><input checked="checked" id="__tabbed_22_1" name="__tabbed_22" type="radio" /><input id="__tabbed_22_2" name="__tabbed_22" type="radio" /><div class="tabbed-labels"><label for="__tabbed_22_1">English</label><label for="__tabbed_22_2">Chinese</label></div>
<div class="tabbed-content">
<div class="tabbed-block"></div>
<div class="tabbed-block"></div>
</div>
</div>
<h3 id="47-python-何时添加了协程">4.7 Python 何时添加了协程<a class="headerlink" href="#47-python-何时添加了协程" title="Permanent link">&para;</a></h3>
<p><strong>4.7 When Were Coroutines Added to Python</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="23:2"><input checked="checked" id="__tabbed_23_1" name="__tabbed_23" type="radio" /><input id="__tabbed_23_2" name="__tabbed_23" type="radio" /><div class="tabbed-labels"><label for="__tabbed_23_1">English</label><label for="__tabbed_23_2">Chinese</label></div>
<div class="tabbed-content">
<div class="tabbed-block"></div>
<div class="tabbed-block"></div>
</div>
</div>
<h2 id="5-定义创建和运行协程">5. 定义、创建和运行协程<a class="headerlink" href="#5-定义创建和运行协程" title="Permanent link">&para;</a></h2>
<p><strong>5. Define, Create and Run Coroutines</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="24:2"><input checked="checked" id="__tabbed_24_1" name="__tabbed_24" type="radio" /><input id="__tabbed_24_2" name="__tabbed_24" type="radio" /><div class="tabbed-labels"><label for="__tabbed_24_1">English</label><label for="__tabbed_24_2">Chinese</label></div>
<div class="tabbed-content">
<div class="tabbed-block"></div>
<div class="tabbed-block"></div>
</div>
</div>
<h3 id="51-如何定义协程">5.1 如何定义协程<a class="headerlink" href="#51-如何定义协程" title="Permanent link">&para;</a></h3>
<p><strong>5.1 How to Define a Coroutine</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="25:2"><input checked="checked" id="__tabbed_25_1" name="__tabbed_25" type="radio" /><input id="__tabbed_25_2" name="__tabbed_25" type="radio" /><div class="tabbed-labels"><label for="__tabbed_25_1">English</label><label for="__tabbed_25_2">Chinese</label></div>
<div class="tabbed-content">
<div class="tabbed-block"></div>
<div class="tabbed-block"></div>
</div>
</div>
<h3 id="52-如何创建协程">5.2 如何创建协程<a class="headerlink" href="#52-如何创建协程" title="Permanent link">&para;</a></h3>
<p><strong>5.2 How to Create a Coroutine</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="26:2"><input checked="checked" id="__tabbed_26_1" name="__tabbed_26" type="radio" /><input id="__tabbed_26_2" name="__tabbed_26" type="radio" /><div class="tabbed-labels"><label for="__tabbed_26_1">English</label><label for="__tabbed_26_2">Chinese</label></div>
<div class="tabbed-content">
<div class="tabbed-block"></div>
<div class="tabbed-block"></div>
</div>
</div>
<h3 id="53-python中如何运行协程">5.3 Python中如何运行协程<a class="headerlink" href="#53-python中如何运行协程" title="Permanent link">&para;</a></h3>
<p><strong>5.3 How to Run a Coroutine From Python</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="27:2"><input checked="checked" id="__tabbed_27_1" name="__tabbed_27" type="radio" /><input id="__tabbed_27_2" name="__tabbed_27" type="radio" /><div class="tabbed-labels"><label for="__tabbed_27_1">English</label><label for="__tabbed_27_2">Chinese</label></div>
<div class="tabbed-content">
<div class="tabbed-block"></div>
<div class="tabbed-block"></div>
</div>
</div>
<h2 id="6-事件循环是什么">6. 事件循环是什么<a class="headerlink" href="#6-事件循环是什么" title="Permanent link">&para;</a></h2>
<p><strong>6. What is the Event Loop</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="28:2"><input checked="checked" id="__tabbed_28_1" name="__tabbed_28" type="radio" /><input id="__tabbed_28_2" name="__tabbed_28" type="radio" /><div class="tabbed-labels"><label for="__tabbed_28_1">English</label><label for="__tabbed_28_2">Chinese</label></div>
<div class="tabbed-content">
<div class="tabbed-block"></div>
<div class="tabbed-block"></div>
</div>
</div>
<h3 id="61-asyncio-的事件循环是什么">6.1 Asyncio 的事件循环是什么<a class="headerlink" href="#61-asyncio-的事件循环是什么" title="Permanent link">&para;</a></h3>
<p><strong>6.1 What is the Asyncio Event Loop</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="29:2"><input checked="checked" id="__tabbed_29_1" name="__tabbed_29" type="radio" /><input id="__tabbed_29_2" name="__tabbed_29" type="radio" /><div class="tabbed-labels"><label for="__tabbed_29_1">English</label><label for="__tabbed_29_2">Chinese</label></div>
<div class="tabbed-content">
<div class="tabbed-block"></div>
<div class="tabbed-block"></div>
</div>
</div>
<h3 id="62-事件循环如何获取和启动">6.2 事件循环如何获取和启动<a class="headerlink" href="#62-事件循环如何获取和启动" title="Permanent link">&para;</a></h3>
<p><strong>6.2 How To Start and Get An Event Loop</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="30:2"><input checked="checked" id="__tabbed_30_1" name="__tabbed_30" type="radio" /><input id="__tabbed_30_2" name="__tabbed_30" type="radio" /><div class="tabbed-labels"><label for="__tabbed_30_1">English</label><label for="__tabbed_30_2">Chinese</label></div>
<div class="tabbed-content">
<div class="tabbed-block"></div>
<div class="tabbed-block"></div>
</div>
</div>
<h3 id="63-事件循环对象是什么">6.3 事件循环对象是什么<a class="headerlink" href="#63-事件循环对象是什么" title="Permanent link">&para;</a></h3>
<p><strong>6.3 What is an Event Loop Object</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="31:2"><input checked="checked" id="__tabbed_31_1" name="__tabbed_31" type="radio" /><input id="__tabbed_31_2" name="__tabbed_31" type="radio" /><div class="tabbed-labels"><label for="__tabbed_31_1">English</label><label for="__tabbed_31_2">Chinese</label></div>
<div class="tabbed-content">
<div class="tabbed-block"></div>
<div class="tabbed-block"></div>
</div>
</div>
<h3 id="64-为什么要访问事件循环">6.4 为什么要访问事件循环<a class="headerlink" href="#64-为什么要访问事件循环" title="Permanent link">&para;</a></h3>
<p><strong>6.4 Why Get Access to The Event Loop</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="32:2"><input checked="checked" id="__tabbed_32_1" name="__tabbed_32" type="radio" /><input id="__tabbed_32_2" name="__tabbed_32" type="radio" /><div class="tabbed-labels"><label for="__tabbed_32_1">English</label><label for="__tabbed_32_2">Chinese</label></div>
<div class="tabbed-content">
<div class="tabbed-block"></div>
<div class="tabbed-block"></div>
</div>
</div>
<h2 id="7-asyncio-任务的创建和运行">7. Asyncio 任务的创建和运行<a class="headerlink" href="#7-asyncio-任务的创建和运行" title="Permanent link">&para;</a></h2>
<p><strong>7. Create and Run Asyncio Tasks</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="33:2"><input checked="checked" id="__tabbed_33_1" name="__tabbed_33" type="radio" /><input id="__tabbed_33_2" name="__tabbed_33" type="radio" /><div class="tabbed-labels"><label for="__tabbed_33_1">English</label><label for="__tabbed_33_2">Chinese</label></div>
<div class="tabbed-content">
<div class="tabbed-block"></div>
<div class="tabbed-block"></div>
</div>
</div>
<h3 id="71-asyncio-任务是什么">7.1 Asyncio 任务是什么<a class="headerlink" href="#71-asyncio-任务是什么" title="Permanent link">&para;</a></h3>
<p><strong>7.1 What is an Asyncio Task</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="34:2"><input checked="checked" id="__tabbed_34_1" name="__tabbed_34" type="radio" /><input id="__tabbed_34_2" name="__tabbed_34" type="radio" /><div class="tabbed-labels"><label for="__tabbed_34_1">English</label><label for="__tabbed_34_2">Chinese</label></div>
<div class="tabbed-content">
<div class="tabbed-block"></div>
<div class="tabbed-block"></div>
</div>
</div>
<h3 id="72-怎么创建任务">7.2 怎么创建任务<a class="headerlink" href="#72-怎么创建任务" title="Permanent link">&para;</a></h3>
<p><strong>7.2 How to Create a Task</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="35:2"><input checked="checked" id="__tabbed_35_1" name="__tabbed_35" type="radio" /><input id="__tabbed_35_2" name="__tabbed_35" type="radio" /><div class="tabbed-labels"><label for="__tabbed_35_1">English</label><label for="__tabbed_35_2">Chinese</label></div>
<div class="tabbed-content">
<div class="tabbed-block"></div>
<div class="tabbed-block"></div>
</div>
</div>
<h4 id="721-使用高级-api-创建任务">7.2.1 使用高级 API 创建任务<a class="headerlink" href="#721-使用高级-api-创建任务" title="Permanent link">&para;</a></h4>
<p><strong>7.2.1 Create Task With High-Level API</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="36:2"><input checked="checked" id="__tabbed_36_1" name="__tabbed_36" type="radio" /><input id="__tabbed_36_2" name="__tabbed_36" type="radio" /><div class="tabbed-labels"><label for="__tabbed_36_1">English</label><label for="__tabbed_36_2">Chinese</label></div>
<div class="tabbed-content">
<div class="tabbed-block"></div>
<div class="tabbed-block"></div>
</div>
</div>
<h3 id="722-使用低级-api-创建任务">7.2.2 使用低级 API 创建任务<a class="headerlink" href="#722-使用低级-api-创建任务" title="Permanent link">&para;</a></h3>
<p><strong>7.2.2 Create Task With Low-Level API</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="37:2"><input checked="checked" id="__tabbed_37_1" name="__tabbed_37" type="radio" /><input id="__tabbed_37_2" name="__tabbed_37" type="radio" /><div class="tabbed-labels"><label for="__tabbed_37_1">English</label><label for="__tabbed_37_2">Chinese</label></div>
<div class="tabbed-content">
<div class="tabbed-block"></div>
<div class="tabbed-block"></div>
</div>
</div>
<h3 id="73-何时运行任务">7.3 何时运行任务？<a class="headerlink" href="#73-何时运行任务" title="Permanent link">&para;</a></h3>
<p><strong>7.3 When Does a Task Run?</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="38:2"><input checked="checked" id="__tabbed_38_1" name="__tabbed_38" type="radio" /><input id="__tabbed_38_2" name="__tabbed_38" type="radio" /><div class="tabbed-labels"><label for="__tabbed_38_1">English</label><label for="__tabbed_38_2">Chinese</label></div>
<div class="tabbed-content">
<div class="tabbed-block"></div>
<div class="tabbed-block"></div>
</div>
</div>
<h2 id="8-使用和查询任务">8. 使用和查询任务<a class="headerlink" href="#8-使用和查询任务" title="Permanent link">&para;</a></h2>
<p><strong>8. Work With and Query Tasks</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="39:2"><input checked="checked" id="__tabbed_39_1" name="__tabbed_39" type="radio" /><input id="__tabbed_39_2" name="__tabbed_39" type="radio" /><div class="tabbed-labels"><label for="__tabbed_39_1">English</label><label for="__tabbed_39_2">Chinese</label></div>
<div class="tabbed-content">
<div class="tabbed-block"></div>
<div class="tabbed-block"></div>
</div>
</div>
<h3 id="81-任务的生命周期">8.1 任务的生命周期<a class="headerlink" href="#81-任务的生命周期" title="Permanent link">&para;</a></h3>
<p><strong>8.1 Task Life-Cycle</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="40:2"><input checked="checked" id="__tabbed_40_1" name="__tabbed_40" type="radio" /><input id="__tabbed_40_2" name="__tabbed_40" type="radio" /><div class="tabbed-labels"><label for="__tabbed_40_1">English</label><label for="__tabbed_40_2">Chinese</label></div>
<div class="tabbed-content">
<div class="tabbed-block"></div>
<div class="tabbed-block"></div>
</div>
</div>
<h3 id="82-如何检查任务的状态">8.2 如何检查任务的状态<a class="headerlink" href="#82-如何检查任务的状态" title="Permanent link">&para;</a></h3>
<p><strong>8.2 How to Check Task Status</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="41:2"><input checked="checked" id="__tabbed_41_1" name="__tabbed_41" type="radio" /><input id="__tabbed_41_2" name="__tabbed_41" type="radio" /><div class="tabbed-labels"><label for="__tabbed_41_1">English</label><label for="__tabbed_41_2">Chinese</label></div>
<div class="tabbed-content">
<div class="tabbed-block"></div>
<div class="tabbed-block"></div>
</div>
</div>
<h4 id="821-检查任务是否完成">8.2.1 检查任务是否完成<a class="headerlink" href="#821-检查任务是否完成" title="Permanent link">&para;</a></h4>
<p><strong>8.2.1 Check if a Task is Done</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="42:2"><input checked="checked" id="__tabbed_42_1" name="__tabbed_42" type="radio" /><input id="__tabbed_42_2" name="__tabbed_42" type="radio" /><div class="tabbed-labels"><label for="__tabbed_42_1">English</label><label for="__tabbed_42_2">Chinese</label></div>
<div class="tabbed-content">
<div class="tabbed-block"></div>
<div class="tabbed-block"></div>
</div>
</div>
<h4 id="822-检查任务是否被取消">8.2.2 检查任务是否被取消<a class="headerlink" href="#822-检查任务是否被取消" title="Permanent link">&para;</a></h4>
<p><strong>8.2.2 Check if a Task is Canceled</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="43:2"><input checked="checked" id="__tabbed_43_1" name="__tabbed_43" type="radio" /><input id="__tabbed_43_2" name="__tabbed_43" type="radio" /><div class="tabbed-labels"><label for="__tabbed_43_1">English</label><label for="__tabbed_43_2">Chinese</label></div>
<div class="tabbed-content">
<div class="tabbed-block"></div>
<div class="tabbed-block"></div>
</div>
</div>
<h3 id="83-如何获取任务结果">8.3 如何获取任务结果<a class="headerlink" href="#83-如何获取任务结果" title="Permanent link">&para;</a></h3>
<p><strong>8.3 How to Get Task Result</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="44:2"><input checked="checked" id="__tabbed_44_1" name="__tabbed_44" type="radio" /><input id="__tabbed_44_2" name="__tabbed_44" type="radio" /><div class="tabbed-labels"><label for="__tabbed_44_1">English</label><label for="__tabbed_44_2">Chinese</label></div>
<div class="tabbed-content">
<div class="tabbed-block"></div>
<div class="tabbed-block"></div>
</div>
</div>
<h3 id="84-如何获取任务异常">8.4 如何获取任务异常<a class="headerlink" href="#84-如何获取任务异常" title="Permanent link">&para;</a></h3>
<p><strong>8.4 How to Get Task Exception</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="45:2"><input checked="checked" id="__tabbed_45_1" name="__tabbed_45" type="radio" /><input id="__tabbed_45_2" name="__tabbed_45" type="radio" /><div class="tabbed-labels"><label for="__tabbed_45_1">English</label><label for="__tabbed_45_2">Chinese</label></div>
<div class="tabbed-content">
<div class="tabbed-block"></div>
<div class="tabbed-block"></div>
</div>
</div>
<h3 id="85-如何取消任务">8.5 如何取消任务<a class="headerlink" href="#85-如何取消任务" title="Permanent link">&para;</a></h3>
<p><strong>8.5 How to Cancel a Task</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="46:2"><input checked="checked" id="__tabbed_46_1" name="__tabbed_46" type="radio" /><input id="__tabbed_46_2" name="__tabbed_46" type="radio" /><div class="tabbed-labels"><label for="__tabbed_46_1">English</label><label for="__tabbed_46_2">Chinese</label></div>
<div class="tabbed-content">
<div class="tabbed-block"></div>
<div class="tabbed-block"></div>
</div>
</div>
<h3 id="86-如何在任务中使用回调">8.6 如何在任务中使用回调<a class="headerlink" href="#86-如何在任务中使用回调" title="Permanent link">&para;</a></h3>
<p><strong>8.6 How to Use Callback With a Task</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="47:2"><input checked="checked" id="__tabbed_47_1" name="__tabbed_47" type="radio" /><input id="__tabbed_47_2" name="__tabbed_47" type="radio" /><div class="tabbed-labels"><label for="__tabbed_47_1">English</label><label for="__tabbed_47_2">Chinese</label></div>
<div class="tabbed-content">
<div class="tabbed-block"></div>
<div class="tabbed-block"></div>
</div>
</div>
<h3 id="87-如何设置任务名称">8.7 如何设置任务名称<a class="headerlink" href="#87-如何设置任务名称" title="Permanent link">&para;</a></h3>
<p><strong>8.7 How to Set the Task Name</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="48:2"><input checked="checked" id="__tabbed_48_1" name="__tabbed_48" type="radio" /><input id="__tabbed_48_2" name="__tabbed_48" type="radio" /><div class="tabbed-labels"><label for="__tabbed_48_1">English</label><label for="__tabbed_48_2">Chinese</label></div>
<div class="tabbed-content">
<div class="tabbed-block"></div>
<div class="tabbed-block"></div>
</div>
</div>
<h2 id="9-当前和正在运行的任务">9. 当前和正在运行的任务<a class="headerlink" href="#9-当前和正在运行的任务" title="Permanent link">&para;</a></h2>
<p><strong>9. Current and Running Tasks</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="49:2"><input checked="checked" id="__tabbed_49_1" name="__tabbed_49" type="radio" /><input id="__tabbed_49_2" name="__tabbed_49" type="radio" /><div class="tabbed-labels"><label for="__tabbed_49_1">English</label><label for="__tabbed_49_2">Chinese</label></div>
<div class="tabbed-content">
<div class="tabbed-block"></div>
<div class="tabbed-block"></div>
</div>
</div>
<h3 id="91-如何获取当前任务">9.1 如何获取当前任务<a class="headerlink" href="#91-如何获取当前任务" title="Permanent link">&para;</a></h3>
<p><strong>9.1 How to Get the Current Task</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="50:2"><input checked="checked" id="__tabbed_50_1" name="__tabbed_50" type="radio" /><input id="__tabbed_50_2" name="__tabbed_50" type="radio" /><div class="tabbed-labels"><label for="__tabbed_50_1">English</label><label for="__tabbed_50_2">Chinese</label></div>
<div class="tabbed-content">
<div class="tabbed-block"></div>
<div class="tabbed-block"></div>
</div>
</div>
<h3 id="92-如何获取所有任务">9.2 如何获取所有任务<a class="headerlink" href="#92-如何获取所有任务" title="Permanent link">&para;</a></h3>
<p><strong>9.2 How to Get All Tasks</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="51:2"><input checked="checked" id="__tabbed_51_1" name="__tabbed_51" type="radio" /><input id="__tabbed_51_2" name="__tabbed_51" type="radio" /><div class="tabbed-labels"><label for="__tabbed_51_1">English</label><label for="__tabbed_51_2">Chinese</label></div>
<div class="tabbed-content">
<div class="tabbed-block"></div>
<div class="tabbed-block"></div>
</div>
</div>
<h2 id="10-同时运行多个协程">10. 同时运行多个协程<a class="headerlink" href="#10-同时运行多个协程" title="Permanent link">&para;</a></h2>
<p><strong>10. Run Many Coroutines Concurrently</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="52:2"><input checked="checked" id="__tabbed_52_1" name="__tabbed_52" type="radio" /><input id="__tabbed_52_2" name="__tabbed_52" type="radio" /><div class="tabbed-labels"><label for="__tabbed_52_1">English</label><label for="__tabbed_52_2">Chinese</label></div>
<div class="tabbed-content">
<div class="tabbed-block"></div>
<div class="tabbed-block"></div>
</div>
</div>
<h3 id="101-什么是-asyncio-gather">10.1 什么是 Asyncio Gather()<a class="headerlink" href="#101-什么是-asyncio-gather" title="Permanent link">&para;</a></h3>
<p><strong>10.1 What is Asyncio gather()</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="53:2"><input checked="checked" id="__tabbed_53_1" name="__tabbed_53" type="radio" /><input id="__tabbed_53_2" name="__tabbed_53" type="radio" /><div class="tabbed-labels"><label for="__tabbed_53_1">English</label><label for="__tabbed_53_2">Chinese</label></div>
<div class="tabbed-content">
<div class="tabbed-block"></div>
<div class="tabbed-block"></div>
</div>
</div>
<h3 id="102-如何使用-asyncio-gather">10.2 如何使用 Asyncio Gather()<a class="headerlink" href="#102-如何使用-asyncio-gather" title="Permanent link">&para;</a></h3>
<p><strong>10.2 How to use Asyncio gather()</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="54:2"><input checked="checked" id="__tabbed_54_1" name="__tabbed_54" type="radio" /><input id="__tabbed_54_2" name="__tabbed_54" type="radio" /><div class="tabbed-labels"><label for="__tabbed_54_1">English</label><label for="__tabbed_54_2">Chinese</label></div>
<div class="tabbed-content">
<div class="tabbed-block"></div>
<div class="tabbed-block"></div>
</div>
</div>
<h3 id="103-对于列表中的多个协程的-gather-示例">10.3 对于列表中的多个协程的 Gather() 示例<a class="headerlink" href="#103-对于列表中的多个协程的-gather-示例" title="Permanent link">&para;</a></h3>
<p><strong>10.3 Example of gather() For Many Coroutines in a List</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="55:2"><input checked="checked" id="__tabbed_55_1" name="__tabbed_55" type="radio" /><input id="__tabbed_55_2" name="__tabbed_55" type="radio" /><div class="tabbed-labels"><label for="__tabbed_55_1">English</label><label for="__tabbed_55_2">Chinese</label></div>
<div class="tabbed-content">
<div class="tabbed-block"></div>
<div class="tabbed-block"></div>
</div>
</div>
<h2 id="11-等待任务的集合">11. 等待任务的集合<a class="headerlink" href="#11-等待任务的集合" title="Permanent link">&para;</a></h2>
<p><strong>11. Wait for A Collection of Tasks</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="56:2"><input checked="checked" id="__tabbed_56_1" name="__tabbed_56" type="radio" /><input id="__tabbed_56_2" name="__tabbed_56" type="radio" /><div class="tabbed-labels"><label for="__tabbed_56_1">English</label><label for="__tabbed_56_2">Chinese</label></div>
<div class="tabbed-content">
<div class="tabbed-block"></div>
<div class="tabbed-block"></div>
</div>
</div>
<h3 id="111-什么是-asynciowait">11.1 什么是 asyncio.wait()<a class="headerlink" href="#111-什么是-asynciowait" title="Permanent link">&para;</a></h3>
<p><strong>11.1 What is asyncio.wait()</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="57:2"><input checked="checked" id="__tabbed_57_1" name="__tabbed_57" type="radio" /><input id="__tabbed_57_2" name="__tabbed_57" type="radio" /><div class="tabbed-labels"><label for="__tabbed_57_1">English</label><label for="__tabbed_57_2">Chinese</label></div>
<div class="tabbed-content">
<div class="tabbed-block"></div>
<div class="tabbed-block"></div>
</div>
</div>
<h3 id="112-如何使用-asynciowait">11.2 如何使用 asyncio.wait()<a class="headerlink" href="#112-如何使用-asynciowait" title="Permanent link">&para;</a></h3>
<p><strong>11.2 How to Use asyncio.wait()</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="58:2"><input checked="checked" id="__tabbed_58_1" name="__tabbed_58" type="radio" /><input id="__tabbed_58_2" name="__tabbed_58" type="radio" /><div class="tabbed-labels"><label for="__tabbed_58_1">English</label><label for="__tabbed_58_2">Chinese</label></div>
<div class="tabbed-content">
<div class="tabbed-block"></div>
<div class="tabbed-block"></div>
</div>
</div>
<h3 id="113-等待所有任务的示例">11.3 等待所有任务的示例<a class="headerlink" href="#113-等待所有任务的示例" title="Permanent link">&para;</a></h3>
<p><strong>11.3 Example of Waiting for All Tasks</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="59:2"><input checked="checked" id="__tabbed_59_1" name="__tabbed_59" type="radio" /><input id="__tabbed_59_2" name="__tabbed_59" type="radio" /><div class="tabbed-labels"><label for="__tabbed_59_1">English</label><label for="__tabbed_59_2">Chinese</label></div>
<div class="tabbed-content">
<div class="tabbed-block"></div>
<div class="tabbed-block"></div>
</div>
</div>
<h2 id="12-等待有时间限制的协程">12. 等待有时间限制的协程<a class="headerlink" href="#12-等待有时间限制的协程" title="Permanent link">&para;</a></h2>
<p><strong>12. Wait for a Coroutine with a Time Limit</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="60:2"><input checked="checked" id="__tabbed_60_1" name="__tabbed_60" type="radio" /><input id="__tabbed_60_2" name="__tabbed_60" type="radio" /><div class="tabbed-labels"><label for="__tabbed_60_1">English</label><label for="__tabbed_60_2">Chinese</label></div>
<div class="tabbed-content">
<div class="tabbed-block"></div>
<div class="tabbed-block"></div>
</div>
</div>
<h3 id="121-什么是-asyncio-wait_for">12.1 什么是 Asyncio wait_for()<a class="headerlink" href="#121-什么是-asyncio-wait_for" title="Permanent link">&para;</a></h3>
<p><strong>12.1 What is Asyncio wait_for()</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="61:2"><input checked="checked" id="__tabbed_61_1" name="__tabbed_61" type="radio" /><input id="__tabbed_61_2" name="__tabbed_61" type="radio" /><div class="tabbed-labels"><label for="__tabbed_61_1">English</label><label for="__tabbed_61_2">Chinese</label></div>
<div class="tabbed-content">
<div class="tabbed-block"></div>
<div class="tabbed-block"></div>
</div>
</div>
<h3 id="122-如何使用-asyncio-wait_for">12.2 如何使用 Asyncio wait_for()<a class="headerlink" href="#122-如何使用-asyncio-wait_for" title="Permanent link">&para;</a></h3>
<p><strong>12.2 How to Use Asyncio wait_for()</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="62:2"><input checked="checked" id="__tabbed_62_1" name="__tabbed_62" type="radio" /><input id="__tabbed_62_2" name="__tabbed_62" type="radio" /><div class="tabbed-labels"><label for="__tabbed_62_1">English</label><label for="__tabbed_62_2">Chinese</label></div>
<div class="tabbed-content">
<div class="tabbed-block"></div>
<div class="tabbed-block"></div>
</div>
</div>
<h3 id="123-带有超时的-asyncio-wait_for-示例">12.3 带有超时的 Asyncio wait_for() 示例<a class="headerlink" href="#123-带有超时的-asyncio-wait_for-示例" title="Permanent link">&para;</a></h3>
<p><strong>12.3 Example of Asyncio wait_for() With a Timeout</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="63:2"><input checked="checked" id="__tabbed_63_1" name="__tabbed_63" type="radio" /><input id="__tabbed_63_2" name="__tabbed_63" type="radio" /><div class="tabbed-labels"><label for="__tabbed_63_1">English</label><label for="__tabbed_63_2">Chinese</label></div>
<div class="tabbed-content">
<div class="tabbed-block"></div>
<div class="tabbed-block"></div>
</div>
</div>
<h2 id="13-防止任务被取消">13. 防止任务被取消<a class="headerlink" href="#13-防止任务被取消" title="Permanent link">&para;</a></h2>
<p><strong>13. Shield Tasks from Cancellation</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="64:2"><input checked="checked" id="__tabbed_64_1" name="__tabbed_64" type="radio" /><input id="__tabbed_64_2" name="__tabbed_64" type="radio" /><div class="tabbed-labels"><label for="__tabbed_64_1">English</label><label for="__tabbed_64_2">Chinese</label></div>
<div class="tabbed-content">
<div class="tabbed-block"></div>
<div class="tabbed-block"></div>
</div>
</div>
<h3 id="131-什么是-asyncio-shield">13.1 什么是 Asyncio shield()<a class="headerlink" href="#131-什么是-asyncio-shield" title="Permanent link">&para;</a></h3>
<p><strong>13.1 What is Asyncio shield()</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="65:2"><input checked="checked" id="__tabbed_65_1" name="__tabbed_65" type="radio" /><input id="__tabbed_65_2" name="__tabbed_65" type="radio" /><div class="tabbed-labels"><label for="__tabbed_65_1">English</label><label for="__tabbed_65_2">Chinese</label></div>
<div class="tabbed-content">
<div class="tabbed-block"></div>
<div class="tabbed-block"></div>
</div>
</div>
<h3 id="132-如何使用-asyncioshield">13.2 如何使用 Asyncioshield()<a class="headerlink" href="#132-如何使用-asyncioshield" title="Permanent link">&para;</a></h3>
<p><strong>13.2 How to Use Asyncio shield()</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="66:2"><input checked="checked" id="__tabbed_66_1" name="__tabbed_66" type="radio" /><input id="__tabbed_66_2" name="__tabbed_66" type="radio" /><div class="tabbed-labels"><label for="__tabbed_66_1">English</label><label for="__tabbed_66_2">Chinese</label></div>
<div class="tabbed-content">
<div class="tabbed-block"></div>
<div class="tabbed-block"></div>
</div>
</div>
<h3 id="133-任务的-asyncioshield-示例">13.3 任务的 Asyncioshield() 示例<a class="headerlink" href="#133-任务的-asyncioshield-示例" title="Permanent link">&para;</a></h3>
<p><strong>13.3 Example of Asyncio shield() for a Task</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="67:2"><input checked="checked" id="__tabbed_67_1" name="__tabbed_67" type="radio" /><input id="__tabbed_67_2" name="__tabbed_67" type="radio" /><div class="tabbed-labels"><label for="__tabbed_67_1">English</label><label for="__tabbed_67_2">Chinese</label></div>
<div class="tabbed-content">
<div class="tabbed-block"></div>
<div class="tabbed-block"></div>
</div>
</div>
<h2 id="14-在-asyncio-中运行阻塞任务">14. 在 Asyncio 中运行阻塞任务<a class="headerlink" href="#14-在-asyncio-中运行阻塞任务" title="Permanent link">&para;</a></h2>
<p><strong>14. Run a Blocking Task in Asyncio</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="68:2"><input checked="checked" id="__tabbed_68_1" name="__tabbed_68" type="radio" /><input id="__tabbed_68_2" name="__tabbed_68" type="radio" /><div class="tabbed-labels"><label for="__tabbed_68_1">English</label><label for="__tabbed_68_2">Chinese</label></div>
<div class="tabbed-content">
<div class="tabbed-block"></div>
<div class="tabbed-block"></div>
</div>
</div>
<h3 id="141-需要在-asyncio-中运行阻塞任务">14.1 需要在 Asyncio 中运行阻塞任务<a class="headerlink" href="#141-需要在-asyncio-中运行阻塞任务" title="Permanent link">&para;</a></h3>
<p><strong>14.1 Need to Run Blocking Tasks in Asyncio</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="69:2"><input checked="checked" id="__tabbed_69_1" name="__tabbed_69" type="radio" /><input id="__tabbed_69_2" name="__tabbed_69" type="radio" /><div class="tabbed-labels"><label for="__tabbed_69_1">English</label><label for="__tabbed_69_2">Chinese</label></div>
<div class="tabbed-content">
<div class="tabbed-block"></div>
<div class="tabbed-block"></div>
</div>
</div>
<h3 id="142-如何运行阻塞任务">14.2 如何运行阻塞任务<a class="headerlink" href="#142-如何运行阻塞任务" title="Permanent link">&para;</a></h3>
<p><strong>14.2 How to Run Blocking Tasks</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="70:2"><input checked="checked" id="__tabbed_70_1" name="__tabbed_70" type="radio" /><input id="__tabbed_70_2" name="__tabbed_70" type="radio" /><div class="tabbed-labels"><label for="__tabbed_70_1">English</label><label for="__tabbed_70_2">Chinese</label></div>
<div class="tabbed-content">
<div class="tabbed-block"></div>
<div class="tabbed-block"></div>
</div>
</div>
<h3 id="143-使用-to_thread-在-asyncio-中运行-io-密集型任务的示例">14.3 使用 to_thread() 在 Asyncio 中运行 I/O 密集型任务的示例<a class="headerlink" href="#143-使用-to_thread-在-asyncio-中运行-io-密集型任务的示例" title="Permanent link">&para;</a></h3>
<p>14.3 Example of Running I/O-Bound Task in Asyncio with to_thread()</p>
<div class="tabbed-set tabbed-alternate" data-tabs="71:2"><input checked="checked" id="__tabbed_71_1" name="__tabbed_71" type="radio" /><input id="__tabbed_71_2" name="__tabbed_71" type="radio" /><div class="tabbed-labels"><label for="__tabbed_71_1">English</label><label for="__tabbed_71_2">Chinese</label></div>
<div class="tabbed-content">
<div class="tabbed-block"></div>
<div class="tabbed-block"></div>
</div>
</div>
<h2 id="15-异步迭代器">15. 异步迭代器<a class="headerlink" href="#15-异步迭代器" title="Permanent link">&para;</a></h2>
<p><strong>15. Asynchronous Iterators</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="72:2"><input checked="checked" id="__tabbed_72_1" name="__tabbed_72" type="radio" /><input id="__tabbed_72_2" name="__tabbed_72" type="radio" /><div class="tabbed-labels"><label for="__tabbed_72_1">English</label><label for="__tabbed_72_2">Chinese</label></div>
<div class="tabbed-content">
<div class="tabbed-block"></div>
<div class="tabbed-block"></div>
</div>
</div>
<h3 id="151-什么是异步迭代器">15.1 什么是异步迭代器<a class="headerlink" href="#151-什么是异步迭代器" title="Permanent link">&para;</a></h3>
<p><strong>15.1 What Are Asynchronous Iterators</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="73:2"><input checked="checked" id="__tabbed_73_1" name="__tabbed_73" type="radio" /><input id="__tabbed_73_2" name="__tabbed_73" type="radio" /><div class="tabbed-labels"><label for="__tabbed_73_1">English</label><label for="__tabbed_73_2">Chinese</label></div>
<div class="tabbed-content">
<div class="tabbed-block"></div>
<div class="tabbed-block"></div>
</div>
</div>
<h4 id="1511-迭代器">15.1.1 迭代器<a class="headerlink" href="#1511-迭代器" title="Permanent link">&para;</a></h4>
<p><strong>15.1.1 Iterators</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="74:2"><input checked="checked" id="__tabbed_74_1" name="__tabbed_74" type="radio" /><input id="__tabbed_74_2" name="__tabbed_74" type="radio" /><div class="tabbed-labels"><label for="__tabbed_74_1">English</label><label for="__tabbed_74_2">Chinese</label></div>
<div class="tabbed-content">
<div class="tabbed-block"></div>
<div class="tabbed-block"></div>
</div>
</div>
<h4 id="1512-异步迭代器">15.1.2 异步迭代器<a class="headerlink" href="#1512-异步迭代器" title="Permanent link">&para;</a></h4>
<p><strong>15.1.2 Asynchronous Iterators</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="75:2"><input checked="checked" id="__tabbed_75_1" name="__tabbed_75" type="radio" /><input id="__tabbed_75_2" name="__tabbed_75" type="radio" /><div class="tabbed-labels"><label for="__tabbed_75_1">English</label><label for="__tabbed_75_2">Chinese</label></div>
<div class="tabbed-content">
<div class="tabbed-block"></div>
<div class="tabbed-block"></div>
</div>
</div>
<h3 id="152-什么是async-for循环">15.2 什么是“async for”循环？<a class="headerlink" href="#152-什么是async-for循环" title="Permanent link">&para;</a></h3>
<p><strong>15.2 What is the “async for” loop?</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="76:2"><input checked="checked" id="__tabbed_76_1" name="__tabbed_76" type="radio" /><input id="__tabbed_76_2" name="__tabbed_76" type="radio" /><div class="tabbed-labels"><label for="__tabbed_76_1">English</label><label for="__tabbed_76_2">Chinese</label></div>
<div class="tabbed-content">
<div class="tabbed-block"></div>
<div class="tabbed-block"></div>
</div>
</div>
<h3 id="153-如何使用异步迭代器">15.3 如何使用异步迭代器<a class="headerlink" href="#153-如何使用异步迭代器" title="Permanent link">&para;</a></h3>
<p><strong>15.3 How to Use Asynchronous Iterators</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="77:2"><input checked="checked" id="__tabbed_77_1" name="__tabbed_77" type="radio" /><input id="__tabbed_77_2" name="__tabbed_77" type="radio" /><div class="tabbed-labels"><label for="__tabbed_77_1">English</label><label for="__tabbed_77_2">Chinese</label></div>
<div class="tabbed-content">
<div class="tabbed-block"></div>
<div class="tabbed-block"></div>
</div>
</div>
<h4 id="1531-定义异步迭代器">15.3.1 定义异步迭代器<a class="headerlink" href="#1531-定义异步迭代器" title="Permanent link">&para;</a></h4>
<p><strong>15.3.1 Define an Asynchronous Iterator</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="78:2"><input checked="checked" id="__tabbed_78_1" name="__tabbed_78" type="radio" /><input id="__tabbed_78_2" name="__tabbed_78" type="radio" /><div class="tabbed-labels"><label for="__tabbed_78_1">English</label><label for="__tabbed_78_2">Chinese</label></div>
<div class="tabbed-content">
<div class="tabbed-block"></div>
<div class="tabbed-block"></div>
</div>
</div>
<h4 id="1532-创建异步迭代器">15.3.2 创建异步迭代器<a class="headerlink" href="#1532-创建异步迭代器" title="Permanent link">&para;</a></h4>
<p><strong>15.3.2 Create Asynchronous Iterator</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="79:2"><input checked="checked" id="__tabbed_79_1" name="__tabbed_79" type="radio" /><input id="__tabbed_79_2" name="__tabbed_79" type="radio" /><div class="tabbed-labels"><label for="__tabbed_79_1">English</label><label for="__tabbed_79_2">Chinese</label></div>
<div class="tabbed-content">
<div class="tabbed-block"></div>
<div class="tabbed-block"></div>
</div>
</div>
<h4 id="1533-单步执行异步迭代器">15.3.3 单步执行异步迭代器<a class="headerlink" href="#1533-单步执行异步迭代器" title="Permanent link">&para;</a></h4>
<p><strong>Step an Asynchronous Iterator</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="80:2"><input checked="checked" id="__tabbed_80_1" name="__tabbed_80" type="radio" /><input id="__tabbed_80_2" name="__tabbed_80" type="radio" /><div class="tabbed-labels"><label for="__tabbed_80_1">English</label><label for="__tabbed_80_2">Chinese</label></div>
<div class="tabbed-content">
<div class="tabbed-block"></div>
<div class="tabbed-block"></div>
</div>
</div>
<h4 id="1534-遍历异步迭代器">15.3.4 遍历异步迭代器<a class="headerlink" href="#1534-遍历异步迭代器" title="Permanent link">&para;</a></h4>
<p><strong>Traverse an Asynchronous Iterator</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="81:2"><input checked="checked" id="__tabbed_81_1" name="__tabbed_81" type="radio" /><input id="__tabbed_81_2" name="__tabbed_81" type="radio" /><div class="tabbed-labels"><label for="__tabbed_81_1">English</label><label for="__tabbed_81_2">Chinese</label></div>
<div class="tabbed-content">
<div class="tabbed-block"></div>
<div class="tabbed-block"></div>
</div>
</div>
<h3 id="154-异步迭代器的示例">15.4 异步迭代器的示例<a class="headerlink" href="#154-异步迭代器的示例" title="Permanent link">&para;</a></h3>
<p><strong>15.4 Example of an Asynchronous Iterator</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="82:2"><input checked="checked" id="__tabbed_82_1" name="__tabbed_82" type="radio" /><input id="__tabbed_82_2" name="__tabbed_82" type="radio" /><div class="tabbed-labels"><label for="__tabbed_82_1">English</label><label for="__tabbed_82_2">Chinese</label></div>
<div class="tabbed-content">
<div class="tabbed-block"></div>
<div class="tabbed-block"></div>
</div>
</div>
<h2 id="16-异步生成器">16. 异步生成器<a class="headerlink" href="#16-异步生成器" title="Permanent link">&para;</a></h2>
<p><strong>16. Asynchronous Generators</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="83:2"><input checked="checked" id="__tabbed_83_1" name="__tabbed_83" type="radio" /><input id="__tabbed_83_2" name="__tabbed_83" type="radio" /><div class="tabbed-labels"><label for="__tabbed_83_1">English</label><label for="__tabbed_83_2">Chinese</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<p>Generators are a fundamental part of Python.</p>
<p>A generator is a function that has at least one <strong>“yield”</strong> expression. They are functions that can be suspended and resumed, just like coroutines.</p>
<p>In fact, Python coroutines are an extension of Python generators.</p>
<p>Asyncio allows us to develop asynchronous generators.</p>
<p>We can create an asynchronous generator by defining a coroutine that makes use of the “yield” expression.</p>
<p>Let’s take a closer look.</p>
</div>
<div class="tabbed-block">
<p>生成器是 Python 的基本组成部分。</p>
<p>生成器是一种至少具有一个“<strong>yield</strong>”表达式的函数。 它们是可以暂停和恢复的函数，就像协程一样。</p>
<p>事实上，Python 协程是 Python 生成器的扩展。</p>
<p>Asyncio 允许我们开发异步生成器。</p>
<p>我们可以通过定义使用“<strong>yield</strong>”表达式的协程来创建异步生成器。</p>
<p>让我们仔细看看。</p>
</div>
</div>
</div>
<h3 id="161-什么是异步生成器">16.1 什么是异步生成器<a class="headerlink" href="#161-什么是异步生成器" title="Permanent link">&para;</a></h3>
<p><strong>16.1 What Are Asynchronous Generators</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="84:2"><input checked="checked" id="__tabbed_84_1" name="__tabbed_84" type="radio" /><input id="__tabbed_84_2" name="__tabbed_84" type="radio" /><div class="tabbed-labels"><label for="__tabbed_84_1">English</label><label for="__tabbed_84_2">Chinese</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<p>An asynchronous generator is a coroutine that uses the yield expression.</p>
<p>Before we dive into the details of asynchronous generators, let’s first review classical Python generators.</p>
</div>
<div class="tabbed-block">
<p>异步生成器是使用yield 表达式的协程。</p>
<p>在我们深入了解异步生成器的细节之前，让我们首先回顾一下经典的 Python 生成器。</p>
</div>
</div>
</div>
<h4 id="1611-生成器">16.1.1 生成器<a class="headerlink" href="#1611-生成器" title="Permanent link">&para;</a></h4>
<p><strong>16.1.1 Generators</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="85:2"><input checked="checked" id="__tabbed_85_1" name="__tabbed_85" type="radio" /><input id="__tabbed_85_2" name="__tabbed_85" type="radio" /><div class="tabbed-labels"><label for="__tabbed_85_1">English</label><label for="__tabbed_85_2">Chinese</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<p>A generator is a Python function that returns a value via a yield expression.</p>
<p>For example:</p>
<div class="highlight"><pre><span></span><code><span class="c1"># define a generator</span>
<span class="k">def</span> <span class="nf">generator</span><span class="p">():</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span>
        <span class="k">yield</span> <span class="n">i</span>
</code></pre></div>
<p>The generator is executed to the yield expression, after which a value is returned. This suspends the generator at that point. The next time the generator is executed it is resumed from the point it was resumed and runs until the next yield expression.</p>
<blockquote>
<p>generator: A function which returns a generator iterator. It looks like a normal function except that it contains yield expressions for producing a series of values usable in a for-loop or that can be retrieved one at a time with the next() function.</p>
<p>— <a href="https://docs.python.org/3/glossary.html">PYTHON GLOSSARY</a></p>
</blockquote>
<p>Technically, a generator function creates and returns a generator iterator. The generator iterator executes the content of the generator function, yielding and resuming as needed.</p>
<blockquote>
<p>generator iterator: An object created by a generator function. Each yield temporarily suspends processing, remembering the location execution state […] When the generator iterator resumes, it picks up where it left off …</p>
<p>— <a href="https://docs.python.org/3/glossary.html">PYTHON GLOSSARY</a></p>
</blockquote>
<p>A generator can be executed in steps by using the next() built-in function.</p>
<p>For example:</p>
<div class="highlight"><pre><span></span><code><span class="o">...</span>
<span class="c1"># create the generator</span>
<span class="n">gen</span> <span class="o">=</span> <span class="n">generator</span><span class="p">()</span>
<span class="c1"># step the generator</span>
<span class="n">result</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">gen</span><span class="p">)</span>
</code></pre></div>
<p>Although, it is more common to iterate the generator to completion, such as using a for-loop or a list comprehension.</p>
<p>For example:</p>
<div class="highlight"><pre><span></span><code><span class="o">...</span>
<span class="c1"># traverse the generator and collect results</span>
<span class="n">results</span> <span class="o">=</span> <span class="p">[</span><span class="n">item</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">generator</span><span class="p">()]</span>
</code></pre></div>
<p>Next, let’s take a closer look at asynchronous generators.</p>
</div>
<div class="tabbed-block">
<p>生成器是一个Python函数，它通过yield表达式返回一个值。</p>
<p>例如:</p>
<div class="highlight"><pre><span></span><code><span class="c1"># 定义生成器</span>
<span class="k">def</span> <span class="nf">generator</span><span class="p">():</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span>
        <span class="k">yield</span> <span class="n">i</span>
</code></pre></div>
<p>生成器执行到yield表达式，然后返回一个值。 这会在此时暂停生成器。 下次执行生成器时，它将从恢复点恢复并运行到下一个 yield 表达式。</p>
<blockquote>
<p>生成器: 返回生成器迭代器的函数。 它看起来像一个普通函数，只不过它包含用于生成一系列可在 for 循环中使用的值的yield 表达式，或者可以使用 <strong>next()</strong> 函数一次检索一个值。</p>
<p>— <a href="https://docs.python.org/3/glossary.html">PYTHON GLOSSARY</a></p>
</blockquote>
<p>从技术上讲，生成器函数创建并返回生成器迭代器。 生成器迭代器执行生成器函数的内容，根据需要产生并恢复。</p>
<blockquote>
<p>生成迭代器: 由生成器函数创建的对象。 每个yield都会暂时挂起处理，记住位置执行状态[...]当生成器迭代器恢复时，它会从上次停止的地方继续...</p>
<p>— <a href="https://docs.python.org/3/glossary.html">PYTHON GLOSSARY</a></p>
</blockquote>
<p>可以使用 <strong>next()</strong> 内置函数逐步执行生成器。</p>
<p>例如:</p>
<div class="highlight"><pre><span></span><code><span class="o">...</span>
<span class="c1"># 创建生成器</span>
<span class="n">gen</span> <span class="o">=</span> <span class="n">generator</span><span class="p">()</span>
<span class="c1"># 生成器的下一步</span>
<span class="n">result</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">gen</span><span class="p">)</span>
</code></pre></div>
<p>尽管如此，更常见的是迭代生成器以完成，例如使用 for 循环或列表理解。</p>
<p>例如:</p>
<div class="highlight"><pre><span></span><code><span class="o">...</span>
<span class="c1"># 遍历生成器并收集结果</span>
<span class="n">results</span> <span class="o">=</span> <span class="p">[</span><span class="n">item</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">generator</span><span class="p">()]</span>
</code></pre></div>
<p>接下来，让我们仔细看看异步生成器。</p>
</div>
</div>
</div>
<h4 id="1612-异步生成器">16.1.2 异步生成器<a class="headerlink" href="#1612-异步生成器" title="Permanent link">&para;</a></h4>
<p><strong>16.1.2 Asynchronous Generators</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="86:2"><input checked="checked" id="__tabbed_86_1" name="__tabbed_86" type="radio" /><input id="__tabbed_86_2" name="__tabbed_86" type="radio" /><div class="tabbed-labels"><label for="__tabbed_86_1">English</label><label for="__tabbed_86_2">Chinese</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<p>An asynchronous generator is a coroutine that uses the yield expression.</p>
<p>Unlike a function generator, the coroutine can schedule and await other coroutines and tasks.</p>
<blockquote>
<p>asynchronous generator: A function which returns an asynchronous generator iterator. It looks like a coroutine function defined with async def except that it contains yield expressions for producing a series of values usable in an async for loop.</p>
<p>— <a href="https://docs.python.org/3/glossary.html">PYTHON GLOSSARY</a></p>
</blockquote>
<p>Like a classical generator, an asynchronous generator function can be used to create an asynchronous generator iterator that can be traversed using the built-in anext() function, instead of the next() function.</p>
<blockquote>
<p>asynchronous generator iterator: An object created by a asynchronous generator function. This is an asynchronous iterator which when called using the <strong>anext</strong>() method returns an awaitable object which will execute the body of the asynchronous generator function until the next yield expression.</p>
<p>— <a href="https://docs.python.org/3/glossary.html">PYTHON GLOSSARY</a></p>
</blockquote>
<p>This means that the asynchronous generator iterator implements the <strong>__anext__()</strong> method and can be used with the async for expression.</p>
<p>This means that each iteration of the generator is scheduled and executed as awaitable. The “<strong>async for</strong>” expression will schedule and execute each iteration of the generator, suspending the calling coroutine and awaiting the result.</p>
<p>You can learn more about the “<strong>async for</strong>” expression in the tutorial:</p>
<ul>
<li><a href="https://superfastpython.com/asyncio-async-for/">Asyncio async for loop</a></li>
</ul>
</div>
<div class="tabbed-block">
<p>异步生成器是使用yield 表达式的协程。</p>
<p>与函数生成器不同，协程可以调度和等待其他协程和任务。</p>
<blockquote>
<p>异步生成器: 返回异步生成器迭代器的函数。 它看起来像一个使用 <strong>async def</strong> 定义的协程函数，只不过它包含用于生成一系列可在 <strong>async for</strong> 循环中使用的值的 yield 表达式。</p>
<p>— <a href="https://docs.python.org/3/glossary.html">PYTHON GLOSSARY</a></p>
</blockquote>
<p>与经典生成器一样，异步生成器函数可用于创建异步生成器迭代器，该迭代器可以使用内置 <strong>anext()</strong> 函数（而不是 <strong>next()</strong> 函数）进行遍历。</p>
<blockquote>
<p>基于异步生成器的迭代器：由异步生成器函数创建的对象。 这是一个异步迭代器，当使用 <strong>__anext__()</strong> 方法调用时，它会返回一个可等待对象，该对象将执行异步生成器函数的主体，直到下一个 yield 表达式。</p>
<p>— <a href="https://docs.python.org/3/glossary.html">PYTHON GLOSSARY</a></p>
</blockquote>
<p>这意味着异步生成器迭代器实现了 <strong>__anext__()</strong> 方法，并且可以与 async for 表达式一起使用。</p>
<p>这意味着生成器的每次迭代都被调度并作为可等待执行。 “<strong>async for</strong>”表达式将调度并执行生成器的每次迭代，挂起调用协程并等待结果。</p>
<p>您可以在教程中了解有关“<strong>async for</strong>”表达式的更多信息：</p>
<ul>
<li><a href="https://superfastpython.com/asyncio-async-for/">Asyncio 的异步 for 循环</a></li>
</ul>
</div>
</div>
</div>
<h3 id="162-如何使用异步生成器">16.2 如何使用异步生成器<a class="headerlink" href="#162-如何使用异步生成器" title="Permanent link">&para;</a></h3>
<p><strong>16.2 How to Use an Asynchronous Generator</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="87:2"><input checked="checked" id="__tabbed_87_1" name="__tabbed_87" type="radio" /><input id="__tabbed_87_2" name="__tabbed_87" type="radio" /><div class="tabbed-labels"><label for="__tabbed_87_1">English</label><label for="__tabbed_87_2">Chinese</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<p>In this section, we will take a close look at how to define, create, step, and traverse an asynchronous generator in asyncio programs.</p>
<p>Let’s start with how to define an asynchronous generator.</p>
</div>
<div class="tabbed-block">
<p>在本节中，我们将仔细研究如何在 asyncio 程序中定义、创建、单步执行和遍历异步生成器。</p>
<p>让我们从如何定义异步生成器开始。</p>
</div>
</div>
</div>
<h4 id="1621-定义异步生成器">16.2.1 定义异步生成器<a class="headerlink" href="#1621-定义异步生成器" title="Permanent link">&para;</a></h4>
<p><strong>16.2.1 Define an Asynchronous Generator</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="88:2"><input checked="checked" id="__tabbed_88_1" name="__tabbed_88" type="radio" /><input id="__tabbed_88_2" name="__tabbed_88" type="radio" /><div class="tabbed-labels"><label for="__tabbed_88_1">English</label><label for="__tabbed_88_2">Chinese</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<p>We can define an asynchronous generator by defining a coroutine that has at least one yield expression.</p>
<p>This means that the function is defined using the “<strong>async def</strong>” expression.</p>
<p>For example:</p>
<div class="highlight"><pre><span></span><code><span class="c1"># define an asynchronous generator</span>
<span class="k">async</span> <span class="k">def</span> <span class="nf">async_generator</span><span class="p">():</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
        <span class="k">yield</span> <span class="n">i</span>
</code></pre></div>
<p>Because the asynchronous generator is a coroutine and each iterator returns an awaitable that is scheduled and executed in the asyncio event loop, we can execute and await awaitables within the body of the generator.</p>
<p>For example:</p>
<div class="highlight"><pre><span></span><code><span class="c1"># define an asynchronous generator that awaits</span>
<span class="k">async</span> <span class="k">def</span> <span class="nf">async_generator</span><span class="p">():</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
        <span class="c1"># suspend and sleep a moment</span>
        <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="c1"># yield a value to the caller</span>
        <span class="k">yield</span> <span class="n">i</span>
</code></pre></div>
<p>Next, let’s look at how we might use an asynchronous generator.</p>
</div>
<div class="tabbed-block">
<p>我们可以通过定义一个至少具有一个yield 表达式的协程来定义异步生成器。</p>
<p>这意味着该函数是使用“<strong>async def</strong>”表达式定义的。</p>
<p>例如:</p>
<div class="highlight"><pre><span></span><code><span class="c1"># 定义一个异步生成器</span>
<span class="k">async</span> <span class="k">def</span> <span class="nf">async_generator</span><span class="p">():</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
        <span class="k">yield</span> <span class="n">i</span>
</code></pre></div>
<p>因为异步生成器是一个协程，并且每个迭代器返回一个在 asyncio 事件循环中调度和执行的等待对象，所以我们可以在生成器的主体内执行和等待等待对象。</p>
<p>例如:</p>
<div class="highlight"><pre><span></span><code><span class="c1"># 定义一个等待的异步生成器</span>
<span class="k">async</span> <span class="k">def</span> <span class="nf">async_generator</span><span class="p">():</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
        <span class="c1"># 暂停并睡眠一会儿</span>
        <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="c1"># 向调用者产生一个值</span>
        <span class="k">yield</span> <span class="n">i</span>
</code></pre></div>
<p>接下来，让我们看看如何使用异步生成器。</p>
</div>
</div>
</div>
<h4 id="1622-创建异步生成器">16.2.2 创建异步生成器<a class="headerlink" href="#1622-创建异步生成器" title="Permanent link">&para;</a></h4>
<p><strong>16.2.2 Create Asynchronous Generator</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="89:2"><input checked="checked" id="__tabbed_89_1" name="__tabbed_89" type="radio" /><input id="__tabbed_89_2" name="__tabbed_89" type="radio" /><div class="tabbed-labels"><label for="__tabbed_89_1">English</label><label for="__tabbed_89_2">Chinese</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<p>To use an asynchronous generator we must create the generator.</p>
<p>This looks like calling it, but instead creates and returns an iterator object.</p>
<p>For example:</p>
<div class="highlight"><pre><span></span><code><span class="o">...</span>
<span class="c1"># create the iterator</span>
<span class="n">it</span> <span class="o">=</span> <span class="n">async_generator</span><span class="p">()</span>
</code></pre></div>
<p>This returns a type of asynchronous iterator called an asynchronous generator iterator.</p>
</div>
<div class="tabbed-block">
<p>要使用异步生成器，我们必须创建生成器。</p>
<p>这看起来像是调用它，但实际上是创建并返回一个迭代器对象。</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code><span class="o">...</span>
<span class="c1"># 创建迭代器</span>
<span class="n">it</span> <span class="o">=</span> <span class="n">async_generator</span><span class="p">()</span>
</code></pre></div>
<p>这会返回一种称为异步生成器的可迭代的异步迭代器。</p>
</div>
</div>
</div>
<h4 id="1623-使用异步生成器">16.2.3 使用异步生成器<a class="headerlink" href="#1623-使用异步生成器" title="Permanent link">&para;</a></h4>
<p><strong>16.2.3 Step an Asynchronous Generator</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="90:2"><input checked="checked" id="__tabbed_90_1" name="__tabbed_90" type="radio" /><input id="__tabbed_90_2" name="__tabbed_90" type="radio" /><div class="tabbed-labels"><label for="__tabbed_90_1">English</label><label for="__tabbed_90_2">Chinese</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<p>One step of the generator can be traversed using the <a href="https://docs.python.org/3/library/functions.html#anext">anext()</a> built-in function, just like a classical generator using the <strong>next()</strong> function.</p>
<p>The result is an awaitable that is awaited.</p>
<p>For example:</p>
<div class="highlight"><pre><span></span><code><span class="o">...</span>
<span class="c1"># get an awaitable for one step of the generator</span>
<span class="n">awaitable</span> <span class="o">=</span> <span class="n">anext</span><span class="p">(</span><span class="n">gen</span><span class="p">)</span>
<span class="c1"># execute the one step of the generator and get the result</span>
<span class="n">result</span> <span class="o">=</span> <span class="k">await</span> <span class="n">awaitable</span>
</code></pre></div>
<p>This can be achieved in one step.</p>
<p>For example:</p>
<div class="highlight"><pre><span></span><code><span class="o">...</span>
<span class="c1"># step the async generator</span>
<span class="n">result</span> <span class="o">=</span> <span class="k">await</span> <span class="n">anext</span><span class="p">(</span><span class="n">gen</span><span class="p">)</span>
</code></pre></div>
</div>
<div class="tabbed-block">
<p>可以使用 <a href="https://docs.python.org/3/library/functions.html#anext">anext()</a> 内置函数遍历生成器的一步，就像使用 <strong>next()</strong> 函数的经典生成器一样 。</p>
<p>结果是一个值得期待的结果。</p>
<p>例如:</p>
<div class="highlight"><pre><span></span><code><span class="o">...</span>
<span class="c1"># 获取生成器一步的等待值</span>
<span class="n">awaitable</span> <span class="o">=</span> <span class="n">anext</span><span class="p">(</span><span class="n">gen</span><span class="p">)</span>
<span class="c1"># 执行生成器的一步并得到结果</span>
<span class="n">result</span> <span class="o">=</span> <span class="k">await</span> <span class="n">awaitable</span>
</code></pre></div>
<p>这可以一步实现。</p>
<p>例如:</p>
<div class="highlight"><pre><span></span><code><span class="o">...</span>
<span class="c1"># 启动异步生成器</span>
<span class="n">result</span> <span class="o">=</span> <span class="k">await</span> <span class="n">anext</span><span class="p">(</span><span class="n">gen</span><span class="p">)</span>
</code></pre></div>
</div>
</div>
</div>
<h4 id="1624-遍历异步生成器">16.2.4 遍历异步生成器<a class="headerlink" href="#1624-遍历异步生成器" title="Permanent link">&para;</a></h4>
<p><strong>16.2.4 Traverse an Asynchronous Generator</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="91:2"><input checked="checked" id="__tabbed_91_1" name="__tabbed_91" type="radio" /><input id="__tabbed_91_2" name="__tabbed_91" type="radio" /><div class="tabbed-labels"><label for="__tabbed_91_1">English</label><label for="__tabbed_91_2">Chinese</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<p>The asynchronous generator can also be traversed in a loop using the “<strong>async for</strong>” expression that will await each iteration of the loop automatically.</p>
<p>For example:</p>
<div class="highlight"><pre><span></span><code>...
# traverse an asynchronous generator
async for result in async_generator():
    print(result)
</code></pre></div>
<p>You can learn more about the “async for” expression in the tutorial:</p>
<p>We may also use an asynchronous list comprehension with the “async for” expression to collect the results of the generator.</p>
<p>For example:</p>
<div class="highlight"><pre><span></span><code>...
# async list comprehension with async generator
results = [item async for item in async_generator()]
</code></pre></div>
</div>
<div class="tabbed-block">
<p>还可以使用“<strong>async for</strong>”表达式在循环中遍历异步生成器，该表达式将自动等待循环的每次迭代。</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>...
# 遍历异步生成器
async for result in async_generator():
    print(result)
</code></pre></div>
<p>您可以在教程中了解有关“async for”表达式的更多信息：</p>
<p>我们还可以使用异步列表理解和“async for”表达式来收集生成器的结果。</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>...
# 使用异步生成器的异步列表推导式
results = [item async for item in async_generator()]
</code></pre></div>
</div>
</div>
</div>
<h3 id="163-异步生成器示例">16.3 异步生成器示例<a class="headerlink" href="#163-异步生成器示例" title="Permanent link">&para;</a></h3>
<p><strong>16.3 Example of an Asynchronous Generator</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="92:2"><input checked="checked" id="__tabbed_92_1" name="__tabbed_92" type="radio" /><input id="__tabbed_92_2" name="__tabbed_92" type="radio" /><div class="tabbed-labels"><label for="__tabbed_92_1">English</label><label for="__tabbed_92_2">Chinese</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<p>We can explore how to traverse an asynchronous generator using the “<strong>async for</strong>” expression.</p>
<p>In this example, we will update the previous example to traverse the generator to completion using an “<strong>async for</strong>” loop.</p>
<p>This loop will automatically await each awaitable returned from the generator, retrieve the yielded value, and make it available within the loop body so that in this case it can be reported.</p>
<p>This is perhaps the most common usage pattern for asynchronous generators.</p>
<p>The complete example is listed below.</p>
<div class="highlight"><pre><span></span><code><span class="c1"># SuperFastPython.com</span>
<span class="c1"># example of asynchronous generator with async for loop</span>
<span class="kn">import</span> <span class="nn">asyncio</span>

<span class="c1"># define an asynchronous generator</span>
<span class="k">async</span> <span class="k">def</span> <span class="nf">async_generator</span><span class="p">():</span>
    <span class="c1"># normal loop</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span>
        <span class="c1"># block to simulate doing work</span>
        <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="c1"># yield the result</span>
        <span class="k">yield</span> <span class="n">i</span>

<span class="c1"># main coroutine</span>
<span class="k">async</span> <span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="c1"># loop over async generator with async for loop</span>
    <span class="k">async</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">async_generator</span><span class="p">():</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>

<span class="c1"># execute the asyncio program</span>
<span class="n">asyncio</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">main</span><span class="p">())</span>
</code></pre></div>
<p>Running the example first creates the <strong>main()</strong> coroutine and uses it as the entry point into the asyncio program.</p>
<p>The <strong>main()</strong> coroutine runs and starts the for loop.</p>
<p>An instance of the asynchronous generator is created and the loop automatically steps it using the <strong>anext()</strong> function to return an awaitable. The loop then awaits the awaitable and retrieves a value which is made available to the body of the loop where it is reported.</p>
<p>This process is then repeated, suspending the main() coroutine, executing an iteration of the generator, and suspending, and resuming the <strong>main()</strong> coroutine until the generator is exhausted.</p>
<p>This highlights how an asynchronous generator can be traversed using an async for expression.</p>
<div class="highlight"><pre><span></span><code>0
1
2
3
4
5
6
7
8
9
</code></pre></div>
<p>You can learn more about async generators in the tutorial:</p>
<ul>
<li><a href="https://superfastpython.com/asynchronous-generators-in-python/">Asynchronous Generators in Python</a></li>
</ul>
<p>Next, we will explore asynchronous context managers.</p>
</div>
<div class="tabbed-block">
<p>我们可以探索如何使用“<strong>async for</strong>”表达式遍历异步生成器。</p>
<p>在此示例中，我们将更新前面的示例，以使用“<strong>async for</strong>”循环遍历生成器直至完成。</p>
<p>该循环将自动等待从生成器返回的每个等待，检索生成的值，并使其在循环体内可用，以便在这种情况下可以报告它。</p>
<p>这可能是异步生成器最常见的使用模式。</p>
<p>下面列出了完整的示例。</p>
<div class="highlight"><pre><span></span><code><span class="c1"># SuperFastPython.com</span>
<span class="c1"># 带有 async for 循环的异步生成器示例</span>
<span class="kn">import</span> <span class="nn">asyncio</span>

<span class="c1"># define an asynchronous generator</span>
<span class="k">async</span> <span class="k">def</span> <span class="nf">async_generator</span><span class="p">():</span>
    <span class="c1"># 正常循环</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span>
        <span class="c1"># 块来模拟做工作</span>
        <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="c1"># 产生结果</span>
        <span class="k">yield</span> <span class="n">i</span>

<span class="c1"># 主协程</span>
<span class="k">async</span> <span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="c1"># 使用 async for 循环遍历异步生成器</span>
    <span class="k">async</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">async_generator</span><span class="p">():</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>

<span class="c1"># 执行异步程序</span>
<span class="n">asyncio</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">main</span><span class="p">())</span>
</code></pre></div>
<p>运行该示例首先创建 <strong>main()</strong> 协程，并将其用作 asyncio 程序的入口点。</p>
<p><strong>main()</strong> 协程运行并启动 for 循环。</p>
<p>创建异步生成器的实例，循环使用 <strong>anext()</strong> 函数自动步进它以返回可等待的对象。 然后，循环等待可等待对象并检索一个值，该值可供报告该值的循环体使用。</p>
<p>然后重复这个过程，挂起 <strong>main()</strong> 协程，执行生成器的迭代，挂起并恢复 <strong>main()</strong> 协程，直到生成器耗尽。</p>
<p>这突出显示了如何使用 <strong>async for</strong> 表达式遍历异步生成器。</p>
<div class="highlight"><pre><span></span><code>0
1
2
3
4
5
6
7
8
9
</code></pre></div>
<p>您可以在教程中了解有关异步生成器的更多信息：</p>
<ul>
<li><a href="https://superfastpython.com/asynchronous-generators-in-python/">Python 中的异步生成器</a></li>
</ul>
<p>接下来，我们将探讨异步上下文管理器。</p>
</div>
</div>
</div>
<h2 id="17-异步上下文管理器">17. 异步上下文管理器<a class="headerlink" href="#17-异步上下文管理器" title="Permanent link">&para;</a></h2>
<p><strong>17. Asynchronous Context Managers</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="93:2"><input checked="checked" id="__tabbed_93_1" name="__tabbed_93" type="radio" /><input id="__tabbed_93_2" name="__tabbed_93" type="radio" /><div class="tabbed-labels"><label for="__tabbed_93_1">English</label><label for="__tabbed_93_2">Chinese</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<p>A context manager is a Python construct that provides a try-finally like environment with a consistent interface and handy syntax, e.g. via the “with” expression.</p>
<p>It is commonly used with resources, ensuring the resource is always closed or released after we are finished with it, regardless of whether the usage of the resources was successful or failed with an exception.</p>
<p>Asyncio allows us to develop asynchronous context managers.</p>
<p>We can create and use asynchronous context managers in asyncio programs by defining an object that implements the <strong>__aenter__()</strong> and <strong>__aexit__()</strong> methods as coroutines.</p>
<p>Let’s take a closer look.</p>
</div>
<div class="tabbed-block">
<p>上下文管理器是一个 Python 结构，它提供了一个类似 try-finally 的环境，具有一致的接口和方便的语法，例如 通过“with”表达。</p>
<p>它通常与资源一起使用，确保资源在使用完毕后始终关闭或释放，无论资源的使用是否成功或因异常而失败。</p>
<p>Asyncio 允许我们开发异步上下文管理器。</p>
<p>我们可以通过定义一个实现 <strong>__aenter__()</strong> 和 <strong>__aexit__()</strong> 方法的对象作为协程来在 asyncio 程序中创建和使用异步上下文管理器。</p>
<p>让我们仔细看看。</p>
</div>
</div>
</div>
<h3 id="171-什么是异步上下文管理器">17.1 什么是异步上下文管理器<a class="headerlink" href="#171-什么是异步上下文管理器" title="Permanent link">&para;</a></h3>
<p><strong>17.1 What is an Asynchronous Context Manager</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="94:2"><input checked="checked" id="__tabbed_94_1" name="__tabbed_94" type="radio" /><input id="__tabbed_94_2" name="__tabbed_94" type="radio" /><div class="tabbed-labels"><label for="__tabbed_94_1">English</label><label for="__tabbed_94_2">Chinese</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<p>An asynchronous context manager is a Python object that implements the <strong>__aenter__()</strong> and <strong>__aexit_ _()</strong> methods.</p>
<p>Before we dive into the details of asynchronous context managers, let’s review classical context managers.</p>
</div>
<div class="tabbed-block">
<p>异步上下文管理器是一个实现 <strong>__aenter__()</strong> 和 <strong>__aexit__()</strong> 方法的 Python 对象。</p>
<p>在我们深入了解异步上下文管理器的细节之前，让我们回顾一下经典的上下文管理器。</p>
</div>
</div>
</div>
<h4 id="1711--上下文管理器">17.1.1  上下文管理器<a class="headerlink" href="#1711--上下文管理器" title="Permanent link">&para;</a></h4>
<p><strong>17.1.1  Context Manager</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="95:2"><input checked="checked" id="__tabbed_95_1" name="__tabbed_95" type="radio" /><input id="__tabbed_95_2" name="__tabbed_95" type="radio" /><div class="tabbed-labels"><label for="__tabbed_95_1">English</label><label for="__tabbed_95_2">Chinese</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<p>A context manager is a Python object that implements the __enter__() and __exit__() methods.</p>
<blockquote>
<p>A context manager is an object that defines the runtime context to be established when executing a with statement. The context manager handles the entry into, and the exit from, the desired runtime context for the execution of the block of code.</p>
<p>— <a href="https://docs.python.org/3/reference/datamodel.html#context-managers">WITH STATEMENT CONTEXT MANAGERS</a></p>
</blockquote>
<ul>
<li>The __enter__() method defines what happens at the beginning of a block, such as opening or preparing resources, like a file, socket or thread pool.</li>
<li>The __exit__() method defines what happens when the block is exited, such as closing a prepared resource.</li>
</ul>
<blockquote>
<p>Typical uses of context managers include saving and restoring various kinds of global state, locking and unlocking resources, closing opened files, etc.</p>
<p>— <a href="https://docs.python.org/3/reference/datamodel.html#context-managers">WITH STATEMENT CONTEXT MANAGERS</a></p>
</blockquote>
<p>A context manager is used via the “with” expression.</p>
<p>Typically the context manager object is created in the beginning of the “with” expression and the __enter__() method is called automatically. The body of the content makes use of the resource via the named context manager object, then the __aexit__() method is called automatically when the block is exited, normally or via an exception.</p>
<p>For example:</p>
<div class="highlight"><pre><span></span><code><span class="o">...</span>
<span class="c1"># open a context manager</span>
<span class="k">with</span> <span class="n">ContextManager</span><span class="p">()</span> <span class="k">as</span> <span class="n">manager</span><span class="p">:</span>
    <span class="c1"># ...</span>
<span class="c1"># closed automatically</span>
<span class="n">This</span> <span class="n">mirrors</span> <span class="n">a</span> <span class="k">try</span><span class="o">-</span><span class="k">finally</span> <span class="n">expression</span><span class="o">.</span>
</code></pre></div>
<p>For example:</p>
<div class="highlight"><pre><span></span><code><span class="o">...</span>
<span class="c1"># create the object</span>
<span class="n">manager</span> <span class="o">=</span> <span class="n">ContextManager</span><span class="p">()</span>
<span class="k">try</span><span class="p">:</span>
    <span class="n">manager</span><span class="o">.</span><span class="fm">__enter__</span><span class="p">()</span>
    <span class="c1"># ...</span>
<span class="k">finally</span><span class="p">:</span>
    <span class="n">manager</span><span class="o">.</span><span class="fm">__exit__</span><span class="p">()</span>
</code></pre></div>
<p>Next, let’s take a look at asynchronous context managers.</p>
</div>
<div class="tabbed-block">
<p>上下文管理器是一个实现 __enter__() 和 __exit__() 方法的 Python 对象。</p>
<blockquote>
<p>上下文管理器是一个对象，它定义执行 with 语句时要建立的运行时上下文。 上下文管理器处理执行代码块所需的运行时上下文的进入和退出。</p>
<p>— <a href="https://docs.python.org/3/reference/datamodel.html#context-managers">WITH STATEMENT CONTEXT MANAGERS</a></p>
</blockquote>
<ul>
<li>__enter__() 方法定义在块开始时发生的情况，例如打开或准备资源，如文件、套接字或线程池。</li>
<li>__exit__() 方法定义退出块时会发生什么，例如关闭准备好的资源。</li>
</ul>
<blockquote>
<p>上下文管理器的典型用途包括保存和恢复各种全局状态、锁定和解锁资源、关闭打开的文件等。</p>
<p>— <a href="https://docs.python.org/3/reference/datamodel.html#context-managers">WITH STATEMENT CONTEXT MANAGERS</a></p>
</blockquote>
<p>上下文管理器通过“with”表达式使用。</p>
<p>通常，上下文管理器对象是在“with”表达式的开头创建的，并且自动调用 __enter__() 方法。 内容的主体通过指定的上下文管理器对象使用资源，然后当块正常或通过异常退出时，自动调用 __aexit__() 方法。</p>
<p>例如:</p>
<div class="highlight"><pre><span></span><code><span class="o">...</span>
<span class="c1"># 打开上下文管理器</span>
<span class="k">with</span> <span class="n">ContextManager</span><span class="p">()</span> <span class="k">as</span> <span class="n">manager</span><span class="p">:</span>
    <span class="c1"># ...</span>
<span class="c1"># 自动关闭</span>
<span class="n">This</span> <span class="n">mirrors</span> <span class="n">a</span> <span class="k">try</span><span class="o">-</span><span class="k">finally</span> <span class="n">expression</span><span class="o">.</span>
</code></pre></div>
<p>例如:</p>
<div class="highlight"><pre><span></span><code><span class="o">...</span>
<span class="c1"># 创建对象</span>
<span class="n">manager</span> <span class="o">=</span> <span class="n">ContextManager</span><span class="p">()</span>
<span class="k">try</span><span class="p">:</span>
    <span class="n">manager</span><span class="o">.</span><span class="fm">__enter__</span><span class="p">()</span>
    <span class="c1"># ...</span>
<span class="k">finally</span><span class="p">:</span>
    <span class="n">manager</span><span class="o">.</span><span class="fm">__exit__</span><span class="p">()</span>
</code></pre></div>
<p>接下来，让我们看一下异步上下文管理器。</p>
</div>
</div>
</div>
<h4 id="1712-异步上下文管理器">17.1.2 异步上下文管理器<a class="headerlink" href="#1712-异步上下文管理器" title="Permanent link">&para;</a></h4>
<p><strong>17.1.2  Asynchronous Context Manager</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="96:2"><input checked="checked" id="__tabbed_96_1" name="__tabbed_96" type="radio" /><input id="__tabbed_96_2" name="__tabbed_96" type="radio" /><div class="tabbed-labels"><label for="__tabbed_96_1">English</label><label for="__tabbed_96_2">Chinese</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<p>Asynchronous context managers were introduced in “<a href="https://peps.python.org/pep-0492/">PEP 492 – Coroutines with async and await syntax</a>“.</p>
<p>They provide a context manager that can be suspended when entering and exiting.</p>
<blockquote>
<p>An asynchronous context manager is a context manager that is able to suspend execution in its __aenter__ and __aexit__ methods.</p>
<p>— ASYNCHRONOUS CONTEXT MANAGERS</p>
</blockquote>
<p>The __aenter__ and __aexit__ methods are defined as coroutines and are awaited by the caller.</p>
<p>This is achieved using the “<strong>async with</strong>” expression.</p>
<p>You can learn more about the “<strong>async with</strong>” expression in the tutorial:</p>
<ul>
<li><a href="https://superfastpython.com/asyncio-async-with/">What is Asyncio async with</a></li>
</ul>
<p>As such, asynchronous context managers can only be used within asyncio programs, such as within calling coroutines.</p>
<p>What is “async with”</p>
<p>The “<strong>async with</strong>” expression is for creating and using asynchronous context managers.</p>
<p>It is an extension of the “<strong>with</strong>” expression for use in coroutines within asyncio programs.</p>
<p>The “<strong>async with</strong>” expression is just like the “<strong>with</strong>” expression used for context managers, except it allows asynchronous context managers to be used within coroutines.</p>
<p>In order to better understand “<strong>async with</strong>“, let’s take a closer look at asynchronous context managers.</p>
<p>The async with expression allows a coroutine to create and use an asynchronous version of a context manager.</p>
<p>For example:</p>
<div class="highlight"><pre><span></span><code><span class="o">...</span>
<span class="c1"># create and use an asynchronous context manager</span>
<span class="k">async</span> <span class="k">with</span> <span class="n">AsyncContextManager</span><span class="p">()</span> <span class="k">as</span> <span class="n">manager</span><span class="p">:</span>
    <span class="c1"># ...</span>
</code></pre></div>
<p>This is equivalent to something like:</p>
<div class="highlight"><pre><span></span><code><span class="o">...</span>
<span class="c1"># create or enter the async context manager</span>
<span class="n">manager</span> <span class="o">=</span> <span class="k">await</span> <span class="n">AsyncContextManager</span><span class="p">()</span>
<span class="k">try</span><span class="p">:</span>
    <span class="c1"># ...</span>
<span class="k">finally</span><span class="p">:</span>
    <span class="c1"># close or exit the context manager</span>
    <span class="k">await</span> <span class="n">manager</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</code></pre></div>
<p>Notice that we are implementing much the same pattern as a traditional context manager, except that creating and closing the context manager involve awaiting coroutines.</p>
<p>This suspends the execution of the current coroutine, schedules a new coroutine and waits for it to complete.</p>
<p>As such an asynchronous context manager must implement the <strong>__aenter__()</strong> and <strong>__aexit__()</strong> methods that must be defined via the async def expression. This makes them coroutines themselves which may also await.</p>
</div>
<div class="tabbed-block">
<p>异步上下文管理器在“<a href="https://peps.python.org/pep-0492/">PEP 492 – 具有异步和等待语法的协程</a>”中引入。</p>
<p>它们提供了一个上下文管理器，可以在进入和退出时暂停。</p>
<blockquote>
<p>异步上下文管理器是能够在其 __aenter__ 和 __aexit__ 方法中暂停执行的上下文管理器。</p>
<p>— <a href="https://docs.python.org/3/reference/datamodel.html#asynchronous-context-managers">ASYNCHRONOUS CONTEXT MANAGERS</a></p>
</blockquote>
<p><strong>__aenter__</strong> 和 <strong>__aexit__</strong> 方法被定义为协程并由调用者等待。</p>
<p>这是使用“<strong>async with</strong>”表达式来实现的。</p>
<p>您可以在教程中了解有关“<strong>async with</strong>”表达式的更多信息：</p>
<ul>
<li><a href="https://superfastpython.com/asyncio-async-with/">Asyncio 异步是什么</a></li>
</ul>
<p>因此，异步上下文管理器只能在 asyncio 程序中使用，例如在调用协程中。</p>
<p>什么是“异步”</p>
<p>“<strong>async with</strong>”表达式用于创建和使用异步上下文管理器。</p>
<p>它是“<strong>with</strong>”表达式的扩展，用于 asyncio 程序中的协程。</p>
<p>“<strong>async with</strong>”表达式就像用于上下文管理器的“<strong>with</strong>”表达式一样，只不过它允许在协程中使用异步上下文管理器。</p>
<p>为了更好地理解“<strong>async with</strong>”，让我们仔细看看异步上下文管理器。</p>
<p>async with 表达式允许协程创建和使用上下文管理器的异步版本。</p>
<p>例如:</p>
<div class="highlight"><pre><span></span><code><span class="o">...</span>
<span class="c1"># 创建并使用异步上下文管理器</span>
<span class="k">async</span> <span class="k">with</span> <span class="n">AsyncContextManager</span><span class="p">()</span> <span class="k">as</span> <span class="n">manager</span><span class="p">:</span>
    <span class="c1"># ...</span>
</code></pre></div>
<p>这相当于：</p>
<div class="highlight"><pre><span></span><code><span class="o">...</span>
<span class="c1"># 创建或进入异步上下文管理器</span>
<span class="n">manager</span> <span class="o">=</span> <span class="k">await</span> <span class="n">AsyncContextManager</span><span class="p">()</span>
<span class="k">try</span><span class="p">:</span>
    <span class="c1"># ...</span>
<span class="k">finally</span><span class="p">:</span>
    <span class="c1"># 关闭或退出上下文管理器</span>
    <span class="k">await</span> <span class="n">manager</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</code></pre></div>
<p>请注意，我们实现的模式与传统上下文管理器几乎相同，只是创建和关闭上下文管理器涉及等待协程。</p>
<p>这会暂停当前协程的执行，安排一个新的协程并等待其完成。</p>
<p>因此，异步上下文管理器必须实现 <strong>__aenter__()</strong> 和 <strong>__aexit__()</strong> 方法，这些方法必须通过 async def 表达式定义。 这使得它们本身成为协程，也可能等待。</p>
</div>
</div>
</div>
<h3 id="172-如何使用异步上下文管理器">17.2 如何使用异步上下文管理器<a class="headerlink" href="#172-如何使用异步上下文管理器" title="Permanent link">&para;</a></h3>
<p><strong>17.2 How to Use Asynchronous Context Managers</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="97:2"><input checked="checked" id="__tabbed_97_1" name="__tabbed_97" type="radio" /><input id="__tabbed_97_2" name="__tabbed_97" type="radio" /><div class="tabbed-labels"><label for="__tabbed_97_1">English</label><label for="__tabbed_97_2">Chinese</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<p>In this section, we will explore how we can define, create, and use asynchronous context managers in our asyncio programs.</p>
</div>
<div class="tabbed-block">
<p>在本节中，我们将探讨如何在 asyncio 程序中定义、创建和使用异步上下文管理器。</p>
</div>
</div>
</div>
<h4 id="1721-定义异步上下文管理器">17.2.1 定义异步上下文管理器<a class="headerlink" href="#1721-定义异步上下文管理器" title="Permanent link">&para;</a></h4>
<p><strong>17.2.1 Define an Asynchronous Context Manager</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="98:2"><input checked="checked" id="__tabbed_98_1" name="__tabbed_98" type="radio" /><input id="__tabbed_98_2" name="__tabbed_98" type="radio" /><div class="tabbed-labels"><label for="__tabbed_98_1">English</label><label for="__tabbed_98_2">Chinese</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<p>We can define an asynchronous context manager as a Python object that implements the <strong><strong>aenter</strong>()</strong> and <strong><strong>aexit</strong>()</strong> methods.</p>
<p>Importantly, both methods must be defined as coroutines using the “<strong>async def</strong>” and therefore must return awaitables.</p>
<p>For example:</p>
<div class="highlight"><pre><span></span><code><span class="c1"># define an asynchronous context manager</span>
<span class="k">class</span> <span class="nc">AsyncContextManager</span><span class="p">:</span>
    <span class="c1"># enter the async context manager</span>
    <span class="k">async</span> <span class="k">def</span> <span class="fm">__aenter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># report a message</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;&gt;entering the context manager&#39;</span><span class="p">)</span>

    <span class="c1"># exit the async context manager</span>
    <span class="k">async</span> <span class="k">def</span> <span class="fm">__aexit__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">exc_type</span><span class="p">,</span> <span class="n">exc</span><span class="p">,</span> <span class="n">tb</span><span class="p">):</span>
        <span class="c1"># report a message</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;&gt;exiting the context manager&#39;</span><span class="p">)</span>
</code></pre></div>
<p>Because each of the methods are coroutines, they may themselves await coroutines or tasks.</p>
<p>For example:</p>
<div class="highlight"><pre><span></span><code><span class="c1"># define an asynchronous context manager</span>
<span class="k">class</span> <span class="nc">AsyncContextManager</span><span class="p">:</span>
    <span class="c1"># enter the async context manager</span>
    <span class="k">async</span> <span class="k">def</span> <span class="fm">__aenter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># report a message</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;&gt;entering the context manager&#39;</span><span class="p">)</span>
        <span class="c1"># block for a moment</span>
        <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span>

    <span class="c1"># exit the async context manager</span>
    <span class="k">async</span> <span class="k">def</span> <span class="fm">__aexit__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">exc_type</span><span class="p">,</span> <span class="n">exc</span><span class="p">,</span> <span class="n">tb</span><span class="p">):</span>
        <span class="c1"># report a message</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;&gt;exiting the context manager&#39;</span><span class="p">)</span>
        <span class="c1"># block for a moment</span>
        <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span>
</code></pre></div>
</div>
<div class="tabbed-block">
<p>我们可以将异步上下文管理器定义为实现 <strong><strong>aenter</strong>()</strong> 和 <strong><strong>aexit</strong>()</strong> 方法的 Python 对象。</p>
<p>重要的是，这两种方法都必须使用“<strong>async def</strong>”定义为协程，因此必须返回可等待对象。</p>
<p>例如:</p>
<div class="highlight"><pre><span></span><code><span class="c1"># 定义异步上下文管理器</span>
<span class="k">class</span> <span class="nc">AsyncContextManager</span><span class="p">:</span>
    <span class="c1"># 进入异步上下文管理器</span>
    <span class="k">async</span> <span class="k">def</span> <span class="fm">__aenter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># 报告消息</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;&gt;entering the context manager&#39;</span><span class="p">)</span>

    <span class="c1"># 退出异步上下文管理器</span>
    <span class="k">async</span> <span class="k">def</span> <span class="fm">__aexit__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">exc_type</span><span class="p">,</span> <span class="n">exc</span><span class="p">,</span> <span class="n">tb</span><span class="p">):</span>
        <span class="c1"># 报告消息</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;&gt;exiting the context manager&#39;</span><span class="p">)</span>
</code></pre></div>
<p>因为每个方法都是协程，所以它们本身可能等待协程或任务。</p>
<p>例如:</p>
<div class="highlight"><pre><span></span><code><span class="c1"># 定义异步上下文管理器</span>
<span class="k">class</span> <span class="nc">AsyncContextManager</span><span class="p">:</span>
    <span class="c1"># 进入异步上下文管理器</span>
    <span class="k">async</span> <span class="k">def</span> <span class="fm">__aenter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># 报告消息</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;&gt;entering the context manager&#39;</span><span class="p">)</span>
        <span class="c1"># 暂时阻塞</span>
        <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span>

    <span class="c1"># 退出异步上下文管理器</span>
    <span class="k">async</span> <span class="k">def</span> <span class="fm">__aexit__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">exc_type</span><span class="p">,</span> <span class="n">exc</span><span class="p">,</span> <span class="n">tb</span><span class="p">):</span>
        <span class="c1"># 报告消息</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;&gt;exiting the context manager&#39;</span><span class="p">)</span>
        <span class="c1"># 暂时阻塞</span>
        <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span>
</code></pre></div>
</div>
</div>
</div>
<h4 id="1722-使用异步上下文管理器">17.2.2 使用异步上下文管理器<a class="headerlink" href="#1722-使用异步上下文管理器" title="Permanent link">&para;</a></h4>
<p><strong>17.2.2 Use an Asynchronous Context Manager</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="99:2"><input checked="checked" id="__tabbed_99_1" name="__tabbed_99" type="radio" /><input id="__tabbed_99_2" name="__tabbed_99" type="radio" /><div class="tabbed-labels"><label for="__tabbed_99_1">English</label><label for="__tabbed_99_2">Chinese</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<p>An asynchronous context manager is used via the “<strong>async with</strong>” expression.</p>
<p>This will automatically await the enter and exit coroutines, suspending the calling coroutine as needed.</p>
<p>For example:</p>
<div class="highlight"><pre><span></span><code><span class="o">...</span>
<span class="c1"># use an asynchronous context manager</span>
<span class="k">async</span> <span class="k">with</span> <span class="n">AsyncContextManager</span><span class="p">()</span> <span class="k">as</span> <span class="n">manager</span><span class="p">:</span>
    <span class="c1"># ...</span>
</code></pre></div>
<p>As such, the “<strong>async with</strong>” expression and asynchronous context managers more generally can only be used within asyncio programs, such as within coroutines.</p>
<p>Now that we know how to use asynchronous context managers, let’s look at a worked example.</p>
</div>
<div class="tabbed-block">
<p>异步上下文管理器通过“<strong>async with</strong>”表达式使用。</p>
<p>这将自动等待进入和退出协程，并根据需要暂停调用协程。</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code><span class="o">...</span>
<span class="c1"># 使用异步上下文管理器</span>
<span class="k">async</span> <span class="k">with</span> <span class="n">AsyncContextManager</span><span class="p">()</span> <span class="k">as</span> <span class="n">manager</span><span class="p">:</span>
    <span class="c1"># ...</span>
</code></pre></div>
<p>因此，“<strong>async with</strong>”表达式和异步上下文管理器更一般地只能在 asyncio 程序中使用，例如在协程中。</p>
<p>现在我们知道如何使用异步上下文管理器，让我们看一个有效的示例。</p>
</div>
</div>
</div>
<h3 id="173-异步上下文管理器和async-with的示例">17.3 异步上下文管理器和“async with”的示例<a class="headerlink" href="#173-异步上下文管理器和async-with的示例" title="Permanent link">&para;</a></h3>
<p><strong>17.3 Example of an Asynchronous Context Manager and “async with”</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="100:2"><input checked="checked" id="__tabbed_100_1" name="__tabbed_100" type="radio" /><input id="__tabbed_100_2" name="__tabbed_100" type="radio" /><div class="tabbed-labels"><label for="__tabbed_100_1">English</label><label for="__tabbed_100_2">Chinese</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<p>We can explore how to use an asynchronous context manager via the “<strong>async with</strong>” expression.</p>
<p>In this example, we will update the above example to use the context manager in a normal manner.</p>
<p>We will use an “<strong>async with</strong>” expression and on one line, create and enter the context manager. This will automatically await the enter method.</p>
<p>We can then make use of the manager within the inner block. In this case, we will just report a message.</p>
<p>Exiting the inner block will automatically await the exit method of the context manager.</p>
<p>Contrasting this example with the previous example shows how much heavy lifting the “<strong>async with</strong>” expression does for us in an asyncio program.</p>
<p>The complete example is listed below.</p>
<div class="highlight"><pre><span></span><code><span class="c1"># SuperFastPython.com</span>
<span class="c1"># example of an asynchronous context manager via async with</span>
<span class="kn">import</span> <span class="nn">asyncio</span>

<span class="c1"># define an asynchronous context manager</span>
<span class="k">class</span> <span class="nc">AsyncContextManager</span><span class="p">:</span>
    <span class="c1"># enter the async context manager</span>
    <span class="k">async</span> <span class="k">def</span> <span class="fm">__aenter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># report a message</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;&gt;entering the context manager&#39;</span><span class="p">)</span>
        <span class="c1"># block for a moment</span>
        <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span>

    <span class="c1"># exit the async context manager</span>
    <span class="k">async</span> <span class="k">def</span> <span class="fm">__aexit__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">exc_type</span><span class="p">,</span> <span class="n">exc</span><span class="p">,</span> <span class="n">tb</span><span class="p">):</span>
        <span class="c1"># report a message</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;&gt;exiting the context manager&#39;</span><span class="p">)</span>
        <span class="c1"># block for a moment</span>
        <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span>

<span class="c1"># define a simple coroutine</span>
<span class="k">async</span> <span class="k">def</span> <span class="nf">custom_coroutine</span><span class="p">():</span>
    <span class="c1"># create and use the asynchronous context manager</span>
    <span class="k">async</span> <span class="k">with</span> <span class="n">AsyncContextManager</span><span class="p">()</span> <span class="k">as</span> <span class="n">manager</span><span class="p">:</span>
        <span class="c1"># report the result</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;within the manager&#39;</span><span class="p">)</span>

<span class="c1"># start the asyncio program</span>
<span class="n">asyncio</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">custom_coroutine</span><span class="p">())</span>
</code></pre></div>
<p>Running the example first creates the <strong>main()</strong> coroutine and uses it as the entry point into the asyncio program.</p>
<p>The <strong>main()</strong> coroutine runs and creates an instance of our <strong>AsyncContextManager</strong> class in an “<strong>async with</strong>” expression.</p>
<p>This expression automatically calls the enter method and awaits the coroutine. A message is reported and the coroutine blocks for a moment.</p>
<p>The <strong>main()</strong> coroutine resumes and executes the body of the context manager, printing a message.</p>
<p>The block is exited and the exit method of the context manager is awaited automatically, reporting a message and sleeping a moment.</p>
<p>This highlights the normal usage pattern for an asynchronous context manager in an asyncio program.</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;</span><span class="n">entering</span> <span class="n">the</span> <span class="n">context</span> <span class="n">manager</span>
<span class="n">within</span> <span class="n">the</span> <span class="n">manager</span>
<span class="o">&gt;</span><span class="n">exiting</span> <span class="n">the</span> <span class="n">context</span> <span class="n">manager</span>
</code></pre></div>
<p>You can learn more about async context managers in the tutorial:</p>
<ul>
<li><a href="https://superfastpython.com/asynchronous-context-manager/">Asynchronous Context Managers in Python</a></li>
</ul>
<p>Next, we will explore asynchronous comprehensions.</p>
</div>
<div class="tabbed-block">
<p>我们可以通过“<strong>async with</strong>”表达式探索如何使用异步上下文管理器。</p>
<p>在此示例中，我们将更新上面的示例以正常方式使用上下文管理器。</p>
<p>我们将使用“<strong>async with</strong>”表达式，并在一行中创建并输入上下文管理器。 这将自动等待输入方法。</p>
<p>然后我们可以在内部块中使用管理器。 在这种情况下，我们只会报告一条消息。</p>
<p>退出内部块将自动等待上下文管理器的退出方法。</p>
<p>将此示例与前面的示例进行对比，可以看出“<strong>async with</strong>”表达式在 asyncio 程序中为我们带来了多大的负担。</p>
<p>下面列出了完整的示例。</p>
<div class="highlight"><pre><span></span><code><span class="c1"># SuperFastPython.com</span>
<span class="c1"># 通过 async with 实现异步上下文管理器的示例</span>
<span class="kn">import</span> <span class="nn">asyncio</span>

<span class="c1"># 定义异步上下文管理器</span>
<span class="k">class</span> <span class="nc">AsyncContextManager</span><span class="p">:</span>
    <span class="c1"># 进入异步上下文管理器</span>
    <span class="k">async</span> <span class="k">def</span> <span class="fm">__aenter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># 报告消息</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;&gt;entering the context manager&#39;</span><span class="p">)</span>
        <span class="c1"># 暂时阻塞</span>
        <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span>

    <span class="c1"># 退出异步上下文管理器</span>
    <span class="k">async</span> <span class="k">def</span> <span class="fm">__aexit__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">exc_type</span><span class="p">,</span> <span class="n">exc</span><span class="p">,</span> <span class="n">tb</span><span class="p">):</span>
        <span class="c1"># 报告消息</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;&gt;exiting the context manager&#39;</span><span class="p">)</span>
        <span class="c1"># 暂时阻塞</span>
        <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span>

<span class="c1"># 定义一个简单的协程</span>
<span class="k">async</span> <span class="k">def</span> <span class="nf">custom_coroutine</span><span class="p">():</span>
    <span class="c1"># 创建并使用异步上下文管理器</span>
    <span class="k">async</span> <span class="k">with</span> <span class="n">AsyncContextManager</span><span class="p">()</span> <span class="k">as</span> <span class="n">manager</span><span class="p">:</span>
        <span class="c1"># 报告结果</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;within the manager&#39;</span><span class="p">)</span>

<span class="c1"># 启动异步程序</span>
<span class="n">asyncio</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">custom_coroutine</span><span class="p">())</span>
</code></pre></div>
<p>运行该示例首先创建 <strong>main()</strong> 协程，并将其用作 asyncio 程序的入口点。</p>
<p><strong>main()</strong> 协程运行并在“<strong>async with</strong>”表达式中创建 <strong>AsyncContextManager</strong> 类的实例。</p>
<p>该表达式自动调用 Enter 方法并等待协程。 报告一条消息，协程阻塞片刻。</p>
<p><strong>main()</strong> 协程恢复并执行上下文管理器的主体，打印一条消息。</p>
<p>该块退出并自动等待上下文管理器的退出方法，报告消息并休眠一会儿。</p>
<p>这突出显示了 asyncio 程序中异步上下文管理器的正常使用模式。</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;</span><span class="n">entering</span> <span class="n">the</span> <span class="n">context</span> <span class="n">manager</span>
<span class="n">within</span> <span class="n">the</span> <span class="n">manager</span>
<span class="o">&gt;</span><span class="n">exiting</span> <span class="n">the</span> <span class="n">context</span> <span class="n">manager</span>
</code></pre></div>
<p>您可以在教程中了解有关异步上下文管理器的更多信息：</p>
<ul>
<li><a href="https://superfastpython.com/asynchronous-context-manager/">Asynchronous Context Managers in Python</a></li>
</ul>
<p>接下来，我们将探索异步推导式。</p>
</div>
</div>
</div>
<h2 id="18-异步推导式">18. 异步推导式<a class="headerlink" href="#18-异步推导式" title="Permanent link">&para;</a></h2>
<p><strong>18. Asynchronous Comprehensions</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="101:2"><input checked="checked" id="__tabbed_101_1" name="__tabbed_101" type="radio" /><input id="__tabbed_101_2" name="__tabbed_101" type="radio" /><div class="tabbed-labels"><label for="__tabbed_101_1">English</label><label for="__tabbed_101_2">Chinese</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<p>Comprehensions, like list and dict comprehensions are one feature of Python when we think of “pythonic“.</p>
<p>It is a way we do loops that is different to many other languages.</p>
<p>Asyncio allows us to use asynchronous comprehensions.</p>
<p>We can traverse an asynchronous generators and asynchronous iterators using an asynchronous comprehension via the “<strong>async for</strong>” expression.</p>
<p>Let’s take a closer look.</p>
</div>
<div class="tabbed-block">
<p>当我们想到“Pythonic”时，推导式（例如列表推导式和字典推导式）是 Python 的特征之一。</p>
<p>这是我们执行循环的一种与许多其他语言不同的方式。</p>
<p>Asyncio 允许我们使用异步推导式。</p>
<p>我们可以通过“<strong>async for</strong>”表达式使用异步推导式来遍历异步生成器和异步迭代器。</p>
<p>让我们仔细看看。</p>
</div>
</div>
</div>
<h3 id="181-什么是异步推导式">18.1 什么是异步推导式<a class="headerlink" href="#181-什么是异步推导式" title="Permanent link">&para;</a></h3>
<p><strong>18.1 What are Asynchronous Comprehensions</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="102:2"><input checked="checked" id="__tabbed_102_1" name="__tabbed_102" type="radio" /><input id="__tabbed_102_2" name="__tabbed_102" type="radio" /><div class="tabbed-labels"><label for="__tabbed_102_1">English</label><label for="__tabbed_102_2">Chinese</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<p>An async comprehension is an asynchronous version of a classical comprehension.</p>
<p>Asyncio supports two types of asynchronous comprehensions, they are the “async for” comprehension and the “await” comprehension.</p>
<blockquote>
<p>PEP 530 adds support for using async for in list, set, dict comprehensions and generator expressions</p>
<p>— <a href="https://docs.python.org/3/whatsnew/3.6.html#pep-530-asynchronous-comprehensions">PEP 530: ASYNCHRONOUS COMPREHENSIONS, WHAT’S NEW IN PYTHON 3.6.</a></p>
</blockquote>
<p>Before we look at each, let’s first recall classical comprehensions.</p>
</div>
<div class="tabbed-block">
<p>异步推导式是经典推导式的异步版本。</p>
<p>Asyncio 支持两种类型的异步推导式，它们是“async for”推导和“await”推导。</p>
<blockquote>
<p>PEP 530 添加了对在 列表、集合、字典推导和生成器表达式使用异步的支持</p>
<p>— <a href="https://docs.python.org/3/whatsnew/3.6.html#pep-530-asynchronous-comprehensions">PEP 530: ASYNCHRONOUS COMPREHENSIONS, WHAT’S NEW IN PYTHON 3.6.</a></p>
</blockquote>
<p>在我们讨论每一个之前，让我们首先回顾一下经典的推导式。</p>
</div>
</div>
</div>
<h3 id="182-推导式">18.2 推导式<a class="headerlink" href="#182-推导式" title="Permanent link">&para;</a></h3>
<p><strong>18.2 Comprehensions</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="103:2"><input checked="checked" id="__tabbed_103_1" name="__tabbed_103" type="radio" /><input id="__tabbed_103_2" name="__tabbed_103" type="radio" /><div class="tabbed-labels"><label for="__tabbed_103_1">English</label><label for="__tabbed_103_2">Chinese</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<p>Comprehensions allow data collections like lists, dicts, and sets to be created in a concise way.</p>
<blockquote>
<p>List comprehensions provide a concise way to create lists.</p>
<p>— <a href="https://docs.python.org/3/tutorial/datastructures.html#list-comprehensions">LIST COMPREHENSIONS</a></p>
</blockquote>
<p>A list comprehension allows a list to be created from a for expression within the new list expression.</p>
<p>For example:</p>
<div class="highlight"><pre><span></span><code><span class="o">...</span>
<span class="c1"># create a list using a list comprehension</span>
<span class="n">result</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span><span class="o">*</span><span class="mi">2</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">100</span><span class="p">)]</span>
</code></pre></div>
<p>Comprehensions are also supported for creating dicts and sets.</p>
<p>For example:</p>
<div class="highlight"><pre><span></span><code><span class="o">...</span>
<span class="c1"># create a dict using a comprehension</span>
<span class="n">result</span> <span class="o">=</span> <span class="p">{</span><span class="n">a</span><span class="p">:</span><span class="n">i</span> <span class="k">for</span> <span class="n">a</span><span class="p">,</span><span class="n">i</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">([</span><span class="s1">&#39;a&#39;</span><span class="p">,</span><span class="s1">&#39;b&#39;</span><span class="p">,</span><span class="s1">&#39;c&#39;</span><span class="p">],</span><span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">))}</span>
<span class="c1"># create a set using a comprehension</span>
<span class="n">result</span> <span class="o">=</span> <span class="p">{</span><span class="n">a</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">]}</span>
</code></pre></div>
</div>
<div class="tabbed-block">
<p>推导式允许以简洁的方式创建列表、字典和集合等数据集合。</p>
<blockquote>
<p>列表推导式提供了一种创建列表的简洁方法。</p>
<p>— <a href="https://docs.python.org/3/tutorial/datastructures.html#list-comprehensions">LIST COMPREHENSIONS</a></p>
</blockquote>
<p>列表推导式允许从新列表表达式中的 for 表达式创建列表。</p>
<p>例如:</p>
<div class="highlight"><pre><span></span><code><span class="o">...</span>
<span class="c1"># 使用列表理解创建列表</span>
<span class="n">result</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span><span class="o">*</span><span class="mi">2</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">100</span><span class="p">)]</span>
</code></pre></div>
<p>还支持创建字典和集合的推导式。</p>
<p>例如:</p>
<div class="highlight"><pre><span></span><code><span class="o">...</span>
<span class="c1"># 使用理解创建一个字典</span>
<span class="n">result</span> <span class="o">=</span> <span class="p">{</span><span class="n">a</span><span class="p">:</span><span class="n">i</span> <span class="k">for</span> <span class="n">a</span><span class="p">,</span><span class="n">i</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">([</span><span class="s1">&#39;a&#39;</span><span class="p">,</span><span class="s1">&#39;b&#39;</span><span class="p">,</span><span class="s1">&#39;c&#39;</span><span class="p">],</span><span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">))}</span>
<span class="c1"># 使用推导式创建一个集合</span>
<span class="n">result</span> <span class="o">=</span> <span class="p">{</span><span class="n">a</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">]}</span>
</code></pre></div>
</div>
</div>
</div>
<h3 id="183-异步推导式">18.3 异步推导式<a class="headerlink" href="#183-异步推导式" title="Permanent link">&para;</a></h3>
<p><strong>18.3 Asynchronous Comprehensions</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="104:2"><input checked="checked" id="__tabbed_104_1" name="__tabbed_104" type="radio" /><input id="__tabbed_104_2" name="__tabbed_104" type="radio" /><div class="tabbed-labels"><label for="__tabbed_104_1">English</label><label for="__tabbed_104_2">Chinese</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<p>An asynchronous comprehension allows a list, set, or dict to be created using the “async for” expression with an asynchronous iterable.</p>
<blockquote>
<p>We propose to allow using async for inside list, set and dict comprehensions.</p>
<p>— PEP 530 – ASYNCHRONOUS COMPREHENSIONS</p>
</blockquote>
<p>For example:</p>
<div class="highlight"><pre><span></span><code><span class="o">...</span>
<span class="c1"># async list comprehension with an async iterator</span>
<span class="n">result</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span> <span class="k">async</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">aiterable</span><span class="p">]</span>
</code></pre></div>
<p>This will create and schedule coroutines or tasks as needed and yield their results into a list.</p>
<p>Recall that the “<a href="https://superfastpython.com/asyncio-async-for/">async for</a>” expression may only be used within coroutines and tasks.</p>
<p>Also, recall that an asynchronous iterator is an iterator that yields awaitables.</p>
<p>The “<strong>async for</strong>” expression allows the caller to traverse an asynchronous iterator of awaitables and retrieve the result from each.</p>
<p>Internally, the async for loop will automatically resolve or await each awaitable, scheduling coroutines as needed.</p>
<p>An async generator automatically implements the methods for the async iterator and may also be used in an asynchronous comprehension.</p>
<p>For example:</p>
<div class="highlight"><pre><span></span><code><span class="o">...</span>
<span class="c1"># async list comprehension with an async generator</span>
<span class="n">result</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span> <span class="k">async</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">agenerator</span><span class="p">]</span>
</code></pre></div>
</div>
<div class="tabbed-block">
<p>异步理解允许使用带有异步迭代的“<strong>async for</strong>”表达式来创建列表、集合或字典。</p>
<blockquote>
<p>我们建议允许对内部列表、集合和字典理解使用异步。</p>
<p>— PEP 530 – ASYNCHRONOUS COMPREHENSIONS</p>
</blockquote>
<p>例如:</p>
<div class="highlight"><pre><span></span><code><span class="o">...</span>
<span class="c1"># 使用异步迭代器的异步列表理解</span>
<span class="n">result</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span> <span class="k">async</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">aiterable</span><span class="p">]</span>
</code></pre></div>
<p>这将根据需要创建和调度协程或任务，并将其结果生成到列表中。</p>
<p>回想一下，“<a href="https://superfastpython.com/asyncio-async-for/">async for</a>”表达式只能在协程和任务中使用。</p>
<p>另外，请记住，异步迭代器是产生可等待项的迭代器。</p>
<p>“<strong>async for</strong>”表达式允许调用者遍历可等待项的异步迭代器并从每个迭代器中检索结果。</p>
<p>在内部，async for 循环将自动解析或等待每个可等待的、根据需要调度协程。</p>
<p>异步生成器自动实现异步迭代器的方法，也可以在异步推导式中使用。</p>
<p>例如:</p>
<div class="highlight"><pre><span></span><code><span class="o">...</span>
<span class="c1"># 使用异步生成器的异步列表推导式</span>
<span class="n">result</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span> <span class="k">async</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">agenerator</span><span class="p">]</span>
</code></pre></div>
</div>
</div>
</div>
<h3 id="184-await-推导式">18.4 Await 推导式<a class="headerlink" href="#184-await-推导式" title="Permanent link">&para;</a></h3>
<p><strong>18.4 Await Comprehensions</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="105:2"><input checked="checked" id="__tabbed_105_1" name="__tabbed_105" type="radio" /><input id="__tabbed_105_2" name="__tabbed_105" type="radio" /><div class="tabbed-labels"><label for="__tabbed_105_1">English</label><label for="__tabbed_105_2">Chinese</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<p>The <strong>“await”</strong> expression may also be used within a list, set, or dict comprehension, referred to as an await comprehension.</p>
<blockquote>
<p>We propose to allow the use of await expressions in both asynchronous and synchronous comprehensions</p>
<p>— <a href="https://peps.python.org/pep-0530/">PEP 530 – ASYNCHRONOUS COMPREHENSIONS</a></p>
</blockquote>
<p>Like an async comprehension, it may only be used within an asyncio coroutine or task.</p>
<p>This allows a data structure, like a list, to be created by suspending and awaiting a series of awaitables.</p>
<p>For example:</p>
<div class="highlight"><pre><span></span><code><span class="o">...</span>
<span class="c1"># await list compression with a collection of awaitables</span>
<span class="n">results</span> <span class="o">=</span> <span class="p">[</span><span class="k">await</span> <span class="n">a</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">awaitables</span><span class="p">]</span>
</code></pre></div>
<p>This will create a list of results by awaiting each awaitable in turn.</p>
<p>The current coroutine will be suspended to execute awaitables sequentially, which is different and perhaps slower than executing them concurrently using <strong>asyncio.gather()</strong>.</p>
<p>You can learn more about async comprehensions in the tutorial:</p>
<ul>
<li><a href="https://superfastpython.com/asynchronous-comprehensions/">Asynchronous Comprehensions in Python</a></li>
</ul>
<p>Next, we will explore how to run commands using subprocesses from asyncio.</p>
</div>
<div class="tabbed-block">
<p><strong>“await”</strong> 表达式也可以在列表、集合或字典理解中使用，称为<strong>await 推导</strong>。</p>
<blockquote>
<p>我们建议在异步和同步中都使用<strong>await推导</strong>或<strong>列表推导</strong></p>
<p>— <a href="https://peps.python.org/pep-0530/">PEP 530 – ASYNCHRONOUS COMPREHENSIONS</a></p>
</blockquote>
<p>与异步理解一样，它只能在异步协程或任务中使用。</p>
<p>这允许通过挂起和等待一系列可等待项来创建数据结构，例如列表。</p>
<p>例如:</p>
<div class="highlight"><pre><span></span><code><span class="o">...</span>
<span class="c1"># 在可等待对象合集中使用await列表推导</span>
<span class="n">results</span> <span class="o">=</span> <span class="p">[</span><span class="k">await</span> <span class="n">a</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">awaitables</span><span class="p">]</span>
</code></pre></div>
<p>这将通过依次等待每个可等待项来创建结果列表。</p>
<p>当前协程将被挂起以顺序执行可等待项，这与使用 <strong>asyncio.gather()</strong> 并发执行它们不同，并且可能更慢。</p>
<p>您可以在教程中了解有关异步推导的更多信息：</p>
<ul>
<li><a href="https://superfastpython.com/asynchronous-comprehensions/">Python 中的异步推导式</a></li>
</ul>
<p>接下来，我们将探索如何使用 asyncio 中的子进程来运行命令。</p>
</div>
</div>
</div>
<h2 id="19-在非阻塞子进程中运行命令">19. 在非阻塞子进程中运行命令<a class="headerlink" href="#19-在非阻塞子进程中运行命令" title="Permanent link">&para;</a></h2>
<p><strong>19. Run Commands in Non-Blocking Subprocesses</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="106:2"><input checked="checked" id="__tabbed_106_1" name="__tabbed_106" type="radio" /><input id="__tabbed_106_2" name="__tabbed_106" type="radio" /><div class="tabbed-labels"><label for="__tabbed_106_1">English</label><label for="__tabbed_106_2">Chinese</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<p>We can execute commands from asyncio.</p>
<p>The command will run in a subprocess that we can write to and read from using non-blocking I/O.</p>
<p>Let’s take a closer look.</p>
</div>
<div class="tabbed-block">
<p>We can execute commands from asyncio.</p>
<p>The command will run in a subprocess that we can write to and read from using non-blocking I/O.</p>
<p>Let’s take a closer look.</p>
</div>
</div>
</div>
<h3 id="191-什么是-asynciosubprocessprocess">19.1 什么是 asyncio.subprocess.Process<a class="headerlink" href="#191-什么是-asynciosubprocessprocess" title="Permanent link">&para;</a></h3>
<p><strong>19.1 What is asyncio.subprocess.Process</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="107:2"><input checked="checked" id="__tabbed_107_1" name="__tabbed_107" type="radio" /><input id="__tabbed_107_2" name="__tabbed_107" type="radio" /><div class="tabbed-labels"><label for="__tabbed_107_1">English</label><label for="__tabbed_107_2">Chinese</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<p>The <a href="https://docs.python.org/3/library/asyncio-subprocess.html#asyncio.subprocess.Process">asyncio.subprocess.Process</a> class provides a representation of a subprocess run by asyncio.</p>
<p>It provides a handle on a subprocess in asyncio programs, allowing actions to be performed on it, such as waiting and terminating it.</p>
<blockquote>
<p>Process is a high-level wrapper that allows communicating with subprocesses and watching for their completion.</p>
<p>— <a href="https://docs.python.org/3/library/asyncio-subprocess.html#interacting-with-subprocesses">INTERACTING WITH SUBPROCESSES</a></p>
</blockquote>
<p>The API is very similar to the <a href="https://docs.python.org/3/library/subprocess.html#subprocess.Popen">multiprocessing.Process</a> class and perhaps more so with the <a href="https://docs.python.org/3/library/subprocess.html#subprocess.Popen">subprocess.Popen</a> class.</p>
<p>Specifically, it shares methods such as <strong>wait()</strong>, <strong>communicate()</strong>, and <strong>send_signal()</strong> and attributes such as stdin, stdout, and stderr with the subprocess.Popen.</p>
<p>Now that we know what the <strong>asyncio.subprocess.Process</strong> class is, let’s look at how we might use it in our asyncio programs.</p>
<p>We do not create a <strong>asyncio.subprocess.Process</strong> directly.</p>
<p>Instead, an instance of the class is created for us when executing a subprocess in an asyncio program.</p>
<blockquote>
<p>An object that wraps OS processes created by the create_subprocess_exec() and create_subprocess_shell() functions.</p>
<p>— <a href="https://docs.python.org/3/library/asyncio-subprocess.html#interacting-with-subprocesses">INTERACTING WITH SUBPROCESSES</a></p>
</blockquote>
<p>There are two ways to execute an external program as a subprocess and acquire a Process instance, they are:</p>
<ul>
<li>asyncio.create_subprocess_exec() for running commands directly.</li>
<li>asyncio.create_subprocess_shell() for running commands via the shell.</li>
</ul>
<p>Let’s look at examples of each in turn.</p>
</div>
<div class="tabbed-block">
<p>asyncio通过<a href="https://docs.python.org/3/library/asyncio-subprocess.html#asyncio.subprocess.Process">asyncio.subprocess.Process</a> 类提供了对于运行子进程的支持和表示。</p>
<p>它提供了 asyncio 程序中子进程的句柄，允许对其执行操作，例如等待和终止它。</p>
<blockquote>
<p>Process是一个高级包装过后的类，允许与子进程通信并监视其完成情况。</p>
<p>— <a href="https://docs.python.org/3/library/asyncio-subprocess.html#interacting-with-subprocesses">INTERACTING WITH SUBPROCESSES</a></p>
</blockquote>
<p>该 API 与 <a href="https://docs.python.org/3/library/subprocess.html#subprocess.Popen">multiprocessing.Process</a> 类非常相似，也许与 <a href="https://docs.python.org/3/library/subprocess.html#subprocess.Popen">subprocess.Popen</a> 类更新相似。</p>
<p>具体来说，它与 <strong>subprocess.Popen</strong> 共享 <strong>wait()</strong>、<strong>communicate()</strong> 和 <strong>send_signal()</strong> 等方法以及 <code>stdin</code>、<code>stdout</code> 和 <code>stderr</code> 等属性。</p>
<p>现在我们知道了 <strong>asyncio.subprocess.Process</strong> 类是什么，让我们看看如何在 asyncio 程序中使用它。</p>
<p>我们不直接创建 <strong>asyncio.subprocess.Process</strong>。</p>
<p>相反，当在 asyncio 程序中执行子进程时，会为我们创建该类的实例。</p>
<blockquote>
<p>包装由 <strong>create_subprocess_exec()</strong> 和 <strong>create_subprocess_shell()</strong> 函数创建的操作系统进程的对象。</p>
<p>— <a href="https://docs.python.org/3/library/asyncio-subprocess.html#interacting-with-subprocesses">INTERACTING WITH SUBPROCESSES</a></p>
</blockquote>
<p>有两种方法可以将外部程序作为子进程执行并获取 Process 实例，它们是：</p>
<ul>
<li><strong>asyncio.create_subprocess_exec()</strong> 用于直接运行命令。</li>
<li><strong>asyncio.create_subprocess_shell()</strong> 用于通过 shell 运行命令。</li>
</ul>
<p>让我们依次看一下每个例子。</p>
</div>
</div>
</div>
<h3 id="192-如何直接运行命令">19.2 如何直接运行命令<a class="headerlink" href="#192-如何直接运行命令" title="Permanent link">&para;</a></h3>
<p><strong>19.2 How to Run a Command Directly</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="108:2"><input checked="checked" id="__tabbed_108_1" name="__tabbed_108" type="radio" /><input id="__tabbed_108_2" name="__tabbed_108" type="radio" /><div class="tabbed-labels"><label for="__tabbed_108_1">English</label><label for="__tabbed_108_2">Chinese</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<p>A <a href="https://en.wikipedia.org/wiki/Command-line_interface">command</a> is a program executed on the command line (terminal or command prompt). It is another program that is run directly.</p>
<p>Common examples on Linux and macOS might be:</p>
<ul>
<li>‘ls‘ to list the contents of a directory</li>
<li>‘cat‘ to report the content of a file</li>
<li>‘date‘ to report the date</li>
<li>‘echo‘ to report back a string</li>
<li>‘sleep‘ to sleep for a number of seconds</li>
</ul>
<p>And so on.</p>
<p>We can execute a command from an asyncio program via the <strong>create_subprocess_exec()</strong> function.</p>
<p>The <strong>asyncio.create_subprocess_exec()</strong> function takes a command and executes it directly.</p>
<p>This is helpful as it allows the command to be executed in a subprocess and for asyncio coroutines to read, write, and wait for it.</p>
<blockquote>
<p>Because all asyncio subprocess functions are asynchronous and asyncio provides many tools to work with such functions, it is easy to execute and monitor multiple subprocesses in parallel.</p>
<p>— ASYNCIO SUBPROCESSES</p>
</blockquote>
<p>Unlike the <strong>asyncio.create_subprocess_shell()</strong> function, the <strong>asyncio.create_subprocess_exec()</strong> will not execute the command using the shell.</p>
<p>This means that the capabilities provided by the shell, such as shell variables, scripting, and wildcards are not available when executing the command.</p>
<p>It also means that executing the command may be more secure as there is no opportunity for a <a href="https://en.wikipedia.org/wiki/Code_injection#Shell_injection">shell injection</a>.</p>
<p>Now that we know what <strong>asyncio.create_subprocess_exec()</strong> does, let’s look at how to use it.</p>
</div>
<div class="tabbed-block">
<p><a href="https://en.wikipedia.org/wiki/Command-line_interface">command</a> 是在命令行（终端或命令提示符）上执行的程序。 这是另一个直接运行的程序。</p>
<p>Linux 和 macOS 上的常见示例可能是：</p>
<ul>
<li>‘ls‘ 列出目录的内容</li>
<li>‘cat‘ 报告文件的内容</li>
<li>‘date‘ 报告日期</li>
<li>‘echo‘ 报告一个字符串</li>
<li>‘sleep‘ 睡眠几秒钟</li>
</ul>
<p>等等。</p>
<p>我们可以通过 <strong>create_subprocess_exec()</strong> 函数从 asyncio 程序执行命令。</p>
<p><strong>asyncio.create_subprocess_exec()</strong> 函数接受一个命令并直接执行它。</p>
<p>这很有用，因为它允许在子进程中执行命令，并允许异步协程读取、写入和等待它。</p>
<blockquote>
<p>因为所有 asyncio 子进程函数都是异步的，并且 asyncio 提供了许多工具来使用这些函数，所以很容易并行执行和监视多个子进程。</p>
<p>— <a href="https://docs.python.org/3/library/asyncio-subprocess.html">ASYNCIO SUBPROCESSES</a></p>
</blockquote>
<p>与 <strong>asyncio.create_subprocess_shell()</strong> 函数不同，<strong>asyncio.create_subprocess_exec()</strong> 不会使用 shell 执行命令。</p>
<p>这意味着 shell 提供的功能（例如 shell 变量、脚本和通配符）在执行命令时不可用。</p>
<p>这也意味着执行命令可能更安全，因为没有机会进行<a href="https://en.wikipedia.org/wiki/Code_injection#Shell_injection">shell注入</a>。</p>
<p>现在我们知道了 <strong>asyncio.create_subprocess_exec()</strong> 的作用，让我们看看如何使用它。</p>
</div>
</div>
</div>
<h4 id="1921-如何使用-asyncio-的-create_subprocess_exec">19.2.1 如何使用 Asyncio 的 create_subprocess_exec()<a class="headerlink" href="#1921-如何使用-asyncio-的-create_subprocess_exec" title="Permanent link">&para;</a></h4>
<p><strong>19.2.1 How to Use Asyncio create_subprocess_exec()</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="109:2"><input checked="checked" id="__tabbed_109_1" name="__tabbed_109" type="radio" /><input id="__tabbed_109_2" name="__tabbed_109" type="radio" /><div class="tabbed-labels"><label for="__tabbed_109_1">English</label><label for="__tabbed_109_2">Chinese</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<p>The <a href="https://docs.python.org/3/library/asyncio-subprocess.html#asyncio.create_subprocess_exec">asyncio.create_subprocess_exec()</a> function will execute a given string command in a subprocess.</p>
<p>It returns a <a href="https://docs.python.org/3/library/asyncio-subprocess.html#asyncio.subprocess.Process">asyncio.subprocess.Process</a> object that represents the subprocess.</p>
<blockquote>
<p>Process is a high-level wrapper that allows communicating with subprocesses and watching for their completion.</p>
<p>— <a href="https://docs.python.org/3/library/asyncio-subprocess.html#asyncio.subprocess.Process">INTERACTING WITH SUBPROCESSES</a></p>
</blockquote>
<p>The create_subprocess_exec() function is a coroutine, which means we must await it. It will return once the subprocess has been started, not when the subprocess is finished.</p>
<p>For example:</p>
<div class="highlight"><pre><span></span><code><span class="o">...</span>
<span class="c1"># execute a command in a subprocess</span>
<span class="n">process</span> <span class="o">=</span> <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">create_subprocess_exec</span><span class="p">(</span><span class="s1">&#39;ls&#39;</span><span class="p">)</span>
</code></pre></div>
<p>Arguments to the command being executed must be provided as subsequent arguments to the <strong>create_subprocess_exec()</strong> function.</p>
<p>For example:</p>
<div class="highlight"><pre><span></span><code><span class="o">...</span>
<span class="c1"># execute a command with arguments in a subprocess</span>
<span class="n">process</span> <span class="o">=</span> <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">create_subprocess_exec</span><span class="p">(</span><span class="s1">&#39;ls&#39;</span><span class="p">,</span> <span class="s1">&#39;-l&#39;</span><span class="p">)</span>
</code></pre></div>
<p>We can wait for the subprocess to finish by awaiting the <strong>wait()</strong> method.</p>
<p>For example:</p>
<div class="highlight"><pre><span></span><code><span class="o">...</span>
<span class="c1"># wait for the subprocess to terminate</span>
<span class="k">await</span> <span class="n">process</span><span class="o">.</span><span class="n">wait</span><span class="p">()</span>
</code></pre></div>
<p>We can stop the subprocess directly by calling the <strong>terminate()</strong> or <strong>kill()</strong> methods, which will raise a signal in the subprocess.</p>
<p>For example:</p>
<div class="highlight"><pre><span></span><code><span class="o">...</span>
<span class="c1"># terminate the subprocess</span>
<span class="n">process</span><span class="o">.</span><span class="n">terminate</span><span class="p">()</span>
</code></pre></div>
<p>The input and output of the command will be handled by <strong>stdin</strong>, <strong>stderr</strong>, and <strong>stdout</strong>.</p>
<p>We can have the asyncio program handle the input or output for the subprocess.</p>
<p>This can be achieved by specifying the input or output stream and specifying a constant to redirect, such as <strong>asyncio.subprocess.PIPE</strong>.</p>
<p>For example, we can redirect the output of a command to the asyncio program:</p>
<div class="highlight"><pre><span></span><code><span class="o">...</span>
<span class="c1"># start a subprocess and redirect output</span>
<span class="n">process</span> <span class="o">=</span> <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">create_subprocess_exec</span><span class="p">(</span><span class="s1">&#39;ls&#39;</span><span class="p">,</span> <span class="n">stdout</span><span class="o">=</span><span class="n">asyncio</span><span class="o">.</span><span class="n">subprocess</span><span class="o">.</span><span class="n">PIPE</span><span class="p">)</span>
</code></pre></div>
<p>We can then read the output of the program via the <strong>asyncio.subprocess.Process</strong> instance via the <strong>communicate()</strong> method.</p>
<p>This method is a coroutine and must be awaited. It is used to both send and receive data with the subprocess.</p>
<p>For example:</p>
<div class="highlight"><pre><span></span><code><span class="o">...</span>
<span class="c1"># read data from the subprocess</span>
<span class="n">line</span> <span class="o">=</span> <span class="n">process</span><span class="o">.</span><span class="n">communicate</span><span class="p">()</span>
</code></pre></div>
<p>We can also send data to the subprocess via the <strong>communicate()</strong> method by setting the <strong>“input”</strong> argument in bytes.</p>
<p>For example:</p>
<div class="highlight"><pre><span></span><code><span class="o">...</span>
<span class="c1"># start a subprocess and redirect input</span>
<span class="n">process</span> <span class="o">=</span> <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">create_subprocess_exec</span><span class="p">(</span><span class="s1">&#39;ls&#39;</span><span class="p">,</span> <span class="n">stdin</span><span class="o">=</span><span class="n">asyncio</span><span class="o">.</span><span class="n">subprocess</span><span class="o">.</span><span class="n">PIPE</span><span class="p">)</span>
<span class="c1"># send data to the subprocess</span>
<span class="n">process</span><span class="o">.</span><span class="n">communicate</span><span class="p">(</span><span class="nb">input</span><span class="o">=</span><span class="sa">b</span><span class="s1">&#39;Hello</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
</code></pre></div>
<p>Behind the scenes the <strong>asyncio.subprocess.PIPE</strong> configures the subprocess to point to a <strong>StreamReader</strong> or <strong>StreamWriter</strong> for sending data to or from the subprocess, and the <strong>communicate()</strong> method will read or write bytes from the configured reader.</p>
<blockquote>
<p>If PIPE is passed to stdin argument, the Process.stdin attribute will point to a StreamWriter instance. If PIPE is passed to stdout or stderr arguments, the Process.stdout and Process.stderr attributes will point to StreamReader instances.</p>
<p>— <a href="https://docs.python.org/3/library/asyncio-subprocess.html">ASYNCIO SUBPROCESSES</a></p>
</blockquote>
<p>We can interact with the <strong>StreamReader</strong> or <strong>StreamWriter</strong> directly via the subprocess via the stdin, stdout, and stderr attributes.</p>
<p>For example:</p>
<div class="highlight"><pre><span></span><code><span class="o">...</span>
<span class="c1"># read a line from the subprocess output stream</span>
<span class="n">line</span> <span class="o">=</span> <span class="k">await</span> <span class="n">process</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>
</code></pre></div>
<p>Now that we know how to use the <strong>create_subprocess_exec()</strong> function, let’s look at some worked examples.</p>
</div>
<div class="tabbed-block">
<p><a href="https://docs.python.org/3/library/asyncio-subprocess.html#asyncio.create_subprocess_exec">asyncio.create_subprocess_exec()</a> 函数将在子进程中执行给定的字符串命令。</p>
<p>它返回一个表示子进程的 <a href="https://docs.python.org/3/library/asyncio-subprocess.html#asyncio.subprocess.Process">asyncio.subprocess.Process</a> 对象。</p>
<blockquote>
<p>Process是一个高级包装器，允许与子进程通信并监视其完成情况。</p>
<p>— <a href="https://docs.python.org/3/library/asyncio-subprocess.html#asyncio.subprocess.Process">INTERACTING WITH SUBPROCESSES</a></p>
</blockquote>
<p>create_subprocess_exec() 函数是一个协程，这意味着我们必须等待它。 它会在子进程启动后返回，而不是在子进程完成时返回。</p>
<p>例如:</p>
<div class="highlight"><pre><span></span><code><span class="o">...</span>
<span class="c1"># 在子进程中执行命令</span>
<span class="n">process</span> <span class="o">=</span> <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">create_subprocess_exec</span><span class="p">(</span><span class="s1">&#39;ls&#39;</span><span class="p">)</span>
</code></pre></div>
<p>正在执行的命令的参数必须作为 <strong>create_subprocess_exec()</strong> 函数的后续参数提供。</p>
<p>例如:</p>
<div class="highlight"><pre><span></span><code><span class="o">...</span>
<span class="c1"># 在子进程中执行带参数的命令</span>
<span class="n">process</span> <span class="o">=</span> <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">create_subprocess_exec</span><span class="p">(</span><span class="s1">&#39;ls&#39;</span><span class="p">,</span> <span class="s1">&#39;-l&#39;</span><span class="p">)</span>
</code></pre></div>
<p>我们可以通过等待 <strong>wait()</strong> 方法来等待子进程完成。</p>
<p>例如:</p>
<div class="highlight"><pre><span></span><code><span class="o">...</span>
<span class="c1"># 等待子进程终止</span>
<span class="k">await</span> <span class="n">process</span><span class="o">.</span><span class="n">wait</span><span class="p">()</span>
</code></pre></div>
<p>我们可以通过调用 <strong>terminate()</strong> 或 <strong>kill()</strong> 方法直接停止子进程，这将在子进程中引发一个信号。</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code><span class="o">...</span>
<span class="c1"># 终止子进程</span>
<span class="n">process</span><span class="o">.</span><span class="n">terminate</span><span class="p">()</span>
</code></pre></div>
<p>命令的输入和输出将由 <strong>stdin</strong>、<strong>stderr</strong> 和 <strong>stdout</strong> 处理。</p>
<p>我们可以让 asyncio 程序处理子进程的输入或输出。</p>
<p>这可以通过指定输入或输出流并指定要重定向的常量来实现，例如 <strong>asyncio.subprocess.PIPE</strong>。</p>
<p>例如，我们可以将命令的输出重定向到 asyncio 程序：</p>
<div class="highlight"><pre><span></span><code><span class="o">...</span>
<span class="c1"># 启动子进程并重定向输出</span>
<span class="n">process</span> <span class="o">=</span> <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">create_subprocess_exec</span><span class="p">(</span><span class="s1">&#39;ls&#39;</span><span class="p">,</span> <span class="n">stdout</span><span class="o">=</span><span class="n">asyncio</span><span class="o">.</span><span class="n">subprocess</span><span class="o">.</span><span class="n">PIPE</span><span class="p">)</span>
</code></pre></div>
<p>然后我们可以通过<strong>asyncio.subprocess.Process</strong>实例通过<strong>communicate()</strong>方法读取程序的输出。</p>
<p>该方法是一个协程，必须等待。 它用于通过子进程发送和接收数据。</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code><span class="o">...</span>
<span class="c1"># 从子进程读取数据</span>
<span class="n">line</span> <span class="o">=</span> <span class="n">process</span><span class="o">.</span><span class="n">communicate</span><span class="p">()</span>
</code></pre></div>
<p>我们还可以通过 <strong>communicate()</strong> 方法通过设置 <strong>“input”</strong> 参数（以字节为单位）将数据发送到子进程。</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code><span class="o">...</span>
<span class="c1"># 启动子进程并重定向输入</span>
<span class="n">process</span> <span class="o">=</span> <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">create_subprocess_exec</span><span class="p">(</span><span class="s1">&#39;ls&#39;</span><span class="p">,</span> <span class="n">stdin</span><span class="o">=</span><span class="n">asyncio</span><span class="o">.</span><span class="n">subprocess</span><span class="o">.</span><span class="n">PIPE</span><span class="p">)</span>
<span class="c1"># 向子进程发送数据</span>
<span class="n">process</span><span class="o">.</span><span class="n">communicate</span><span class="p">(</span><span class="nb">input</span><span class="o">=</span><span class="sa">b</span><span class="s1">&#39;Hello</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
</code></pre></div>
<p>在背后， <strong>asyncio.subprocess.PIPE</strong> 将子进程配置为指向 <strong>StreamReader</strong> 或 <strong>StreamWriter</strong> 用于向子进程发送数据或从子进程发送数据，以及 <strong>communicate()</strong> 方法 将从配置的读取器读取或写入字节。</p>
<blockquote>
<p>如果 PIPE 传递给 stdin 参数，则 Process.stdin 属性将指向 <strong>StreamWriter</strong> 实例。 如果 PIPE 传递给 <strong>stdout</strong> 或 <strong>stderr</strong> 参数，则 <strong>Process.stdout</strong> 和 <strong>Process.stderr</strong> 属性将指向 <strong>StreamReader</strong> 实例。</p>
<p>— <a href="https://docs.python.org/3/library/asyncio-subprocess.html">ASYNCIO SUBPROCESSES</a></p>
</blockquote>
<p>我们可以通过子进程通过 <code>stdin</code>、<code>stdout</code> 和 <code>stderr</code> 属性直接与 <strong>StreamReader</strong> 或 <strong>StreamWriter</strong> 交互。</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code><span class="o">...</span>
<span class="c1"># 从子进程输出流中读取一行</span>
<span class="n">line</span> <span class="o">=</span> <span class="k">await</span> <span class="n">process</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>
</code></pre></div>
<p>现在我们知道如何使用 <strong>create_subprocess_exec()</strong> 函数，让我们看一些有效的示例。</p>
</div>
</div>
</div>
<h4 id="1922-asyncio-的-create_subprocess_exec-的示例">19.2.2 Asyncio 的 create_subprocess_exec() 的示例<a class="headerlink" href="#1922-asyncio-的-create_subprocess_exec-的示例" title="Permanent link">&para;</a></h4>
<p><strong>19.2.2 Example of Asyncio create_subprocess_exec()</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="110:2"><input checked="checked" id="__tabbed_110_1" name="__tabbed_110" type="radio" /><input id="__tabbed_110_2" name="__tabbed_110" type="radio" /><div class="tabbed-labels"><label for="__tabbed_110_1">English</label><label for="__tabbed_110_2">Chinese</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<p>We can explore how to run a command in a subprocess from asyncio.</p>
<p>In this example, we will execute the <a href="https://en.wikipedia.org/wiki/Echo_(command)">“echo”</a> command to report back a string.</p>
<p>The echo command will report the provided string on standard output directly.</p>
<p>The complete example is listed below.</p>
<p><strong>Note</strong>, this example assumes you have access to the <strong>“echo”</strong> command, I’m not sure it will work on Windows.</p>
<div class="highlight"><pre><span></span><code><span class="c1"># SuperFastPython.com</span>
<span class="c1"># example of executing a command as a subprocess with asyncio</span>
<span class="kn">import</span> <span class="nn">asyncio</span>

<span class="c1"># main coroutine</span>
<span class="k">async</span> <span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="c1"># start executing a command in a subprocess</span>
    <span class="n">process</span> <span class="o">=</span> <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">create_subprocess_exec</span><span class="p">(</span><span class="s1">&#39;echo&#39;</span><span class="p">,</span> <span class="s1">&#39;Hello World&#39;</span><span class="p">)</span>
    <span class="c1"># report the details of the subprocess</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;subprocess: </span><span class="si">{</span><span class="n">process</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

<span class="c1"># entry point</span>
<span class="n">asyncio</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">main</span><span class="p">())</span>
</code></pre></div>
<p>Running the example first creates the <strong>main()</strong> coroutine and executes it as the entry point into the asyncio program.</p>
<p>The <strong>main()</strong> coroutine runs and calls the create_subprocess_exec() function to execute a command.</p>
<p>The <strong>main()</strong> coroutine suspends while the subprocess is created. A Process instance is returned.</p>
<p>The <strong>main()</strong> coroutine resumes and reports the details of the subprocess. The <strong>main()</strong> process terminates and the asyncio program terminates.</p>
<p>The output of the echo command is reported on the command line.</p>
<p>This highlights how we can execute a command from an asyncio program.</p>
<div class="highlight"><pre><span></span><code>Hello World
subprocess: &lt;Process 50249&gt;
</code></pre></div>
</div>
<div class="tabbed-block">
<p>我们可以探索如何在 asyncio 的子进程中运行命令。</p>
<p>在此示例中，我们将执行 <a href="https://en.wikipedia.org/wiki/Echo_(command)">“echo”</a> 命令来报告一个字符串。</p>
<p>echo 命令将直接在标准输出上报告提供的字符串。</p>
<p>下面列出了完整的示例。</p>
<p><strong>注意</strong>，此示例假设您有权访问 <strong>“echo”</strong> 命令，我不确定它是否适用于 Windows。</p>
<div class="highlight"><pre><span></span><code><span class="c1"># SuperFastPython.com</span>
<span class="c1"># 使用 asyncio 作为子进程执行命令的示例</span>
<span class="kn">import</span> <span class="nn">asyncio</span>

<span class="c1"># 主协程</span>
<span class="k">async</span> <span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="c1"># 开始在子进程中执行命令</span>
    <span class="n">process</span> <span class="o">=</span> <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">create_subprocess_exec</span><span class="p">(</span><span class="s1">&#39;echo&#39;</span><span class="p">,</span> <span class="s1">&#39;Hello World&#39;</span><span class="p">)</span>
    <span class="c1"># 报告子流程的详细信息</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;subprocess: </span><span class="si">{</span><span class="n">process</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

<span class="c1"># 入口点</span>
<span class="n">asyncio</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">main</span><span class="p">())</span>
</code></pre></div>
<p>运行该示例首先创建 <strong>main()</strong> 协程，并将其作为 asyncio 程序的入口点执行。</p>
<p><strong>main()</strong> 协程运行并调用 create_subprocess_exec() 函数来执行命令。</p>
<p>创建子进程时，<strong>main()</strong> 协程会挂起。 返回一个 Process 实例。</p>
<p><strong>main()</strong> 协程恢复并报告子进程的详细信息。 <strong>main()</strong> 进程终止，并且 asyncio 程序终止。</p>
<p>echo 命令的输出在命令行上报告。</p>
<p>这突出显示了我们如何从 asyncio 程序执行命令。</p>
<div class="highlight"><pre><span></span><code>Hello World
subprocess: &lt;Process 50249&gt;
</code></pre></div>
</div>
</div>
</div>
<h3 id="193-如何跟shell一起运行一个命令">19.3 如何跟shell一起运行一个命令<a class="headerlink" href="#193-如何跟shell一起运行一个命令" title="Permanent link">&para;</a></h3>
<p><strong>How to Run a Command Via the Shell</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="111:2"><input checked="checked" id="__tabbed_111_1" name="__tabbed_111" type="radio" /><input id="__tabbed_111_2" name="__tabbed_111" type="radio" /><div class="tabbed-labels"><label for="__tabbed_111_1">English</label><label for="__tabbed_111_2">Chinese</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<p>We can execute commands using the <a href="https://en.wikipedia.org/wiki/Shell_(computing)">shell</a>.</p>
<p>The shell is a user interface for the command line, called a command line interpreter (CLI).</p>
<p>It will interpret and execute commands on behalf of the user.</p>
<p>It also offers features such as a primitive programming language for scripting, wildcards, piping, shell variables (e.g. PATH), and more.</p>
<p>For example, we can redirect the output of one command as input to another command, such as the contents of the “<strong>/etc/services</strong>” file into the word count “wc” command and count the number of lines:</p>
<div class="highlight"><pre><span></span><code><span class="n">cat</span> <span class="o">/</span><span class="n">etc</span><span class="o">/</span><span class="n">services</span> <span class="o">|</span> <span class="n">wc</span> <span class="o">-</span><span class="n">l</span>
</code></pre></div>
<p>Examples of shells in the Unix based operating systems include:</p>
<ul>
<li>‘sh’</li>
<li>‘bash’</li>
<li>‘zsh’</li>
<li>And so on.</li>
</ul>
<p>On Windows, the shell is probably <a href="https://en.wikipedia.org/wiki/Cmd.exe">cmd.exe</a>.</p>
<p>See this great list of command line shells:</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/List_of_command-line_interpreters">List of command-line interpreters</a>, Wikipedia</li>
</ul>
<p>The shell is already running, it was used to start the Python program.</p>
<p>You don’t need to do anything special to get or have access to the shell.</p>
<p>We can execute a command from an asyncio program via the <strong>create_subprocess_shell()</strong> function.</p>
<p>The <strong>asyncio.create_subprocess_shell()</strong> function takes a command and executes it using the current user shell.</p>
<p>This is helpful as it not only allows the command to be executed, but allows the capabilities of the shell to be used, such as redirection, wildcards and more.</p>
<blockquote>
<p>… the specified command will be executed through the shell. This can be useful if you are using Python primarily for the enhanced control flow it offers over most system shells and still want convenient access to other shell features such as shell pipes, filename wildcards, environment variable expansion, and expansion of ~ to a user’s home directory.</p>
<p>— <a href="https://docs.python.org/3/library/subprocess.html">SUBPROCESS — SUBPROCESS MANAGEMENT</a></p>
</blockquote>
<p>The command will be executed in a subprocess of the process executing the asyncio program.</p>
<p>Importantly, the asyncio program is able to interact with the subprocess asynchronously, e.g. via coroutines.</p>
<blockquote>
<p>Because all asyncio subprocess functions are asynchronous and asyncio provides many tools to work with such functions, it is easy to execute and monitor multiple subprocesses in parallel.</p>
<p>— ASYNCIO SUBPROCESSES</p>
</blockquote>
<p>There can be security considerations when executing a command via the shell instead of directly.</p>
<p>This is because there is at least one level of indirection and interpretation between the request to execute the command and the command being executed, allowing possible malicious injection.</p>
<blockquote>
<p>Important It is the application’s responsibility to ensure that all whitespace and special characters are quoted appropriately to avoid shell injection vulnerabilities.</p>
<p>— ASYNCIO SUBPROCESSES</p>
</blockquote>
<p>Now that we know what <strong>asyncio.create_subprocess_shell()</strong> does, let’s look at how to use it.</p>
</div>
<div class="tabbed-block">
<p>我们可以使用<a href="https://en.wikipedia.org/wiki/Shell_(computing)">shell</a>执行命令。</p>
<p>shell 是命令行的用户界面，称为命令行解释器 (CLI)。</p>
<p>它将代表用户解释并执行命令。</p>
<p>它还提供诸如用于脚本、通配符、管道、shell 变量（例如 PATH）等的原始编程语言等功能。</p>
<p>例如，我们可以将一个命令的输出重定向为另一个命令的输入，例如将“<strong>/etc/services</strong>”文件的内容重定向到字数统计“wc”命令并统计行数：</p>
<div class="highlight"><pre><span></span><code><span class="n">cat</span> <span class="o">/</span><span class="n">etc</span><span class="o">/</span><span class="n">services</span> <span class="o">|</span> <span class="n">wc</span> <span class="o">-</span><span class="n">l</span>
</code></pre></div>
<p>基于 Unix 的操作系统中的 shell 示例包括：</p>
<ul>
<li>‘sh’</li>
<li>‘bash’</li>
<li>‘zsh’</li>
<li>等等。</li>
</ul>
<p>在 Windows 上，shell 可能是 <a href="https://en.wikipedia.org/wiki/Cmd.exe">cmd.exe</a>。</p>
<p>请参阅这个很棒的命令行 shell 列表：</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/List_of_command-line_interpreters">命令行解释器列表</a>, Wikipedia</li>
</ul>
<p>shell已经在运行，它被用来启动Python程序。</p>
<p>您无需执行任何特殊操作即可获取或访问 shell。</p>
<p>我们可以通过 <strong>create_subprocess_shell()</strong> 函数从 asyncio 程序执行命令。</p>
<p><strong>asyncio.create_subprocess_shell()</strong> 函数接受一个命令并使用当前用户 shell 执行它。</p>
<p>这很有用，因为它不仅允许执行命令，还允许使用 shell 的功能，例如重定向、通配符等。</p>
<blockquote>
<p>… 指定的命令将通过 shell 执行。 如果您使用 Python 主要是为了增强它在大多数系统 shell 上提供的控制流，并且仍然希望方便地访问其他 shell 功能（例如 shell 管道、文件名通配符、环境变量扩展以及将 ~ 扩展到用户主目录），那么这会很有用。</p>
<p>— <a href="https://docs.python.org/3/library/subprocess.html">SUBPROCESS — SUBPROCESS MANAGEMENT</a></p>
</blockquote>
<p>该命令将在执行 asyncio 程序的进程的子进程中执行。</p>
<p>重要的是，asyncio 程序能够与子进程异步交互，例如 通过协程。</p>
<blockquote>
<p>因为所有 asyncio 子进程函数都是异步的，并且 asyncio 提供了许多工具来使用这些函数，所以很容易并行执行和监视多个子进程。</p>
<p>— <a href="https://docs.python.org/3/library/asyncio-subprocess.html">ASYNCIO SUBPROCESSES</a></p>
</blockquote>
<p>通过 shell 而不是直接执行命令时可能存在安全考虑。</p>
<p>这是因为执行命令的请求和正在执行的命令之间至少存在一层间接和解释，从而允许可能的恶意注入。</p>
<blockquote>
<p>重要的应用程序有责任确保所有空格和特殊字符都被正确引用，以避免 shell 注入漏洞。</p>
<p>— <a href="https://docs.python.org/3/library/asyncio-subprocess.html">ASYNCIO SUBPROCESSES</a></p>
</blockquote>
<p>现在我们知道了 <strong>asyncio.create_subprocess_shell()</strong> 的作用，让我们看看如何使用它。</p>
</div>
</div>
</div>
<h4 id="1931-如何使用-asyncio-的-create_subprocess_shell">19.3.1 如何使用 Asyncio 的 create_subprocess_shell()<a class="headerlink" href="#1931-如何使用-asyncio-的-create_subprocess_shell" title="Permanent link">&para;</a></h4>
<p><strong>19.3.1 How to Use Asyncio create_subprocess_shell()</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="112:2"><input checked="checked" id="__tabbed_112_1" name="__tabbed_112" type="radio" /><input id="__tabbed_112_2" name="__tabbed_112" type="radio" /><div class="tabbed-labels"><label for="__tabbed_112_1">English</label><label for="__tabbed_112_2">Chinese</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<p>The <a href="https://docs.python.org/3/library/asyncio-subprocess.html#asyncio.create_subprocess_shell">asyncio.create_subprocess_shell()</a> function will execute a given string command via the current shell.</p>
<p>It returns a <a href="https://docs.python.org/3/library/asyncio-subprocess.html#asyncio.subprocess.Process">asyncio.subprocess.Process</a> object that represents the process.</p>
<p>It is very similar to the <strong>create_subprocess_shell()</strong> function we saw in a previous section. Nevertheless, we will review how to use the function and interact with the process via the Process instance (in case you skipped straight to this section).</p>
<p>The <strong>create_subprocess_shell()</strong> function is a coroutine, which means we must await it. It will return once the subprocess has been started, not when the subprocess is finished.</p>
<p>For example:</p>
<div class="highlight"><pre><span></span><code><span class="o">...</span>
<span class="c1"># start a subprocess</span>
<span class="n">process</span> <span class="o">=</span> <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">create_subprocess_shell</span><span class="p">(</span><span class="s1">&#39;ls&#39;</span><span class="p">)</span>
<span class="n">We</span> <span class="n">can</span> <span class="n">wait</span> <span class="k">for</span> <span class="n">the</span> <span class="n">subprocess</span> <span class="n">to</span> <span class="n">finish</span> <span class="n">by</span> <span class="n">awaiting</span> <span class="n">the</span> <span class="o">**</span><span class="n">wait</span><span class="p">()</span><span class="o">**</span> <span class="n">method</span><span class="o">.</span>
</code></pre></div>
<p>For example:</p>
<div class="highlight"><pre><span></span><code><span class="o">...</span>
<span class="c1"># wait for the subprocess to terminate</span>
<span class="k">await</span> <span class="n">process</span><span class="o">.</span><span class="n">wait</span><span class="p">()</span>
</code></pre></div>
<p>We can stop the subprocess directly by calling the <strong>terminate()</strong> or <strong>kill()</strong> methods, which will raise a signal in the subprocess.</p>
<p>The input and output of the command will be handled by the shell, e.g. <strong>stdin</strong>, <strong>stderr</strong>, and <strong>stdout</strong>.</p>
<p>We can have the asyncio program handle the input or output for the subprocess.</p>
<p>This can be achieved by specifying the input or output stream and specifying a constant to redirect, such as <strong>asyncio.subprocess.PIPE</strong>.</p>
<p>For example, we can redirect the output of a command to the asyncio program:</p>
<div class="highlight"><pre><span></span><code><span class="o">...</span>
<span class="c1"># start a subprocess and redirect output</span>
<span class="n">process</span> <span class="o">=</span> <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">create_subprocess_shell</span><span class="p">(</span><span class="s1">&#39;ls&#39;</span><span class="p">,</span> <span class="n">stdout</span><span class="o">=</span><span class="n">asyncio</span><span class="o">.</span><span class="n">subprocess</span><span class="o">.</span><span class="n">PIPE</span><span class="p">)</span>
</code></pre></div>
<p>We can then read the output of the program via the <strong>asyncio.subprocess.Process</strong> instance via the <strong>communicate()</strong> method.</p>
<p>This method is a coroutine and must be awaited. It is used to both send and receive data with the subprocess.</p>
<p>For example:</p>
<div class="highlight"><pre><span></span><code><span class="o">...</span>
<span class="c1"># read data from the subprocess</span>
<span class="n">line</span> <span class="o">=</span> <span class="n">process</span><span class="o">.</span><span class="n">communicate</span><span class="p">()</span>
</code></pre></div>
<p>We can also send data to the subprocess via the <strong>communicate()</strong> method by setting the “input” argument in bytes.</p>
<p>For example:</p>
<div class="highlight"><pre><span></span><code><span class="o">...</span>
<span class="c1"># start a subprocess and redirect input</span>
<span class="n">process</span> <span class="o">=</span> <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">create_subprocess_shell</span><span class="p">(</span><span class="s1">&#39;ls&#39;</span><span class="p">,</span> <span class="n">stdin</span><span class="o">=</span><span class="n">asyncio</span><span class="o">.</span><span class="n">subprocess</span><span class="o">.</span><span class="n">PIPE</span><span class="p">)</span>
<span class="c1"># send data to the subprocess</span>
<span class="n">process</span><span class="o">.</span><span class="n">communicate</span><span class="p">(</span><span class="nb">input</span><span class="o">=</span><span class="sa">b</span><span class="s1">&#39;Hello</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
</code></pre></div>
<p>Behind the scenes the <strong>asyncio.subprocess.PIPE</strong> configures the subprocess to point to a <strong>StreamReader</strong> or <strong>StreamWriter</strong> for sending data to or from the subprocess, and the <strong>communicate()</strong> method will read or write bytes from the configured reader.</p>
<blockquote>
<p>If PIPE is passed to stdin argument, the Process.stdin attribute will point to a StreamWriter instance. If PIPE is passed to stdout or stderr arguments, the Process.stdout and Process.stderr attributes will point to StreamReader instances.</p>
<p>— <a href="https://docs.python.org/3/library/asyncio-subprocess.html">ASYNCIO SUBPROCESSES</a></p>
</blockquote>
<p>We can interact with the <strong>StreamReader</strong> or <strong>StreamWriter</strong> directly via the subprocess via the stdin, stdout, and stderr attributes.</p>
<p>For example:</p>
<div class="highlight"><pre><span></span><code><span class="o">...</span>
<span class="c1"># read a line from the subprocess output stream</span>
<span class="n">line</span> <span class="o">=</span> <span class="k">await</span> <span class="n">process</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>
</code></pre></div>
<p>Now that we know how to use the <strong>create_subprocess_shell()</strong> function, let’s look at some worked examples.</p>
</div>
<div class="tabbed-block">
<p><a href="https://docs.python.org/3/library/asyncio-subprocess.html#asyncio.create_subprocess_shell">asyncio.create_subprocess_shell()</a> 函数将通过当前 shell 执行给定的字符串命令。</p>
<p>它返回一个表示进程的 <a href="https://docs.python.org/3/library/asyncio-subprocess.html#asyncio.subprocess.Process">asyncio.subprocess.Process</a> 对象。</p>
<p>它与我们在上一节中看到的 <strong>create_subprocess_shell()</strong> 函数非常相似。 尽管如此，我们将回顾如何使用该函数并通过 <strong>Process</strong> 实例与流程交互（如果您直接跳到本节）。</p>
<p><strong>create_subprocess_shell()</strong> 函数是一个协程，这意味着我们必须等待它。 它会在子进程启动后返回，而不是在子进程完成时返回。</p>
<p>例如:</p>
<div class="highlight"><pre><span></span><code><span class="o">...</span>
<span class="c1"># 启动一个子进程</span>
<span class="n">process</span> <span class="o">=</span> <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">create_subprocess_shell</span><span class="p">(</span><span class="s1">&#39;ls&#39;</span><span class="p">)</span>
</code></pre></div>
<p>我们可以通过等待 <strong>wait()</strong> 方法来等待子进程完成。</p>
<p>例如:</p>
<div class="highlight"><pre><span></span><code><span class="o">...</span>
<span class="c1"># 等待子进程终止</span>
<span class="k">await</span> <span class="n">process</span><span class="o">.</span><span class="n">wait</span><span class="p">()</span>
</code></pre></div>
<p>我们可以通过调用 <strong>terminate()</strong> 或 <strong>kill()</strong> 方法直接停止子进程，这将在子进程中引发一个信号。</p>
<p>命令的输入和输出将由 shell 处理，例如 <strong>标准输入</strong>、<strong>标准错误</strong>和<strong>标准输出</strong>。</p>
<p>我们可以让 asyncio 程序处理子进程的输入或输出。</p>
<p>这可以通过指定输入或输出流并指定要重定向的常量来实现，例如 <strong>asyncio.subprocess.PIPE</strong>。</p>
<p>例如，我们可以将命令的输出重定向到 asyncio 程序：</p>
<div class="highlight"><pre><span></span><code><span class="o">...</span>
<span class="c1"># 启动子进程并重定向输出</span>
<span class="n">process</span> <span class="o">=</span> <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">create_subprocess_shell</span><span class="p">(</span><span class="s1">&#39;ls&#39;</span><span class="p">,</span> <span class="n">stdout</span><span class="o">=</span><span class="n">asyncio</span><span class="o">.</span><span class="n">subprocess</span><span class="o">.</span><span class="n">PIPE</span><span class="p">)</span>
</code></pre></div>
<p>然后我们可以通过<strong>asyncio.subprocess.Process</strong>实例通过<strong>communicate()</strong>方法读取程序的输出。</p>
<p>该方法是一个协程，必须等待。 它用于通过子进程发送和接收数据。</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code><span class="o">...</span>
<span class="c1"># 从子进程读取数据</span>
<span class="n">line</span> <span class="o">=</span> <span class="n">process</span><span class="o">.</span><span class="n">communicate</span><span class="p">()</span>
</code></pre></div>
<p>我们还可以通过以字节为单位设置“input”参数，通过 <strong>communicate()</strong> 方法将数据发送到子进程。</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code><span class="o">...</span>
<span class="c1"># 启动子进程并重定向输入</span>
<span class="n">process</span> <span class="o">=</span> <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">create_subprocess_shell</span><span class="p">(</span><span class="s1">&#39;ls&#39;</span><span class="p">,</span> <span class="n">stdin</span><span class="o">=</span><span class="n">asyncio</span><span class="o">.</span><span class="n">subprocess</span><span class="o">.</span><span class="n">PIPE</span><span class="p">)</span>
<span class="c1"># 向子进程发送数据</span>
<span class="n">process</span><span class="o">.</span><span class="n">communicate</span><span class="p">(</span><span class="nb">input</span><span class="o">=</span><span class="sa">b</span><span class="s1">&#39;Hello</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
</code></pre></div>
<p>在背后， <strong>asyncio.subprocess.PIPE</strong> 将子进程配置为指向 <strong>StreamReader</strong> 或 <strong>StreamWriter</strong> 用于向子进程发送数据或从子进程发送数据，以及 <strong>communicate()</strong> 方法 将从配置的读取器读取或写入字节。</p>
<blockquote>
<p>如果 PIPE 传递给 stdin 参数，则 Process.stdin 属性将指向 StreamWriter 实例。 如果 PIPE 传递给 stdout 或 stderr 参数，则 Process.stdout 和 Process.stderr 属性将指向 StreamReader 实例。</p>
<p>— <a href="https://docs.python.org/3/library/asyncio-subprocess.html">ASYNCIO SUBPROCESSES</a></p>
</blockquote>
<p>我们可以通过子进程的 <code>stdin</code>、<code>stdout</code> 和 <code>stderr</code> 属性直接与 <strong>StreamReader</strong> 或 <strong>StreamWriter</strong> 交互。</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code><span class="o">...</span>
<span class="c1"># 从子进程输出流中读取一行</span>
<span class="n">line</span> <span class="o">=</span> <span class="k">await</span> <span class="n">process</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>
</code></pre></div>
<p>现在我们知道如何使用 <strong>create_subprocess_shell()</strong> 函数，让我们看一些有效的示例。</p>
</div>
</div>
</div>
<h4 id="1932-asyncio-的-create_subprocess_shell-的示例">19.3.2 Asyncio 的 create_subprocess_shell() 的示例<a class="headerlink" href="#1932-asyncio-的-create_subprocess_shell-的示例" title="Permanent link">&para;</a></h4>
<p><strong>19.3.2 Example of Asyncio create_subprocess_shell()</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="113:2"><input checked="checked" id="__tabbed_113_1" name="__tabbed_113" type="radio" /><input id="__tabbed_113_2" name="__tabbed_113" type="radio" /><div class="tabbed-labels"><label for="__tabbed_113_1">English</label><label for="__tabbed_113_2">Chinese</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<p>We can explore how to run a command in a subprocess from asyncio using the shell.</p>
<p>In this example, we will execute the <a href="https://en.wikipedia.org/wiki/Echo_(command)">“echo”</a> command to report back a string.</p>
<p>The echo command will report the provided string on standard output directly.</p>
<p>The complete example is listed below.</p>
<p>Note, this example assumes you have access to the “echo” command, I’m not sure it will work on Windows.</p>
<div class="highlight"><pre><span></span><code><span class="c1"># SuperFastPython.com</span>
<span class="c1"># example of executing a shell command as a subprocess with asyncio</span>
<span class="kn">import</span> <span class="nn">asyncio</span>

<span class="c1"># main coroutine</span>
<span class="k">async</span> <span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="c1"># start executing a shell command in a subprocess</span>
    <span class="n">process</span> <span class="o">=</span> <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">create_subprocess_shell</span><span class="p">(</span><span class="s1">&#39;echo Hello World&#39;</span><span class="p">)</span>
    <span class="c1"># report the details of the subprocess</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;subprocess: </span><span class="si">{</span><span class="n">process</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

<span class="c1"># entry point</span>
<span class="n">asyncio</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">main</span><span class="p">())</span>
</code></pre></div>
<p>Running the example first creates the main() coroutine and executes it as the entry point into the asyncio program.</p>
<p>The main() coroutine runs and calls the create_subprocess_shell() function to execute a command.</p>
<p>The main() coroutine suspends while the subprocess is created. A Process instance is returned.</p>
<p>The main() coroutine resumes and reports the details of the subprocess. The main() process terminates and the asyncio program terminates.</p>
<p>The output of the echo command is reported on the command line.</p>
<p>This highlights how we can execute a command using the shell from an asyncio program.</p>
<div class="highlight"><pre><span></span><code>subprocess: &lt;Process 43916&gt;
Hello World
</code></pre></div>
</div>
<div class="tabbed-block">
<p>我们可以探索如何使用 shell 从 asyncio 的子进程中运行命令。</p>
<p>在此示例中，我们将执行 <a href="https://en.wikipedia.org/wiki/Echo_(command)">“echo”</a> 命令来报告一个字符串。</p>
<p>echo 命令将直接在标准输出上报告提供的字符串。</p>
<p>下面列出了完整的示例。</p>
<p>请注意，此示例假设您有权访问“echo”命令，我不确定它是否适用于 Windows。</p>
<div class="highlight"><pre><span></span><code><span class="c1"># SuperFastPython.com</span>
<span class="c1"># 使用 asyncio 作为子进程执行 shell 命令的示例</span>
<span class="kn">import</span> <span class="nn">asyncio</span>

<span class="c1"># 主协程</span>
<span class="k">async</span> <span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="c1"># 开始在子进程中执行 shell 命令</span>
    <span class="n">process</span> <span class="o">=</span> <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">create_subprocess_shell</span><span class="p">(</span><span class="s1">&#39;echo Hello World&#39;</span><span class="p">)</span>
    <span class="c1"># 报告子流程的详细信息</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;subprocess: </span><span class="si">{</span><span class="n">process</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

<span class="c1"># 入口点</span>
<span class="n">asyncio</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">main</span><span class="p">())</span>
</code></pre></div>
<p>运行该示例首先创建 <strong>main()</strong> 协程并将其作为 asyncio 程序的入口点执行。</p>
<p><strong>main()</strong> 协程运行并调用 <strong>create_subprocess_shell()</strong> 函数来执行命令。</p>
<p><strong>main()</strong> 协程在子进程创建时挂起。 返回一个 <a href="https://docs.python.org/3/library/asyncio-subprocess.html#asyncio.subprocess.Process"><strong>Process</strong></a> 实例。</p>
<p><strong>main()</strong> 协程恢复并报告子流程的详细信息。 <strong>main()</strong> 进程终止，asyncio 程序终止。</p>
<p>echo 命令的输出在命令行上报告。</p>
<p>这突出显示了我们如何使用 asyncio 程序中的 shell 执行命令。</p>
<div class="highlight"><pre><span></span><code>subprocess: &lt;Process 43916&gt;
Hello World
</code></pre></div>
</div>
</div>
</div>
<h2 id="20-非阻塞流">20. 非阻塞流<a class="headerlink" href="#20-非阻塞流" title="Permanent link">&para;</a></h2>
<p><strong>20. Non-Blocking Streams</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="114:2"><input checked="checked" id="__tabbed_114_1" name="__tabbed_114" type="radio" /><input id="__tabbed_114_2" name="__tabbed_114" type="radio" /><div class="tabbed-labels"><label for="__tabbed_114_1">English</label><label for="__tabbed_114_2">Chinese</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<p>A major benefit of asyncio is the ability to use non-blocking streams.</p>
<p>Let’s take a closer look.</p>
</div>
<div class="tabbed-block">
<p>asyncio 的一个主要好处是能够使用非阻塞流。</p>
<p>让我们仔细看看。</p>
</div>
</div>
</div>
<h3 id="201-asyncio-的流">20.1 Asyncio 的流<a class="headerlink" href="#201-asyncio-的流" title="Permanent link">&para;</a></h3>
<p><strong>20.1 Asyncio Streams</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="115:2"><input checked="checked" id="__tabbed_115_1" name="__tabbed_115" type="radio" /><input id="__tabbed_115_2" name="__tabbed_115" type="radio" /><div class="tabbed-labels"><label for="__tabbed_115_1">English</label><label for="__tabbed_115_2">Chinese</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<p>Asyncio provides non-blocking I/O socket programming.</p>
<p>This is provided via streams.</p>
<blockquote>
<p>Streams are high-level async/await-ready primitives to work with network connections. Streams allow sending and receiving data without using callbacks or low-level protocols and transports.</p>
<p>— ASYNCIO STREAMS</p>
</blockquote>
<p>Sockets can be opened that provide access to a stream writer and a stream writer.</p>
<p>Data can then be written and read from the stream using coroutines, suspending when appropriate.</p>
<p>Once finished, the socket can be closed.</p>
<p>The asyncio streams capability is low-level meaning that any protocols required must be implemented manually.</p>
<p>This might include common web protocols, such as:</p>
<ul>
<li>HTTP or HTTPS for interacting with web servers</li>
<li>SMTP for interacting with email servers</li>
<li>FTP for interacting with file servers.</li>
</ul>
<p>The streams can also be used to create a server to handle requests using a standard protocol, or to develop your own application-specific protocol.</p>
<p>Now that we know what asyncio streams are, let’s look at how to use them.</p>
</div>
<div class="tabbed-block">
<p>Asyncio 提供非阻塞 I/O 套接字编程。</p>
<p>这是通过流(streams)提供的。</p>
<blockquote>
<p>流(streams)是高级异步/等待就绪原语，可与网络连接一起使用。 流允许在不使用回调或低级协议和传输的情况下发送和接收数据。</p>
<p>— <a href="https://docs.python.org/3/library/asyncio-stream.html">ASYNCIO STREAMS</a></p>
</blockquote>
<p>可以打开提供对流写入器和流写入器的访问的套接字。</p>
<p>然后可以使用协程在流中写入和读取数据，并在适当的时候挂起。</p>
<p>完成后，可以关闭套接字。</p>
<p>异步流功能是低级的，这意味着必须手动实现所需的任何协议。</p>
<p>这可能包括常见的网络协议，例如：</p>
<ul>
<li>用于与 Web 服务器交互的 HTTP 或 HTTPS</li>
<li>用于与电子邮件服务器交互的 SMTP</li>
<li>用于与文件服务器交互的 FTP。</li>
</ul>
<p>这些流还可用于创建服务器来使用标准协议处理请求，或开发您自己的特定于应用程序的协议。</p>
<p>现在我们知道什么是异步流，让我们看看如何使用它们。</p>
</div>
</div>
</div>
<h3 id="202-如何打开一个连接">20.2 如何打开一个连接<a class="headerlink" href="#202-如何打开一个连接" title="Permanent link">&para;</a></h3>
<p><strong>20.2 How to Open a Connection</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="116:2"><input checked="checked" id="__tabbed_116_1" name="__tabbed_116" type="radio" /><input id="__tabbed_116_2" name="__tabbed_116" type="radio" /><div class="tabbed-labels"><label for="__tabbed_116_1">English</label><label for="__tabbed_116_2">Chinese</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<p>An asyncio TCP client socket connection can be opened using the <a href="https://docs.python.org/3/library/asyncio-stream.html#asyncio.open_connection">asyncio.open_connection()</a> function.</p>
<blockquote>
<p>Establish a network connection and return a pair of (reader, writer) objects. The returned reader and writer objects are instances of StreamReader and StreamWriter classes.</p>
<p>— <a href="https://docs.python.org/3/library/asyncio-stream.html">ASYNCIO STREAMS</a></p>
</blockquote>
<p>This is a coroutine that must be awaited and will return once the socket connection is open.</p>
<p>The function returns a <strong>StreamReader</strong> and <strong>StreamWriter</strong> object for interacting with the socket.</p>
<p>For example:</p>
<div class="highlight"><pre><span></span><code><span class="o">...</span>
<span class="c1"># open a connection</span>
<span class="n">reader</span><span class="p">,</span> <span class="n">writer</span> <span class="o">=</span> <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">open_connection</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
</code></pre></div>
<p>The <strong>asyncio.open_connection()</strong> function takes many arguments in order to configure the socket connection.</p>
<p>The two required arguments are the host and the port.</p>
<p>The host is a string that specifies the server to connect to, such as a domain name or an IP address.</p>
<p>The port is the socket port number, such as 80 for HTTP servers, 443 for HTTPS servers, 23 for SMTP and so on.</p>
<p>For example:</p>
<div class="highlight"><pre><span></span><code><span class="o">...</span>
<span class="c1"># open a connection to an http server</span>
<span class="n">reader</span><span class="p">,</span> <span class="n">writer</span> <span class="o">=</span> <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">open_connection</span><span class="p">(</span><span class="s1">&#39;www.google.com&#39;</span><span class="p">,</span> <span class="mi">80</span><span class="p">)</span>
</code></pre></div>
<p>Encrypted socket connections are supported over the SSL protocol.</p>
<p>The most common example might be HTTPS which is replacing HTTP.</p>
<p>This can be achieved by setting the “<strong>ssl</strong>” argument to <strong>True</strong>.</p>
<p>For example:</p>
<div class="highlight"><pre><span></span><code><span class="o">...</span>
<span class="c1"># open a connection to an https server</span>
<span class="n">reader</span><span class="p">,</span> <span class="n">writer</span> <span class="o">=</span> <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">open_connection</span><span class="p">(</span><span class="s1">&#39;www.google.com&#39;</span><span class="p">,</span> <span class="mi">443</span><span class="p">,</span> <span class="n">ssl</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</code></pre></div>
</div>
<div class="tabbed-block">
<p>可以使用 <a href="https://docs.python.org/3/library/asyncio-stream.html#asyncio.open_connection">asyncio.open_connection()</a> 函数打开 asyncio TCP 客户端套接字连接。</p>
<blockquote>
<p>建立网络连接并返回一对（reader、writer）对象。 返回的读取器和写入器对象是 StreamReader 和 StreamWriter 类的实例。</p>
<p>— <a href="https://docs.python.org/3/library/asyncio-stream.html">ASYNCIO STREAMS</a></p>
</blockquote>
<p>这是一个必须等待的协程，一旦套接字连接打开就会返回。</p>
<p>该函数返回一个 <strong>StreamReader</strong> 和 <strong>StreamWriter</strong> 对象，用于与套接字交互。</p>
<p>例如:</p>
<div class="highlight"><pre><span></span><code><span class="o">...</span>
<span class="c1"># 打开一个连接</span>
<span class="n">reader</span><span class="p">,</span> <span class="n">writer</span> <span class="o">=</span> <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">open_connection</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
</code></pre></div>
<p><strong>asyncio.open_connection()</strong> 函数需要许多参数来配置套接字连接。</p>
<p>两个必需的参数是主机和端口。</p>
<p>主机是一个字符串，指定要连接的服务器，例如域名或IP地址。</p>
<p>port 是套接字端口号，例如 HTTP 服务器为 80，HTTPS 服务器为 443，SMTP 为 23 等。</p>
<p>例如:</p>
<div class="highlight"><pre><span></span><code><span class="o">...</span>
<span class="c1"># 打开与 http 服务器的连接</span>
<span class="n">reader</span><span class="p">,</span> <span class="n">writer</span> <span class="o">=</span> <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">open_connection</span><span class="p">(</span><span class="s1">&#39;www.google.com&#39;</span><span class="p">,</span> <span class="mi">80</span><span class="p">)</span>
</code></pre></div>
<p>SSL 协议支持加密套接字连接。</p>
<p>最常见的例子可能是 HTTPS，它正在取代 HTTP。</p>
<p>这可以通过将“<strong>ssl</strong>”参数设置为<strong>True</strong>来实现。</p>
<p>例如:</p>
<div class="highlight"><pre><span></span><code><span class="o">...</span>
<span class="c1"># 打开与 https 服务器的连接</span>
<span class="n">reader</span><span class="p">,</span> <span class="n">writer</span> <span class="o">=</span> <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">open_connection</span><span class="p">(</span><span class="s1">&#39;www.google.com&#39;</span><span class="p">,</span> <span class="mi">443</span><span class="p">,</span> <span class="n">ssl</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</code></pre></div>
</div>
</div>
</div>
<h3 id="203-如何启动一个侦听服务">20.3 如何启动一个侦听服务<a class="headerlink" href="#203-如何启动一个侦听服务" title="Permanent link">&para;</a></h3>
<p><strong>20.3 How to Start a Server</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="117:2"><input checked="checked" id="__tabbed_117_1" name="__tabbed_117" type="radio" /><input id="__tabbed_117_2" name="__tabbed_117" type="radio" /><div class="tabbed-labels"><label for="__tabbed_117_1">English</label><label for="__tabbed_117_2">Chinese</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<p>An asyncio TCP server socket can be opened using the <a href="https://docs.python.org/3/library/asyncio-stream.html#asyncio.start_server">asyncio.start_server()</a> function.</p>
<blockquote>
<p>Create a TCP server (socket type SOCK_STREAM) listening on port of the host address.</p>
<p>— <a href="https://docs.python.org/3/library/asyncio-eventloop.html">ASYNCIO EVENT LOOP</a></p>
</blockquote>
<p>This is a coroutine that must be awaited.</p>
<p>The function returns an <a href="https://docs.python.org/3/library/asyncio-eventloop.html#asyncio.Server">asyncio.Server</a> object that represents the running server.</p>
<p>For example:</p>
<div class="highlight"><pre><span></span><code><span class="o">...</span>
<span class="c1"># start a tcp server</span>
<span class="n">server</span> <span class="o">=</span> <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">start_server</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
</code></pre></div>
<p>The three required arguments are the callback function, the host, and the port.</p>
<p>The callback function is a custom function specified by name that will be called each time a client connects to the server.</p>
<blockquote>
<p>The client_connected_cb callback is called whenever a new client connection is established. It receives a (reader, writer) pair as two arguments, instances of the StreamReader and StreamWriter classes.</p>
<p>— ASYNCIO STREAMS</p>
</blockquote>
<p>The host is the domain name or IP address that clients will specify to connect. The port is the socket port number on which to receive connections, such as 21 for FTP or 80 for HTTP.</p>
<p>For example:</p>
<div class="highlight"><pre><span></span><code><span class="c1"># handle connections</span>
<span class="k">async</span> <span class="k">def</span> <span class="nf">handler</span><span class="p">(</span><span class="n">reader</span><span class="p">,</span> <span class="n">writer</span><span class="p">):</span>
    <span class="c1"># ...</span>

<span class="o">...</span>
<span class="c1"># start a server to receive http connections</span>
<span class="n">server</span> <span class="o">=</span> <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">start_server</span><span class="p">(</span><span class="n">handler</span><span class="p">,</span> <span class="s1">&#39;127.0.0.1&#39;</span><span class="p">,</span> <span class="mi">80</span><span class="p">)</span>
</code></pre></div>
</div>
<div class="tabbed-block">
<p>可以使用 <a href="https://docs.python.org/3/library/asyncio-stream.html#asyncio.start_server">asyncio.start_server()</a> 函数打开 <strong>asyncio TCP</strong> 服务器套接字。</p>
<blockquote>
<p>创建一个 TCP 服务器（套接字类型 <strong>SOCK_STREAM</strong>），侦听主机地址的端口。</p>
<p>— <a href="https://docs.python.org/3/library/asyncio-eventloop.html">ASYNCIO EVENT LOOP</a></p>
</blockquote>
<p>这是一个必须等待的协程。</p>
<p>该函数返回一个代表正在运行的服务器的 <a href="https://docs.python.org/3/library/asyncio-eventloop.html#asyncio.Server">asyncio.Server</a> 对象。</p>
<p>例如:</p>
<div class="highlight"><pre><span></span><code><span class="o">...</span>
<span class="c1"># 启动一个tcp服务器</span>
<span class="n">server</span> <span class="o">=</span> <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">start_server</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
</code></pre></div>
<p>三个必需参数是回调函数、主机和端口。</p>
<p>回调函数是一个由名称指定的自定义函数，每次客户端连接到服务器时都会调用该函数。</p>
<blockquote>
<p>每当建立新的客户端连接时，都会调用 <code>client_connected_cb</code> 回调。 它接收一个（读取器(reader)，写入器(writer)）对作为两个参数，即 <strong>StreamReader</strong> 和 <strong>StreamWriter</strong> 类的实例。</p>
<p>— <a href="https://docs.python.org/3/library/asyncio-stream.html">ASYNCIO STREAMS</a></p>
</blockquote>
<p>主机是客户端指定连接的域名或IP地址。 <strong>port</strong> 是接收连接的套接字端口号，例如 <strong>FTP</strong> 为 <code>21</code>，<strong>HTTP</strong> 为 <code>80</code>。</p>
<p>例如:</p>
<div class="highlight"><pre><span></span><code><span class="c1"># 处理连接</span>
<span class="k">async</span> <span class="k">def</span> <span class="nf">handler</span><span class="p">(</span><span class="n">reader</span><span class="p">,</span> <span class="n">writer</span><span class="p">):</span>
    <span class="c1"># ...</span>

<span class="o">...</span>
<span class="c1"># 启动一个服务器来接收http连接</span>
<span class="n">server</span> <span class="o">=</span> <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">start_server</span><span class="p">(</span><span class="n">handler</span><span class="p">,</span> <span class="s1">&#39;127.0.0.1&#39;</span><span class="p">,</span> <span class="mi">80</span><span class="p">)</span>
</code></pre></div>
</div>
</div>
</div>
<h3 id="204-如何使用-streamwriter-写入数据">20.4 如何使用 StreamWriter 写入数据<a class="headerlink" href="#204-如何使用-streamwriter-写入数据" title="Permanent link">&para;</a></h3>
<p><strong>20.4 How to Write Data with the StreamWriter</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="118:2"><input checked="checked" id="__tabbed_118_1" name="__tabbed_118" type="radio" /><input id="__tabbed_118_2" name="__tabbed_118" type="radio" /><div class="tabbed-labels"><label for="__tabbed_118_1">English</label><label for="__tabbed_118_2">Chinese</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<p>We can write data to the socket using an <a href="https://docs.python.org/3/library/asyncio-stream.html#streamwriter">asyncio.StreamWriter</a>.</p>
<blockquote>
<p>Represents a writer object that provides APIs to write data to the IO stream.</p>
<p>— <a href="https://docs.python.org/3/library/asyncio-stream.html">ASYNCIO STREAMS</a></p>
</blockquote>
<p>Data is written as bytes.</p>
<p>Byte data can be written to the socket using the <a href="https://docs.python.org/3/library/asyncio-stream.html#asyncio.StreamWriter.write">write()</a> method.</p>
<blockquote>
<p>The method attempts to write the data to the underlying socket immediately. If that fails, the data is queued in an internal write buffer until it can be sent.</p>
<p>— <a href="https://docs.python.org/3/library/asyncio-stream.html">ASYNCIO STREAMS</a></p>
</blockquote>
<p>For example:</p>
<div class="highlight"><pre><span></span><code><span class="o">...</span>
<span class="c1"># write byte data</span>
<span class="n">writer</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">byte_data</span><span class="p">)</span>
</code></pre></div>
<p>Alternatively, multiple “lines” of byte data organized into a list or iterable can be written using the <a href="https://docs.python.org/3/library/asyncio-stream.html#asyncio.StreamWriter.writelines">writelines()</a> method.</p>
<p>For example:</p>
<div class="highlight"><pre><span></span><code><span class="o">...</span>
<span class="c1"># write lines of byte data</span>
<span class="n">writer</span><span class="o">.</span><span class="n">writelines</span><span class="p">(</span><span class="n">byte_lines</span><span class="p">)</span>
</code></pre></div>
<p>Neither method for writing data blocks or suspends the calling coroutine.</p>
<p>After writing byte data it is a good idea to drain the socket via the <a href="https://docs.python.org/3/library/asyncio-stream.html#asyncio.StreamWriter.drain">drain()</a> method.</p>
<blockquote>
<p>Wait until it is appropriate to resume writing to the stream.</p>
<p>— <a href="https://docs.python.org/3/library/asyncio-stream.html">ASYNCIO STREAMS</a></p>
</blockquote>
<p>This is a coroutine and will suspend the caller until the bytes have been transmitted and the socket is ready.</p>
<p>For example:</p>
<div class="highlight"><pre><span></span><code><span class="o">...</span>
<span class="c1"># write byte data</span>
<span class="n">writer</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">byte_data</span><span class="p">)</span>
<span class="c1"># wait for data to be transmitted</span>
<span class="k">await</span> <span class="n">writer</span><span class="o">.</span><span class="n">drain</span><span class="p">()</span>
</code></pre></div>
</div>
<div class="tabbed-block">
<p>我们可以使用 <a href="https://docs.python.org/3/library/asyncio-stream.html#streamwriter">asyncio.StreamWriter</a> 将数据写入套接字。</p>
<blockquote>
<p>表示一个 writer 对象，它提供 API 将数据写入 IO 流。</p>
<p>— <a href="https://docs.python.org/3/library/asyncio-stream.html">ASYNCIO STREAMS</a></p>
</blockquote>
<p>数据以字节形式写入。</p>
<p>可以使用 <a href="https://docs.python.org/3/library/asyncio-stream.html#asyncio.StreamWriter.write">write()</a> 方法将字节数据写入套接字。</p>
<blockquote>
<p>该方法尝试立即将数据写入底层套接字。 如果失败，数据将在内部写入缓冲区中排队，直到可以发送。</p>
<p>— <a href="https://docs.python.org/3/library/asyncio-stream.html">ASYNCIO STREAMS</a></p>
</blockquote>
<p>例如:</p>
<div class="highlight"><pre><span></span><code><span class="o">...</span>
<span class="c1"># 写入字节数据</span>
<span class="n">writer</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">byte_data</span><span class="p">)</span>
</code></pre></div>
<p>或者，可以使用 <a href="https://docs.python.org/3/library/asyncio-stream.html#asyncio.StreamWriter">writelines()</a> 写入组织成列表或可迭代的多“行”字节数据。 writelines) 方法。</p>
<p>例如:</p>
<div class="highlight"><pre><span></span><code><span class="o">...</span>
<span class="c1"># 写入字节数据行</span>
<span class="n">writer</span><span class="o">.</span><span class="n">writelines</span><span class="p">(</span><span class="n">byte_lines</span><span class="p">)</span>
</code></pre></div>
<p>这两种方法都不会写入数据块或挂起调用协程。</p>
<p>写入字节数据后，最好通过 <a href="https://docs.python.org/3/library/asyncio-stream.html#asyncio.StreamWriter.drain">drain()</a> 方法排空套接字。</p>
<blockquote>
<p>等到合适的时候再继续写入流。</p>
<p>— <a href="https://docs.python.org/3/library/asyncio-stream.html">ASYNCIO STREAMS</a></p>
</blockquote>
<p>这是一个协程，将挂起调用者，直到字节已传输且套接字准备就绪。</p>
<p>例如:</p>
<div class="highlight"><pre><span></span><code><span class="o">...</span>
<span class="c1"># 写入字节数据</span>
<span class="n">writer</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">byte_data</span><span class="p">)</span>
<span class="c1"># 等待数据传输</span>
<span class="k">await</span> <span class="n">writer</span><span class="o">.</span><span class="n">drain</span><span class="p">()</span>
</code></pre></div>
</div>
</div>
</div>
<h3 id="205-如何使用-streamreader-读取数据">20.5 如何使用 StreamReader 读取数据<a class="headerlink" href="#205-如何使用-streamreader-读取数据" title="Permanent link">&para;</a></h3>
<p><strong>20.5 How to Read Data with the StreamReader</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="119:2"><input checked="checked" id="__tabbed_119_1" name="__tabbed_119" type="radio" /><input id="__tabbed_119_2" name="__tabbed_119" type="radio" /><div class="tabbed-labels"><label for="__tabbed_119_1">English</label><label for="__tabbed_119_2">Chinese</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<p>We can read data from the socket using an <a href="https://docs.python.org/3/library/asyncio-stream.html#streamreader">asyncio.StreamReader</a>.</p>
<blockquote>
<p>Represents a reader object that provides APIs to read data from the IO stream.</p>
<p>— <a href="https://docs.python.org/3/library/asyncio-stream.html">ASYNCIO STREAMS</a></p>
</blockquote>
<p>Data is read in byte format, therefore strings may need to be encoded before being used.</p>
<p>All read methods are coroutines that must be awaited.</p>
<p>An arbitrary number of bytes can be read via the read() method, which will read until the end of file (EOF).</p>
<div class="highlight"><pre><span></span><code><span class="o">...</span>
<span class="c1"># read byte data</span>
<span class="n">byte_data</span> <span class="o">=</span> <span class="k">await</span> <span class="n">reader</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
</code></pre></div>
<p>Additionally, the number of bytes to read can be specified via the “n” argument.</p>
<blockquote>
<p>Read up to n bytes. If n is not provided, or set to -1, read until EOF and return all read bytes.</p>
<p>— <a href="https://docs.python.org/3/library/asyncio-stream.html">ASYNCIO STREAMS</a></p>
</blockquote>
<p>This may be helpful if you know the number of bytes expected from the next response.</p>
<p>For example:</p>
<div class="highlight"><pre><span></span><code><span class="o">...</span>
<span class="c1"># read byte data</span>
<span class="n">byte_data</span> <span class="o">=</span> <span class="k">await</span> <span class="n">reader</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>
</code></pre></div>
<p>A single line of data can be read using the readline() method.</p>
<p>This will return bytes until a new line character ‘\n’ is encountered, or EOF.</p>
<blockquote>
<p>Read one line, where “line” is a sequence of bytes ending with \n. If EOF is received and \n was not found, the method returns partially read data. If EOF is received and the internal buffer is empty, return an empty bytes object.</p>
<p>— <a href="https://docs.python.org/3/library/asyncio-stream.html">ASYNCIO STREAMS</a></p>
</blockquote>
<p>This is helpful when reading standard protocols that operate with lines of text.</p>
<div class="highlight"><pre><span></span><code><span class="o">...</span>
<span class="c1"># read a line data</span>
<span class="n">byte_line</span> <span class="o">=</span> <span class="k">await</span> <span class="n">reader</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>
</code></pre></div>
<p>Additionally, there is a readexactly() method to read an exact number of bytes otherwise raise an exception, and a readuntil() that will read bytes until a specified character in byte form is read.</p>
</div>
<div class="tabbed-block">
<p>我们可以使用 <a href="https://docs.python.org/3/library/asyncio-stream.html#streamreader">asyncio.StreamReader</a> 从套接字读取数据。</p>
<blockquote>
<p>表示一个读取器对象，它提供 API 以从 IO 流读取数据。</p>
<p>— <a href="https://docs.python.org/3/library/asyncio-stream.html">ASYNCIO STREAMS</a></p>
</blockquote>
<p>数据以字节格式读取，因此字符串在使用之前可能需要进行编码。</p>
<p>所有读取方法都是必须等待的协程。</p>
<p>可以通过 <strong>read()</strong> 方法读取任意数量的字节，该方法将读取到文件末尾 (EOF)。</p>
<div class="highlight"><pre><span></span><code><span class="o">...</span>
<span class="c1"># 读取字节数据</span>
<span class="n">byte_data</span> <span class="o">=</span> <span class="k">await</span> <span class="n">reader</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
</code></pre></div>
<p>此外，可以通过“n”参数指定要读取的字节数。</p>
<blockquote>
<p>最多读取 n 个字节。 如果未提供 n 或设置为 -1，则读取直到 EOF 并返回所有读取的字节。</p>
<p>— <a href="https://docs.python.org/3/library/asyncio-stream.html">ASYNCIO STREAMS</a></p>
</blockquote>
<p>如果您知道下一个响应的预期字节数，这可能会有所帮助。</p>
<p>例如:</p>
<div class="highlight"><pre><span></span><code><span class="o">...</span>
<span class="c1"># 读取字节数据</span>
<span class="n">byte_data</span> <span class="o">=</span> <span class="k">await</span> <span class="n">reader</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>
</code></pre></div>
<p>可以使用 <strong>readline()</strong> 方法读取单行数据。</p>
<p>这将返回字节，直到遇到新行字符“\n”或 EOF。</p>
<blockquote>
<p>读取一行，其中“line”是以\n结尾的字节序列。 如果收到 EOF 但未找到 \n，则该方法返回部分读取的数据。 如果收到 EOF 并且内部缓冲区为空，则返回一个空字节对象。</p>
<p>— <a href="https://docs.python.org/3/library/asyncio-stream.html">ASYNCIO STREAMS</a></p>
</blockquote>
<p>这在阅读使用文本行操作的标准协议时很有帮助。</p>
<div class="highlight"><pre><span></span><code><span class="o">...</span>
<span class="c1"># 读取一行数据</span>
<span class="n">byte_line</span> <span class="o">=</span> <span class="k">await</span> <span class="n">reader</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>
</code></pre></div>
<p>此外，还有一个 <strong>readexactly()</strong> 方法用于读取确切的字节数，否则会引发异常，还有一个 <strong>readuntil()</strong> 方法将读取字节，直到读取字节形式的指定字符。</p>
</div>
</div>
</div>
<h3 id="206-如何关闭连接">20.6 如何关闭连接<a class="headerlink" href="#206-如何关闭连接" title="Permanent link">&para;</a></h3>
<p><strong>20.6 How to Close Connection</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="120:2"><input checked="checked" id="__tabbed_120_1" name="__tabbed_120" type="radio" /><input id="__tabbed_120_2" name="__tabbed_120" type="radio" /><div class="tabbed-labels"><label for="__tabbed_120_1">English</label><label for="__tabbed_120_2">Chinese</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<p>The socket can be closed via the asyncio.StreamWriter.</p>
<p>The close() method can be called which will close the socket.</p>
<blockquote>
<p>The method closes the stream and the underlying socket.</p>
<p>— <a href="https://docs.python.org/3/library/asyncio-stream.html">ASYNCIO STREAMS</a></p>
</blockquote>
<p>This method does not block.</p>
<p>For example:</p>
<div class="highlight"><pre><span></span><code><span class="o">...</span>
<span class="c1"># close the socket</span>
<span class="n">writer</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</code></pre></div>
<p>Although the close() method does not block, we can wait for the socket to close completely before continuing on.</p>
<p>This can be achieved via the wait_closed() method.</p>
<blockquote>
<p>Wait until the stream is closed. Should be called after close() to wait until the underlying connection is closed.</p>
<p>— <a href="https://docs.python.org/3/library/asyncio-stream.html">ASYNCIO STREAMS</a></p>
</blockquote>
<p>This is a coroutine that can be awaited.</p>
<p>For example:</p>
<div class="highlight"><pre><span></span><code><span class="o">...</span>
<span class="c1"># close the socket</span>
<span class="n">writer</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
<span class="c1"># wait for the socket to close</span>
<span class="k">await</span> <span class="n">writer</span><span class="o">.</span><span class="n">wait_closed</span><span class="p">()</span>
</code></pre></div>
<p>We can check if the socket has been closed or is in the process of being closed via the is_closing() method.</p>
<p>For example:</p>
<div class="highlight"><pre><span></span><code><span class="o">...</span>
<span class="c1"># check if the socket is closed or closing</span>
<span class="k">if</span> <span class="n">writer</span><span class="o">.</span><span class="n">is_closing</span><span class="p">():</span>
    <span class="c1"># ...</span>
</code></pre></div>
</div>
<div class="tabbed-block">
<p>可以通过 <strong>asyncio.StreamWriter</strong> 关闭套接字。</p>
<p>可以调用 <strong>close()</strong> 方法来关闭套接字。</p>
<blockquote>
<p>该方法关闭流和底层套接字。</p>
<p>— <a href="https://docs.python.org/3/library/asyncio-stream.html">ASYNCIO STREAMS</a></p>
</blockquote>
<p>该方法不会阻塞。</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code><span class="o">...</span>
<span class="c1"># 关闭套接字</span>
<span class="n">writer</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</code></pre></div>
<p>虽然 <strong>close()</strong> 方法不会阻塞，但我们可以等待套接字完全关闭后再继续。</p>
<p>这可以通过 <strong>wait_close()</strong> 方法来实现。</p>
<blockquote>
<p>等待流关闭。 应在 <strong>close()</strong> 之后调用以等待底层连接关闭。</p>
<p>— <a href="https://docs.python.org/3/library/asyncio-stream.html">ASYNCIO STREAMS</a></p>
</blockquote>
<p>这是一个可以等待的协程。</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code><span class="o">...</span>
<span class="c1"># 关闭套接字</span>
<span class="n">writer</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
<span class="c1"># 等待套接字关闭</span>
<span class="k">await</span> <span class="n">writer</span><span class="o">.</span><span class="n">wait_closed</span><span class="p">()</span>
</code></pre></div>
<p>我们可以通过 <strong>is_close()</strong> 方法检查套接字是否已关闭或正在关闭过程中。</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code><span class="o">...</span>
<span class="c1"># 检查套接字是否已关闭或正在关闭</span>
<span class="k">if</span> <span class="n">writer</span><span class="o">.</span><span class="n">is_closing</span><span class="p">():</span>
    <span class="c1"># ...</span>
</code></pre></div>
</div>
</div>
</div>
<h2 id="21-检查网站状态的示例">21. 检查网站状态的示例<a class="headerlink" href="#21-检查网站状态的示例" title="Permanent link">&para;</a></h2>
<p><strong>21. Example of Checking Website Status</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="121:2"><input checked="checked" id="__tabbed_121_1" name="__tabbed_121" type="radio" /><input id="__tabbed_121_2" name="__tabbed_121" type="radio" /><div class="tabbed-labels"><label for="__tabbed_121_1">English</label><label for="__tabbed_121_2">Chinese</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<p>We can query the HTTP status of websites using asyncio by opening a stream and writing and reading HTTP requests and responses.</p>
<p>We can then use asyncio to query the status of many websites concurrently, and even report the results dynamically.</p>
<p>Let’s get started.</p>
</div>
<div class="tabbed-block">
<p>我们可以使用 asyncio 通过打开流并写入和读取 HTTP 请求和响应来查询网站的 HTTP 状态。</p>
<p>然后我们可以使用 asyncio 同时查询多个网站的状态，甚至动态报告结果。</p>
<p>让我们开始吧。</p>
</div>
</div>
</div>
<h3 id="211-如何使用-asyncio-检查-http-状态">21.1 如何使用 Asyncio 检查 HTTP 状态<a class="headerlink" href="#211-如何使用-asyncio-检查-http-状态" title="Permanent link">&para;</a></h3>
<p><strong>21.1 How to Check HTTP Status with Asyncio</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="122:2"><input checked="checked" id="__tabbed_122_1" name="__tabbed_122" type="radio" /><input id="__tabbed_122_2" name="__tabbed_122" type="radio" /><div class="tabbed-labels"><label for="__tabbed_122_1">English</label><label for="__tabbed_122_2">Chinese</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<p>The asyncio module provides support for opening socket connections and reading and writing data via streams.</p>
<p>We can use this capability to check the status of web pages.</p>
<p>This involves perhaps four steps, they are:</p>
<ol>
<li>Open a connection</li>
<li>Write a request</li>
<li>Read a response</li>
<li>Close the connection</li>
</ol>
<p>Let’s take a closer look at each part in turn.</p>
</div>
<div class="tabbed-block">
<p>asyncio 模块提供对打开套接字连接以及通过流读写数据的支持。</p>
<p>我们可以使用此功能来检查网页的状态。</p>
<p>这可能涉及四个步骤，它们是：</p>
<ol>
<li>打开连接</li>
<li>写一个请求</li>
<li>读一个响应</li>
<li>关闭连接</li>
</ol>
<p>让我们依次仔细看看每个部分。</p>
</div>
</div>
</div>
<h3 id="212-打开-http-连接">21.2 打开 HTTP 连接<a class="headerlink" href="#212-打开-http-连接" title="Permanent link">&para;</a></h3>
<p><strong>21.2 Open HTTP Connection</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="123:2"><input checked="checked" id="__tabbed_123_1" name="__tabbed_123" type="radio" /><input id="__tabbed_123_2" name="__tabbed_123" type="radio" /><div class="tabbed-labels"><label for="__tabbed_123_1">English</label><label for="__tabbed_123_2">Chinese</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<p>A connection can be opened in asyncio using the <a href="https://docs.python.org/3/library/asyncio-stream.html#asyncio.open_connection">asyncio.open_connection()</a> function.</p>
<p>Among many arguments, the function takes the string hostname and integer port number</p>
<p>This is a coroutine that must be awaited and returns a StreamReader and a StreamWriter for reading and writing with the socket.</p>
<p>This can be used to open an HTTP connection on port 80.</p>
<p>For example:</p>
<div class="highlight"><pre><span></span><code><span class="o">...</span>
<span class="c1"># open a socket connection</span>
<span class="n">reader</span><span class="p">,</span> <span class="n">writer</span> <span class="o">=</span> <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">open_connection</span><span class="p">(</span><span class="s1">&#39;www.google.com&#39;</span><span class="p">,</span> <span class="mi">80</span><span class="p">)</span>
</code></pre></div>
<p>We can also open an SSL connection using the <strong>ssl=True</strong> argument. This can be used to open an HTTPS connection on port 443.</p>
<p>For example:</p>
<div class="highlight"><pre><span></span><code><span class="o">...</span>
<span class="c1"># open a socket connection</span>
<span class="n">reader</span><span class="p">,</span> <span class="n">writer</span> <span class="o">=</span> <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">open_connection</span><span class="p">(</span><span class="s1">&#39;www.google.com&#39;</span><span class="p">,</span> <span class="mi">443</span><span class="p">,</span> <span class="n">ssl</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</code></pre></div>
</div>
<div class="tabbed-block">
<p>可以使用 <a href="https://docs.python.org/3/library/asyncio-stream.html#asyncio.open_connection">asyncio.open_connection()</a> 函数在 asyncio 中打开连接。</p>
<p>在许多参数中，该函数采用字符串主机名和整数端口号</p>
<p>这是一个必须等待的协程，并返回一个 <strong>StreamReader</strong> 和一个 <strong>StreamWriter</strong>，用于使用套接字进行读写。</p>
<p>这可用于在端口 80 上打开 HTTP 连接。</p>
<p>例如:</p>
<div class="highlight"><pre><span></span><code><span class="o">...</span>
<span class="c1"># 打开套接字连接</span>
<span class="n">reader</span><span class="p">,</span> <span class="n">writer</span> <span class="o">=</span> <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">open_connection</span><span class="p">(</span><span class="s1">&#39;www.google.com&#39;</span><span class="p">,</span> <span class="mi">80</span><span class="p">)</span>
</code></pre></div>
<p>我们还可以使用 <strong>ssl=True</strong> 参数打开 SSL 连接。 这可用于在端口 443 上打开 HTTPS 连接。</p>
<p>例如:</p>
<div class="highlight"><pre><span></span><code><span class="o">...</span>
<span class="c1"># 打开套接字连接</span>
<span class="n">reader</span><span class="p">,</span> <span class="n">writer</span> <span class="o">=</span> <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">open_connection</span><span class="p">(</span><span class="s1">&#39;www.google.com&#39;</span><span class="p">,</span> <span class="mi">443</span><span class="p">,</span> <span class="n">ssl</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</code></pre></div>
</div>
</div>
</div>
<h3 id="213-写入-http-请求">21.3 写入 HTTP 请求<a class="headerlink" href="#213-写入-http-请求" title="Permanent link">&para;</a></h3>
<p><strong>21.3 Write HTTP Request</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="124:2"><input checked="checked" id="__tabbed_124_1" name="__tabbed_124" type="radio" /><input id="__tabbed_124_2" name="__tabbed_124" type="radio" /><div class="tabbed-labels"><label for="__tabbed_124_1">English</label><label for="__tabbed_124_2">Chinese</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<p>Once open, we can write a query to the <strong>StreamWriter</strong> to make an HTTP request.</p>
<p>For example, an <a href="https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol">HTTP version 1.1 request</a> is in plain text. We can request the file path ‘/’, which may look as follows:</p>
<div class="highlight"><pre><span></span><code><span class="n">GET</span> <span class="o">/</span> <span class="n">HTTP</span><span class="o">/</span><span class="mf">1.1</span>
<span class="n">Host</span><span class="p">:</span> <span class="n">www</span><span class="o">.</span><span class="n">google</span><span class="o">.</span><span class="n">com</span>
</code></pre></div>
<p>Importantly, there must be a carriage return and a line feed (\r\n) at the end of each line, and an empty line at the end.</p>
<p>As Python strings this may look as follows:</p>
<div class="highlight"><pre><span></span><code><span class="s1">&#39;GET / HTTP/1.1</span><span class="se">\r\n</span><span class="s1">&#39;</span>
<span class="s1">&#39;Host: www.google.com</span><span class="se">\r\n</span><span class="s1">&#39;</span>
<span class="s1">&#39;</span><span class="se">\r\n</span><span class="s1">&#39;</span>
</code></pre></div>
<p>You can learn more about HTTP v1.1 request messages here:</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol#HTTP/1.1_request_messages">HTTP/1.1 request messages</a></li>
</ul>
<p>This string must be encoded as bytes before being written to the <a href="https://docs.python.org/3/library/asyncio-stream.html#streamwriter">StreamWriter</a>.</p>
<p>This can be achieved using the <a href="https://docs.python.org/3/library/stdtypes.html#str.encode">encode()</a> method on the string itself.</p>
<p>The default ‘<strong>utf-8</strong>‘ encoding may be sufficient.</p>
<p>For example:</p>
<div class="highlight"><pre><span></span><code><span class="o">...</span>
<span class="c1"># encode string as bytes</span>
<span class="n">byte_data</span> <span class="o">=</span> <span class="n">string</span><span class="o">.</span><span class="n">encode</span><span class="p">()</span>
</code></pre></div>
<p>You can see a listing of encodings here:</p>
<ul>
<li><a href="https://docs.python.org/3/library/codecs.html#standard-encodings">Python Standard Encodings</a></li>
</ul>
<p>The bytes can then be written to the socket via the <strong>StreamWriter</strong> via the <a href="https://docs.python.org/3/library/asyncio-stream.html#asyncio.StreamWriter.write">write()</a> method.</p>
<p>For example:</p>
<div class="highlight"><pre><span></span><code><span class="o">...</span>
<span class="c1"># encode string as bytes</span>
<span class="n">byte_data</span> <span class="o">=</span> <span class="n">string</span><span class="o">.</span><span class="n">encode</span><span class="p">()</span>
</code></pre></div>
<p>You can see a listing of encodings here:</p>
<ul>
<li><a href="https://docs.python.org/3/library/codecs.html#standard-encodings">Python Standard Encodings</a></li>
</ul>
<p>The bytes can then be written to the socket via the <strong>StreamWriter</strong> via the <a href="https://docs.python.org/3/library/asyncio-stream.html#asyncio.StreamWriter.write">write()</a> method.</p>
<p>For example:</p>
<div class="highlight"><pre><span></span><code><span class="o">...</span>
<span class="c1"># write query to socket</span>
<span class="n">writer</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">byte_data</span><span class="p">)</span>
</code></pre></div>
<p>After writing the request, it is a good idea to wait for the byte data to be sent and for the socket to be ready.</p>
<p>This can be achieved by the <strong>drain()</strong> method.</p>
<p>This is a coroutine that must be awaited.</p>
<p>For example:</p>
<div class="highlight"><pre><span></span><code><span class="o">...</span>
<span class="c1"># wait for the socket to be ready.</span>
<span class="k">await</span> <span class="n">writer</span><span class="o">.</span><span class="n">drain</span><span class="p">()</span>
</code></pre></div>
</div>
<div class="tabbed-block">
<p>打开后，我们可以向 <strong>StreamWriter</strong> 写入查询以发出 HTTP 请求。</p>
<p>例如，<a href="https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol">HTTP 版本 1.1 请求</a> 是纯文本形式。 我们可以请求文件路径“/”，如下所示：</p>
<div class="highlight"><pre><span></span><code><span class="n">GET</span> <span class="o">/</span> <span class="n">HTTP</span><span class="o">/</span><span class="mf">1.1</span>
<span class="n">Host</span><span class="p">:</span> <span class="n">www</span><span class="o">.</span><span class="n">google</span><span class="o">.</span><span class="n">com</span>
</code></pre></div>
<p>重要的是，每行末尾必须有回车符和换行符（\r\n），并且末尾有一个空行。</p>
<p>作为 Python 字符串，这可能如下所示：</p>
<div class="highlight"><pre><span></span><code><span class="s1">&#39;GET / HTTP/1.1</span><span class="se">\r\n</span><span class="s1">&#39;</span>
<span class="s1">&#39;Host: www.google.com</span><span class="se">\r\n</span><span class="s1">&#39;</span>
<span class="s1">&#39;</span><span class="se">\r\n</span><span class="s1">&#39;</span>
</code></pre></div>
<p>您可以在此处了解有关 HTTP v1.1 请求消息的更多信息：</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol#HTTP/1.1_request_messages">HTTP/1.1 请求消息</a></li>
</ul>
<p>在写入 <a href="https://docs.python.org/3/library/asyncio-stream.html#streamwriter">StreamWriter</a> 之前，必须将该字符串编码为字节。</p>
<p>这可以通过对字符串本身使用 <a href="https://docs.python.org/3/library/stdtypes.html#str.encode">encode()</a> 方法来实现。</p>
<p>默认的“<strong>utf-8</strong>”编码可能就足够了。</p>
<p>例如:</p>
<div class="highlight"><pre><span></span><code><span class="o">...</span>
<span class="c1"># 将字符串编码为字节</span>
<span class="n">byte_data</span> <span class="o">=</span> <span class="n">string</span><span class="o">.</span><span class="n">encode</span><span class="p">()</span>
</code></pre></div>
<p>您可以在此处查看编码列表：</p>
<ul>
<li><a href="https://docs.python.org/3/library/codecs.html#standard-encodings">Python 标准编码</a></li>
</ul>
<p>然后可以通过 <strong>StreamWriter</strong> 通过 <a href="https://docs.python.org/3/library/asyncio-stream.html#asyncio.StreamWriter.write">write()</a> 将字节写入套接字 方法。</p>
<p>例如:</p>
<div class="highlight"><pre><span></span><code><span class="o">...</span>
<span class="c1"># 将查询写入套接字</span>
<span class="n">writer</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">byte_data</span><span class="p">)</span>
</code></pre></div>
<p>写入请求后，最好等待字节数据发送和套接字准备就绪。</p>
<p>这可以通过 <strong>drain()</strong> 方法来实现。</p>
<p>这是一个必须等待的协程。</p>
<p>例如:</p>
<div class="highlight"><pre><span></span><code><span class="o">...</span>
<span class="c1"># 等待套接字准备好。</span>
<span class="k">await</span> <span class="n">writer</span><span class="o">.</span><span class="n">drain</span><span class="p">()</span>
</code></pre></div>
</div>
</div>
</div>
<h3 id="214-读取-http-响应">21.4 读取 HTTP 响应<a class="headerlink" href="#214-读取-http-响应" title="Permanent link">&para;</a></h3>
<p><strong>21.4 Read HTTP Response</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="125:2"><input checked="checked" id="__tabbed_125_1" name="__tabbed_125" type="radio" /><input id="__tabbed_125_2" name="__tabbed_125" type="radio" /><div class="tabbed-labels"><label for="__tabbed_125_1">English</label><label for="__tabbed_125_2">Chinese</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<p>Once the HTTP request has been made, we can read the response.</p>
<p>This can be achieved via the <a href="https://docs.python.org/3/library/asyncio-stream.html#streamreader">StreamReader</a> for the socket.</p>
<p>The response can be read using the <strong>read()</strong> method which will read a chunk of bytes, or the <strong>readline()</strong> method which will read one line of bytes.</p>
<p>We might prefer the <strong>readline()</strong> method because we are using the text-based HTTP protocol which sends HTML data one line at a time.</p>
<p>The <strong>readline()</strong> method is a coroutine and must be awaited.</p>
<p>For example:</p>
<div class="highlight"><pre><span></span><code><span class="o">...</span>
<span class="c1"># read one line of response</span>
<span class="n">line_bytes</span> <span class="o">=</span> <span class="k">await</span> <span class="n">reader</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>
</code></pre></div>
<p><a href="https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol#HTTP/1.1_response_messages">HTTP 1.1 responses</a> are composed of two parts, a header separated by an empty line, then the body terminating with an empty line.</p>
<p>The header has information about whether the request was successful and what type of file will be sent, and the body contains the content of the file, such as an HTML webpage.</p>
<p>The first line of the HTTP header contains the HTTP status for the requested page on the server.</p>
<p>You can learn more about HTTP v1.1 responses here:</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol#HTTP/1.1_response_messages">HTTP/1.1 response messages</a></li>
</ul>
<p>Each line must be decoded from bytes into a string.</p>
<p>This can be achieved using the <a href="https://docs.python.org/3/library/stdtypes.html#bytes.decode">decode()</a> method on the byte data. Again, the default encoding is ‘<strong>utf_8</strong>‘.</p>
<p>For example:</p>
<div class="highlight"><pre><span></span><code><span class="o">...</span>
<span class="c1"># decode bytes into a string</span>
<span class="n">line_data</span> <span class="o">=</span> <span class="n">line_bytes</span><span class="o">.</span><span class="n">decode</span><span class="p">()</span>
</code></pre></div>
</div>
<div class="tabbed-block">
<p>一旦发出 HTTP 请求，我们就可以读取响应。</p>
<p>这可以通过套接字的 <a href="https://docs.python.org/3/library/asyncio-stream.html#streamreader">StreamReader</a> 来实现。</p>
<p>可以使用 <strong>read()</strong> 方法读取响应，该方法将读取一大块字节，或者使用 <strong>readline()</strong> 方法读取一行字节。</p>
<p>我们可能更喜欢 <strong>readline()</strong> 方法，因为我们使用基于文本的 HTTP 协议，它一次发送一行 HTML 数据。</p>
<p><strong>readline()</strong> 方法是一个协程，必须等待。</p>
<p>例如:</p>
<div class="highlight"><pre><span></span><code><span class="o">...</span>
<span class="c1"># 读取一行响应</span>
<span class="n">line_bytes</span> <span class="o">=</span> <span class="k">await</span> <span class="n">reader</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>
</code></pre></div>
<p><a href="https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol#HTTP/1.1_response_messages">HTTP 1.1 响应</a> 由两部分组成，一个由空行分隔的标头，然后是由空行终止的正文。</p>
<p>header 包含有关请求是否成功以及将发送什么类型的文件的信息，body 包含文件的内容，例如 HTML 网页。</p>
<p>HTTP 标头的第一行包含服务器上所请求页面的 HTTP 状态。</p>
<p>您可以在此处了解有关 HTTP v1.1 响应的更多信息：</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol#HTTP/1.1_response_messages">HTTP/1.1 响应消息</a></li>
</ul>
<p>每一行都必须从字节解码为字符串。</p>
<p>这可以通过对字节数据使用 <a href="https://docs.python.org/3/library/stdtypes.html#bytes.decode">decode()</a> 方法来实现。 同样，默认编码是“<strong>utf_8</strong>”。</p>
<p>例如:</p>
<div class="highlight"><pre><span></span><code><span class="o">...</span>
<span class="c1"># 将字节解码为字符串</span>
<span class="n">line_data</span> <span class="o">=</span> <span class="n">line_bytes</span><span class="o">.</span><span class="n">decode</span><span class="p">()</span>
</code></pre></div>
</div>
</div>
</div>
<h3 id="215-关闭-http-连接">21.5 关闭 HTTP 连接<a class="headerlink" href="#215-关闭-http-连接" title="Permanent link">&para;</a></h3>
<p><strong>21.5 Close HTTP Connection</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="126:2"><input checked="checked" id="__tabbed_126_1" name="__tabbed_126" type="radio" /><input id="__tabbed_126_2" name="__tabbed_126" type="radio" /><div class="tabbed-labels"><label for="__tabbed_126_1">English</label><label for="__tabbed_126_2">Chinese</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<p>We can close the socket connection by closing the <strong>StreamWriter</strong>.</p>
<p>This can be achieved by calling the <a href="https://docs.python.org/3/library/asyncio-stream.html#asyncio.StreamWriter.close">close()</a> method.</p>
<p>For example:</p>
<div class="highlight"><pre><span></span><code><span class="o">...</span>
<span class="c1"># close the connection</span>
<span class="n">writer</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</code></pre></div>
<p>This does not block and may not close the socket immediately.</p>
<p>Now that we know how to make HTTP requests and read responses using <strong>asyncio</strong>, let’s look at some worked examples of checking web page statuses.</p>
</div>
<div class="tabbed-block">
<p>我们可以通过关闭 <strong>StreamWriter</strong> 来关闭套接字连接。</p>
<p>这可以通过调用 <a href="https://docs.python.org/3/library/asyncio-stream.html#asyncio.StreamWriter.close">close()</a> 方法来实现。</p>
<p>例如:</p>
<div class="highlight"><pre><span></span><code><span class="o">...</span>
<span class="c1"># 关闭连接</span>
<span class="n">writer</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</code></pre></div>
<p>这不会阻塞并且可能不会立即关闭套接字。</p>
<p>现在我们知道如何使用 <strong>asyncio</strong> 发出 HTTP 请求并读取响应，让我们看一些检查网页状态的示例。</p>
</div>
</div>
</div>
<h3 id="216-按顺序检查-http-状态的示例">21.6 按顺序检查 HTTP 状态的示例<a class="headerlink" href="#216-按顺序检查-http-状态的示例" title="Permanent link">&para;</a></h3>
<p><strong>21.6 Example of Checking HTTP Status Sequentially</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="127:2"><input checked="checked" id="__tabbed_127_1" name="__tabbed_127" type="radio" /><input id="__tabbed_127_2" name="__tabbed_127" type="radio" /><div class="tabbed-labels"><label for="__tabbed_127_1">English</label><label for="__tabbed_127_2">Chinese</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<p>We can develop an example to check the HTTP status for multiple websites using asyncio.</p>
<p>In this example, we will first develop a coroutine that will check the status of a given URL. We will then call this coroutine once for each of the top 10 websites.</p>
<p>Firstly, we can define a coroutine that will take a URL string and return the HTTP status.</p>
<div class="highlight"><pre><span></span><code><span class="c1"># get the HTTP/S status of a webpage</span>
<span class="k">async</span> <span class="k">def</span> <span class="nf">get_status</span><span class="p">(</span><span class="n">url</span><span class="p">):</span>
    <span class="c1"># ...</span>
</code></pre></div>
<p>The URL must be parsed into its constituent components.</p>
<p>We require the hostname and file path when making the HTTP request. We also need to know the URL scheme (HTTP or HTTPS) in order to determine whether SSL is required nor not.</p>
<p>This can be achieved using the <a href="https://docs.python.org/3/library/urllib.parse.html">urllib.parse.urlsplit()</a> function that takes a URL string and returns a named tuple of all the URL elements.</p>
<div class="highlight"><pre><span></span><code><span class="o">...</span>
<span class="c1"># split the url into components</span>
<span class="n">url_parsed</span> <span class="o">=</span> <span class="n">urlsplit</span><span class="p">(</span><span class="n">url</span><span class="p">)</span>
</code></pre></div>
<p>We can then open the HTTP connection based on the URL scheme and use the URL hostname.</p>
<div class="highlight"><pre><span></span><code><span class="o">...</span>
<span class="c1"># open the connection</span>
<span class="k">if</span> <span class="n">url_parsed</span><span class="o">.</span><span class="n">scheme</span> <span class="o">==</span> <span class="s1">&#39;https&#39;</span><span class="p">:</span>
    <span class="n">reader</span><span class="p">,</span> <span class="n">writer</span> <span class="o">=</span> <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">open_connection</span><span class="p">(</span><span class="n">url_parsed</span><span class="o">.</span><span class="n">hostname</span><span class="p">,</span> <span class="mi">443</span><span class="p">,</span> <span class="n">ssl</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">else</span><span class="p">:</span>
    <span class="n">reader</span><span class="p">,</span> <span class="n">writer</span> <span class="o">=</span> <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">open_connection</span><span class="p">(</span><span class="n">url_parsed</span><span class="o">.</span><span class="n">hostname</span><span class="p">,</span> <span class="mi">80</span><span class="p">)</span>
</code></pre></div>
<p>Next, we can create the HTTP GET request using the hostname and file path and write the encoded bytes to the socket using the StreamWriter.</p>
<div class="highlight"><pre><span></span><code><span class="o">...</span>
<span class="c1"># send GET request</span>
<span class="n">query</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;GET </span><span class="si">{</span><span class="n">url_parsed</span><span class="o">.</span><span class="n">path</span><span class="si">}</span><span class="s1"> HTTP/1.1</span><span class="se">\r\n</span><span class="s1">Host: </span><span class="si">{</span><span class="n">url_parsed</span><span class="o">.</span><span class="n">hostname</span><span class="si">}</span><span class="se">\r\n\r\n</span><span class="s1">&#39;</span>
<span class="c1"># write query to socket</span>
<span class="n">writer</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">query</span><span class="o">.</span><span class="n">encode</span><span class="p">())</span>
<span class="c1"># wait for the bytes to be written to the socket</span>
<span class="k">await</span> <span class="n">writer</span><span class="o">.</span><span class="n">drain</span><span class="p">()</span>
</code></pre></div>
<p>Next, we can read the HTTP response.</p>
<p>We only require the first line of the response that contains the HTTP status.</p>
<div class="highlight"><pre><span></span><code><span class="o">...</span>
<span class="c1"># read the single line response</span>
<span class="n">response</span> <span class="o">=</span> <span class="k">await</span> <span class="n">reader</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>
</code></pre></div>
<p>The connection can then be closed.</p>
<div class="highlight"><pre><span></span><code><span class="o">...</span>
<span class="c1"># close the connection</span>
<span class="n">writer</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</code></pre></div>
<p>Finally, we can decode the bytes read from the server, remote trailing white space, and return the HTTP status.</p>
<div class="highlight"><pre><span></span><code><span class="o">...</span>
<span class="c1"># decode and strip white space</span>
<span class="n">status</span> <span class="o">=</span> <span class="n">response</span><span class="o">.</span><span class="n">decode</span><span class="p">()</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
<span class="c1"># return the response</span>
<span class="k">return</span> <span class="n">status</span>
</code></pre></div>
<p>Tying this together, the complete get_status() coroutine is listed below.</p>
<p>It does not have any error handling, such as the case where the host cannot be reached or is slow to respond.</p>
<p>These additions would make a nice extension for the reader.</p>
<div class="highlight"><pre><span></span><code><span class="c1"># get the HTTP/S status of a webpage</span>
<span class="k">async</span> <span class="k">def</span> <span class="nf">get_status</span><span class="p">(</span><span class="n">url</span><span class="p">):</span>
    <span class="c1"># split the url into components</span>
    <span class="n">url_parsed</span> <span class="o">=</span> <span class="n">urlsplit</span><span class="p">(</span><span class="n">url</span><span class="p">)</span>
    <span class="c1"># open the connection</span>
    <span class="k">if</span> <span class="n">url_parsed</span><span class="o">.</span><span class="n">scheme</span> <span class="o">==</span> <span class="s1">&#39;https&#39;</span><span class="p">:</span>
        <span class="n">reader</span><span class="p">,</span> <span class="n">writer</span> <span class="o">=</span> <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">open_connection</span><span class="p">(</span><span class="n">url_parsed</span><span class="o">.</span><span class="n">hostname</span><span class="p">,</span> <span class="mi">443</span><span class="p">,</span> <span class="n">ssl</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">reader</span><span class="p">,</span> <span class="n">writer</span> <span class="o">=</span> <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">open_connection</span><span class="p">(</span><span class="n">url_parsed</span><span class="o">.</span><span class="n">hostname</span><span class="p">,</span> <span class="mi">80</span><span class="p">)</span>
    <span class="c1"># send GET request</span>
    <span class="n">query</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;GET </span><span class="si">{</span><span class="n">url_parsed</span><span class="o">.</span><span class="n">path</span><span class="si">}</span><span class="s1"> HTTP/1.1</span><span class="se">\r\n</span><span class="s1">Host: </span><span class="si">{</span><span class="n">url_parsed</span><span class="o">.</span><span class="n">hostname</span><span class="si">}</span><span class="se">\r\n\r\n</span><span class="s1">&#39;</span>
    <span class="c1"># write query to socket</span>
    <span class="n">writer</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">query</span><span class="o">.</span><span class="n">encode</span><span class="p">())</span>
    <span class="c1"># wait for the bytes to be written to the socket</span>
    <span class="k">await</span> <span class="n">writer</span><span class="o">.</span><span class="n">drain</span><span class="p">()</span>
    <span class="c1"># read the single line response</span>
    <span class="n">response</span> <span class="o">=</span> <span class="k">await</span> <span class="n">reader</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>
    <span class="c1"># close the connection</span>
    <span class="n">writer</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    <span class="c1"># decode and strip white space</span>
    <span class="n">status</span> <span class="o">=</span> <span class="n">response</span><span class="o">.</span><span class="n">decode</span><span class="p">()</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
    <span class="c1"># return the response</span>
    <span class="k">return</span> <span class="n">status</span>
</code></pre></div>
<p>Next, we can call the get_status() coroutine for multiple web pages or websites we want to check.</p>
<p>In this case, we will define a list of the top 10 web pages in the world.</p>
<div class="highlight"><pre><span></span><code><span class="o">...</span>
<span class="c1"># list of top 10 websites to check</span>
<span class="n">sites</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;https://www.google.com/&#39;</span><span class="p">,</span>
    <span class="s1">&#39;https://www.youtube.com/&#39;</span><span class="p">,</span>
    <span class="s1">&#39;https://www.facebook.com/&#39;</span><span class="p">,</span>
    <span class="s1">&#39;https://twitter.com/&#39;</span><span class="p">,</span>
    <span class="s1">&#39;https://www.instagram.com/&#39;</span><span class="p">,</span>
    <span class="s1">&#39;https://www.baidu.com/&#39;</span><span class="p">,</span>
    <span class="s1">&#39;https://www.wikipedia.org/&#39;</span><span class="p">,</span>
    <span class="s1">&#39;https://yandex.ru/&#39;</span><span class="p">,</span>
    <span class="s1">&#39;https://yahoo.com/&#39;</span><span class="p">,</span>
    <span class="s1">&#39;https://www.whatsapp.com/&#39;</span>
    <span class="p">]</span>
</code></pre></div>
<p>We can then query each, in turn, using our get_status() coroutine.</p>
<p>In this case, we will do so sequentially in a loop, and report the status of each in turn.</p>
<div class="highlight"><pre><span></span><code><span class="o">...</span>
<span class="c1"># check the status of all websites</span>
<span class="k">for</span> <span class="n">url</span> <span class="ow">in</span> <span class="n">sites</span><span class="p">:</span>
    <span class="c1"># get the status for the url</span>
    <span class="n">status</span> <span class="o">=</span> <span class="k">await</span> <span class="n">get_status</span><span class="p">(</span><span class="n">url</span><span class="p">)</span>
    <span class="c1"># report the url and its status</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">url</span><span class="si">:</span><span class="s1">30</span><span class="si">}</span><span class="s1">:</span><span class="se">\t</span><span class="si">{</span><span class="n">status</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
</code></pre></div>
<p>We can do better than sequential when using asyncio, but this provides a good starting point that we can improve upon later.</p>
<p>Tying this together, the main() coroutine queries the status of the top 10 websites.</p>
<div class="highlight"><pre><span></span><code><span class="c1"># main coroutine</span>
<span class="k">async</span> <span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="c1"># list of top 10 websites to check</span>
    <span class="n">sites</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;https://www.google.com/&#39;</span><span class="p">,</span>
        <span class="s1">&#39;https://www.youtube.com/&#39;</span><span class="p">,</span>
        <span class="s1">&#39;https://www.facebook.com/&#39;</span><span class="p">,</span>
        <span class="s1">&#39;https://twitter.com/&#39;</span><span class="p">,</span>
        <span class="s1">&#39;https://www.instagram.com/&#39;</span><span class="p">,</span>
        <span class="s1">&#39;https://www.baidu.com/&#39;</span><span class="p">,</span>
        <span class="s1">&#39;https://www.wikipedia.org/&#39;</span><span class="p">,</span>
        <span class="s1">&#39;https://yandex.ru/&#39;</span><span class="p">,</span>
        <span class="s1">&#39;https://yahoo.com/&#39;</span><span class="p">,</span>
        <span class="s1">&#39;https://www.whatsapp.com/&#39;</span>
        <span class="p">]</span>
    <span class="c1"># check the status of all websites</span>
    <span class="k">for</span> <span class="n">url</span> <span class="ow">in</span> <span class="n">sites</span><span class="p">:</span>
        <span class="c1"># get the status for the url</span>
        <span class="n">status</span> <span class="o">=</span> <span class="k">await</span> <span class="n">get_status</span><span class="p">(</span><span class="n">url</span><span class="p">)</span>
        <span class="c1"># report the url and its status</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">url</span><span class="si">:</span><span class="s1">30</span><span class="si">}</span><span class="s1">:</span><span class="se">\t</span><span class="si">{</span><span class="n">status</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
</code></pre></div>
<p>Finally, we can create the main() coroutine and use it as the entry point to the asyncio program.</p>
<div class="highlight"><pre><span></span><code><span class="o">...</span>
<span class="c1"># run the asyncio program</span>
<span class="n">asyncio</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">main</span><span class="p">())</span>
</code></pre></div>
<p>Tying this together, the complete example is listed below.</p>
<div class="highlight"><pre><span></span><code><span class="c1"># SuperFastPython.com</span>
<span class="c1"># check the status of many webpages</span>
<span class="kn">import</span> <span class="nn">asyncio</span>
<span class="kn">from</span> <span class="nn">urllib.parse</span> <span class="kn">import</span> <span class="n">urlsplit</span>

<span class="c1"># get the HTTP/S status of a webpage</span>
<span class="k">async</span> <span class="k">def</span> <span class="nf">get_status</span><span class="p">(</span><span class="n">url</span><span class="p">):</span>
    <span class="c1"># split the url into components</span>
    <span class="n">url_parsed</span> <span class="o">=</span> <span class="n">urlsplit</span><span class="p">(</span><span class="n">url</span><span class="p">)</span>
    <span class="c1"># open the connection</span>
    <span class="k">if</span> <span class="n">url_parsed</span><span class="o">.</span><span class="n">scheme</span> <span class="o">==</span> <span class="s1">&#39;https&#39;</span><span class="p">:</span>
        <span class="n">reader</span><span class="p">,</span> <span class="n">writer</span> <span class="o">=</span> <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">open_connection</span><span class="p">(</span><span class="n">url_parsed</span><span class="o">.</span><span class="n">hostname</span><span class="p">,</span> <span class="mi">443</span><span class="p">,</span> <span class="n">ssl</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">reader</span><span class="p">,</span> <span class="n">writer</span> <span class="o">=</span> <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">open_connection</span><span class="p">(</span><span class="n">url_parsed</span><span class="o">.</span><span class="n">hostname</span><span class="p">,</span> <span class="mi">80</span><span class="p">)</span>
    <span class="c1"># send GET request</span>
    <span class="n">query</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;GET </span><span class="si">{</span><span class="n">url_parsed</span><span class="o">.</span><span class="n">path</span><span class="si">}</span><span class="s1"> HTTP/1.1</span><span class="se">\r\n</span><span class="s1">Host: </span><span class="si">{</span><span class="n">url_parsed</span><span class="o">.</span><span class="n">hostname</span><span class="si">}</span><span class="se">\r\n\r\n</span><span class="s1">&#39;</span>
    <span class="c1"># write query to socket</span>
    <span class="n">writer</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">query</span><span class="o">.</span><span class="n">encode</span><span class="p">())</span>
    <span class="c1"># wait for the bytes to be written to the socket</span>
    <span class="k">await</span> <span class="n">writer</span><span class="o">.</span><span class="n">drain</span><span class="p">()</span>
    <span class="c1"># read the single line response</span>
    <span class="n">response</span> <span class="o">=</span> <span class="k">await</span> <span class="n">reader</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>
    <span class="c1"># close the connection</span>
    <span class="n">writer</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    <span class="c1"># decode and strip white space</span>
    <span class="n">status</span> <span class="o">=</span> <span class="n">response</span><span class="o">.</span><span class="n">decode</span><span class="p">()</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
    <span class="c1"># return the response</span>
    <span class="k">return</span> <span class="n">status</span>

<span class="c1"># main coroutine</span>
<span class="k">async</span> <span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="c1"># list of top 10 websites to check</span>
    <span class="n">sites</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;https://www.google.com/&#39;</span><span class="p">,</span>
        <span class="s1">&#39;https://www.youtube.com/&#39;</span><span class="p">,</span>
        <span class="s1">&#39;https://www.facebook.com/&#39;</span><span class="p">,</span>
        <span class="s1">&#39;https://twitter.com/&#39;</span><span class="p">,</span>
        <span class="s1">&#39;https://www.instagram.com/&#39;</span><span class="p">,</span>
        <span class="s1">&#39;https://www.baidu.com/&#39;</span><span class="p">,</span>
        <span class="s1">&#39;https://www.wikipedia.org/&#39;</span><span class="p">,</span>
        <span class="s1">&#39;https://yandex.ru/&#39;</span><span class="p">,</span>
        <span class="s1">&#39;https://yahoo.com/&#39;</span><span class="p">,</span>
        <span class="s1">&#39;https://www.whatsapp.com/&#39;</span>
        <span class="p">]</span>
    <span class="c1"># check the status of all websites</span>
    <span class="k">for</span> <span class="n">url</span> <span class="ow">in</span> <span class="n">sites</span><span class="p">:</span>
        <span class="c1"># get the status for the url</span>
        <span class="n">status</span> <span class="o">=</span> <span class="k">await</span> <span class="n">get_status</span><span class="p">(</span><span class="n">url</span><span class="p">)</span>
        <span class="c1"># report the url and its status</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">url</span><span class="si">:</span><span class="s1">30</span><span class="si">}</span><span class="s1">:</span><span class="se">\t</span><span class="si">{</span><span class="n">status</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

<span class="c1"># run the asyncio program</span>
<span class="n">asyncio</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">main</span><span class="p">())</span>
</code></pre></div>
<p>Running the example first creates the main() coroutine and uses it as the entry point into the program.</p>
<p>The main() coroutine runs, defining a list of the top 10 websites.</p>
<p>The list of websites is then traversed sequentially. The main() coroutine suspends and calls the get_status() coroutine to query the status of one website.</p>
<p>The get_status() coroutine runs, parses the URL, and opens a connection. It constructs an HTTP GET query and writes it to the host. A response is read, decoded, and returned.</p>
<p>The main() coroutine resumes and reports the HTTP status of the URL.</p>
<p>This is repeated for each URL in the list.</p>
<p>The program takes about 5.6 seconds to complete, or about half a second per URL on average.</p>
<p>This highlights how we can use asyncio to query the HTTP status of webpages.</p>
<p>Nevertheless, it does not take full advantage of the asyncio to execute tasks concurrently.</p>
<div class="highlight"><pre><span></span><code>https://www.google.com/       : HTTP/1.1 200 OK
https://www.youtube.com/      : HTTP/1.1 200 OK
https://www.facebook.com/     : HTTP/1.1 302 Found
https://twitter.com/          : HTTP/1.1 200 OK
https://www.instagram.com/    : HTTP/1.1 200 OK
https://www.baidu.com/        : HTTP/1.1 200 OK
https://www.wikipedia.org/    : HTTP/1.1 200 OK
https://yandex.ru/            : HTTP/1.1 302 Moved temporarily
https://yahoo.com/            : HTTP/1.1 301 Moved Permanently
https://www.whatsapp.com/     : HTTP/1.1 302 Found
</code></pre></div>
<p>Next, let’s look at how we might update the example to execute the coroutines concurrently.</p>
</div>
<div class="tabbed-block">
<p>我们可以开发一个示例来使用 asyncio 检查多个网站的 HTTP 状态。</p>
<p>在此示例中，我们将首先开发一个协程来检查给定 URL 的状态。 然后，我们将为前 10 个网站中的每个网站调用一次该协程。</p>
<p>首先，我们可以定义一个协程，它将接受 URL 字符串并返回 HTTP 状态。</p>
<div class="highlight"><pre><span></span><code><span class="c1"># 获取网页的 HTTP/S 状态</span>
<span class="k">async</span> <span class="k">def</span> <span class="nf">get_status</span><span class="p">(</span><span class="n">url</span><span class="p">):</span>
    <span class="c1"># ...</span>
</code></pre></div>
<p>URL 必须被解析为其组成部分。</p>
<p>发出 HTTP 请求时，我们需要主机名和文件路径。 我们还需要知道 URL 方案（HTTP 或 HTTPS），以便确定是否需要 SSL。</p>
<p>这可以使用 <a href="https://docs.python.org/3/library/urllib.parse.html">urllib.parse.urlsplit()</a> 函数来实现，该函数接受 URL 字符串并返回所有 URL 的命名元组。 网址元素。</p>
<div class="highlight"><pre><span></span><code><span class="o">...</span>
<span class="c1"># 将 url 拆分为多个部分</span>
<span class="n">url_parsed</span> <span class="o">=</span> <span class="n">urlsplit</span><span class="p">(</span><span class="n">url</span><span class="p">)</span>
</code></pre></div>
<p>然后我们可以根据 URL 方案打开 HTTP 连接并使用 URL 主机名。</p>
<div class="highlight"><pre><span></span><code><span class="o">...</span>
<span class="c1"># 打开连接</span>
<span class="k">if</span> <span class="n">url_parsed</span><span class="o">.</span><span class="n">scheme</span> <span class="o">==</span> <span class="s1">&#39;https&#39;</span><span class="p">:</span>
    <span class="n">reader</span><span class="p">,</span> <span class="n">writer</span> <span class="o">=</span> <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">open_connection</span><span class="p">(</span><span class="n">url_parsed</span><span class="o">.</span><span class="n">hostname</span><span class="p">,</span> <span class="mi">443</span><span class="p">,</span> <span class="n">ssl</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">else</span><span class="p">:</span>
    <span class="n">reader</span><span class="p">,</span> <span class="n">writer</span> <span class="o">=</span> <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">open_connection</span><span class="p">(</span><span class="n">url_parsed</span><span class="o">.</span><span class="n">hostname</span><span class="p">,</span> <span class="mi">80</span><span class="p">)</span>
</code></pre></div>
<p>接下来，我们可以使用主机名和文件路径创建 HTTP GET 请求，并使用 <strong>StreamWriter</strong> 将编码字节写入套接字。</p>
<div class="highlight"><pre><span></span><code><span class="o">...</span>
<span class="c1"># send GET request</span>
<span class="n">query</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;GET </span><span class="si">{</span><span class="n">url_parsed</span><span class="o">.</span><span class="n">path</span><span class="si">}</span><span class="s1"> HTTP/1.1</span><span class="se">\r\n</span><span class="s1">Host: </span><span class="si">{</span><span class="n">url_parsed</span><span class="o">.</span><span class="n">hostname</span><span class="si">}</span><span class="se">\r\n\r\n</span><span class="s1">&#39;</span>
<span class="c1"># write query to socket</span>
<span class="n">writer</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">query</span><span class="o">.</span><span class="n">encode</span><span class="p">())</span>
<span class="c1"># wait for the bytes to be written to the socket</span>
<span class="k">await</span> <span class="n">writer</span><span class="o">.</span><span class="n">drain</span><span class="p">()</span>
</code></pre></div>
<p>接下来，我们可以读取 HTTP 响应。</p>
<p>我们只需要包含 HTTP 状态的响应的第一行。</p>
<div class="highlight"><pre><span></span><code><span class="o">...</span>
<span class="c1"># 读取单行响应</span>
<span class="n">response</span> <span class="o">=</span> <span class="k">await</span> <span class="n">reader</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>
</code></pre></div>
<p>然后可以关闭连接。</p>
<div class="highlight"><pre><span></span><code><span class="o">...</span>
<span class="c1"># 关闭连接</span>
<span class="n">writer</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</code></pre></div>
<p>最后，我们可以解码从服务器读取的字节、远程尾随空格，并返回 HTTP 状态。</p>
<div class="highlight"><pre><span></span><code><span class="o">...</span>
<span class="c1"># 解码并去除空白</span>
<span class="n">status</span> <span class="o">=</span> <span class="n">response</span><span class="o">.</span><span class="n">decode</span><span class="p">()</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
<span class="c1"># 返回响应</span>
<span class="k">return</span> <span class="n">status</span>
</code></pre></div>
<p>将它们结合在一起，下面列出了完整的 <strong>get_status()</strong> 协程。</p>
<p>它没有任何错误处理，例如无法到达主机或响应缓慢的情况。</p>
<p>这些补充将为读者提供一个很好的扩展。</p>
<div class="highlight"><pre><span></span><code><span class="c1"># 获取网页的 HTTP/S 状态</span>
<span class="k">async</span> <span class="k">def</span> <span class="nf">get_status</span><span class="p">(</span><span class="n">url</span><span class="p">):</span>
    <span class="c1"># 将 url 拆分为多个组件</span>
    <span class="n">url_parsed</span> <span class="o">=</span> <span class="n">urlsplit</span><span class="p">(</span><span class="n">url</span><span class="p">)</span>
    <span class="c1"># 打开连接</span>
    <span class="k">if</span> <span class="n">url_parsed</span><span class="o">.</span><span class="n">scheme</span> <span class="o">==</span> <span class="s1">&#39;https&#39;</span><span class="p">:</span>
        <span class="n">reader</span><span class="p">,</span> <span class="n">writer</span> <span class="o">=</span> <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">open_connection</span><span class="p">(</span><span class="n">url_parsed</span><span class="o">.</span><span class="n">hostname</span><span class="p">,</span> <span class="mi">443</span><span class="p">,</span> <span class="n">ssl</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">reader</span><span class="p">,</span> <span class="n">writer</span> <span class="o">=</span> <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">open_connection</span><span class="p">(</span><span class="n">url_parsed</span><span class="o">.</span><span class="n">hostname</span><span class="p">,</span> <span class="mi">80</span><span class="p">)</span>
    <span class="c1"># 发送GET请求</span>
    <span class="n">query</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;GET </span><span class="si">{</span><span class="n">url_parsed</span><span class="o">.</span><span class="n">path</span><span class="si">}</span><span class="s1"> HTTP/1.1</span><span class="se">\r\n</span><span class="s1">Host: </span><span class="si">{</span><span class="n">url_parsed</span><span class="o">.</span><span class="n">hostname</span><span class="si">}</span><span class="se">\r\n\r\n</span><span class="s1">&#39;</span>
    <span class="c1"># 将查询写入套接字</span>
    <span class="n">writer</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">query</span><span class="o">.</span><span class="n">encode</span><span class="p">())</span>
    <span class="c1"># 等待字节写入套接字</span>
    <span class="k">await</span> <span class="n">writer</span><span class="o">.</span><span class="n">drain</span><span class="p">()</span>
    <span class="c1"># 读取单行响应</span>
    <span class="n">response</span> <span class="o">=</span> <span class="k">await</span> <span class="n">reader</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>
    <span class="c1"># 关闭连接</span>
    <span class="n">writer</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    <span class="c1"># 解码并去除空白</span>
    <span class="n">status</span> <span class="o">=</span> <span class="n">response</span><span class="o">.</span><span class="n">decode</span><span class="p">()</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
    <span class="c1"># 返回响应</span>
    <span class="k">return</span> <span class="n">status</span>
</code></pre></div>
<p>接下来，我们可以为我们想要检查的多个网页或网站调用 <strong>get_status()</strong> 协程。</p>
<p>在本例中，我们将定义世界排名前 10 的网页列表。</p>
<div class="highlight"><pre><span></span><code><span class="o">...</span>
<span class="c1"># 要检查的前 10 个网站列表</span>
<span class="n">sites</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;https://www.google.com/&#39;</span><span class="p">,</span>
    <span class="s1">&#39;https://www.youtube.com/&#39;</span><span class="p">,</span>
    <span class="s1">&#39;https://www.facebook.com/&#39;</span><span class="p">,</span>
    <span class="s1">&#39;https://twitter.com/&#39;</span><span class="p">,</span>
    <span class="s1">&#39;https://www.instagram.com/&#39;</span><span class="p">,</span>
    <span class="s1">&#39;https://www.baidu.com/&#39;</span><span class="p">,</span>
    <span class="s1">&#39;https://www.wikipedia.org/&#39;</span><span class="p">,</span>
    <span class="s1">&#39;https://yandex.ru/&#39;</span><span class="p">,</span>
    <span class="s1">&#39;https://yahoo.com/&#39;</span><span class="p">,</span>
    <span class="s1">&#39;https://www.whatsapp.com/&#39;</span>
    <span class="p">]</span>
</code></pre></div>
<p>然后我们可以使用 get_status() 协程依次查询每个。</p>
<p>在这种情况下，我们将在循环中按顺序执行此操作，并依次报告每个状态。</p>
<div class="highlight"><pre><span></span><code><span class="o">...</span>
<span class="c1"># 检查所有网站的状态</span>
<span class="k">for</span> <span class="n">url</span> <span class="ow">in</span> <span class="n">sites</span><span class="p">:</span>
    <span class="c1"># 获取 url 的状态</span>
    <span class="n">status</span> <span class="o">=</span> <span class="k">await</span> <span class="n">get_status</span><span class="p">(</span><span class="n">url</span><span class="p">)</span>
    <span class="c1"># 报告 url 及其状态</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">url</span><span class="si">:</span><span class="s1">30</span><span class="si">}</span><span class="s1">:</span><span class="se">\t</span><span class="si">{</span><span class="n">status</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
</code></pre></div>
<p>使用 asyncio 时，我们可以比顺序做得更好，但这提供了一个很好的起点，我们可以在以后进行改进。</p>
<p>将它们结合在一起，<strong>main()</strong> 协程查询前 10 个网站的状态。</p>
<div class="highlight"><pre><span></span><code><span class="c1"># 主协程</span>
<span class="k">async</span> <span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="c1"># 要检查的前 10 个网站列表</span>
    <span class="n">sites</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;https://www.google.com/&#39;</span><span class="p">,</span>
        <span class="s1">&#39;https://www.youtube.com/&#39;</span><span class="p">,</span>
        <span class="s1">&#39;https://www.facebook.com/&#39;</span><span class="p">,</span>
        <span class="s1">&#39;https://twitter.com/&#39;</span><span class="p">,</span>
        <span class="s1">&#39;https://www.instagram.com/&#39;</span><span class="p">,</span>
        <span class="s1">&#39;https://www.baidu.com/&#39;</span><span class="p">,</span>
        <span class="s1">&#39;https://www.wikipedia.org/&#39;</span><span class="p">,</span>
        <span class="s1">&#39;https://yandex.ru/&#39;</span><span class="p">,</span>
        <span class="s1">&#39;https://yahoo.com/&#39;</span><span class="p">,</span>
        <span class="s1">&#39;https://www.whatsapp.com/&#39;</span>
        <span class="p">]</span>
    <span class="c1"># 检查所有网站的状态</span>
    <span class="k">for</span> <span class="n">url</span> <span class="ow">in</span> <span class="n">sites</span><span class="p">:</span>
        <span class="c1"># 获取 url 的状态</span>
        <span class="n">status</span> <span class="o">=</span> <span class="k">await</span> <span class="n">get_status</span><span class="p">(</span><span class="n">url</span><span class="p">)</span>
        <span class="c1"># 报告 url 及其状态</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">url</span><span class="si">:</span><span class="s1">30</span><span class="si">}</span><span class="s1">:</span><span class="se">\t</span><span class="si">{</span><span class="n">status</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
</code></pre></div>
<p>最后，我们可以创建 <strong>main()</strong> 协程并将其用作 <strong>asyncio</strong> 程序的入口点。</p>
<div class="highlight"><pre><span></span><code><span class="o">...</span>
<span class="c1"># 运行异步程序</span>
<span class="n">asyncio</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">main</span><span class="p">())</span>
</code></pre></div>
<p>将它们结合在一起，下面列出了完整的示例。</p>
<div class="highlight"><pre><span></span><code><span class="c1"># SuperFastPython.com</span>
<span class="c1"># 检查许多网页的状态</span>
<span class="kn">import</span> <span class="nn">asyncio</span>
<span class="kn">from</span> <span class="nn">urllib.parse</span> <span class="kn">import</span> <span class="n">urlsplit</span>

<span class="c1"># 获取网页的 HTTP/S 状态</span>
<span class="k">async</span> <span class="k">def</span> <span class="nf">get_status</span><span class="p">(</span><span class="n">url</span><span class="p">):</span>
    <span class="c1"># 将 url 拆分为多个组件</span>
    <span class="n">url_parsed</span> <span class="o">=</span> <span class="n">urlsplit</span><span class="p">(</span><span class="n">url</span><span class="p">)</span>
    <span class="c1"># 打开连接</span>
    <span class="k">if</span> <span class="n">url_parsed</span><span class="o">.</span><span class="n">scheme</span> <span class="o">==</span> <span class="s1">&#39;https&#39;</span><span class="p">:</span>
        <span class="n">reader</span><span class="p">,</span> <span class="n">writer</span> <span class="o">=</span> <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">open_connection</span><span class="p">(</span><span class="n">url_parsed</span><span class="o">.</span><span class="n">hostname</span><span class="p">,</span> <span class="mi">443</span><span class="p">,</span> <span class="n">ssl</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">reader</span><span class="p">,</span> <span class="n">writer</span> <span class="o">=</span> <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">open_connection</span><span class="p">(</span><span class="n">url_parsed</span><span class="o">.</span><span class="n">hostname</span><span class="p">,</span> <span class="mi">80</span><span class="p">)</span>
    <span class="c1"># 发送 GET 请求</span>
    <span class="n">query</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;GET </span><span class="si">{</span><span class="n">url_parsed</span><span class="o">.</span><span class="n">path</span><span class="si">}</span><span class="s1"> HTTP/1.1</span><span class="se">\r\n</span><span class="s1">Host: </span><span class="si">{</span><span class="n">url_parsed</span><span class="o">.</span><span class="n">hostname</span><span class="si">}</span><span class="se">\r\n\r\n</span><span class="s1">&#39;</span>
    <span class="c1"># 将查询写入套接字</span>
    <span class="n">writer</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">query</span><span class="o">.</span><span class="n">encode</span><span class="p">())</span>
    <span class="c1"># 等待字节写入套接字</span>
    <span class="k">await</span> <span class="n">writer</span><span class="o">.</span><span class="n">drain</span><span class="p">()</span>
    <span class="c1"># 读取单行响应</span>
    <span class="n">response</span> <span class="o">=</span> <span class="k">await</span> <span class="n">reader</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>
    <span class="c1"># 关闭连接</span>
    <span class="n">writer</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    <span class="c1"># 解码并去除空白</span>
    <span class="n">status</span> <span class="o">=</span> <span class="n">response</span><span class="o">.</span><span class="n">decode</span><span class="p">()</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
    <span class="c1"># 返回响应</span>
    <span class="k">return</span> <span class="n">status</span>

<span class="c1"># 主协程</span>
<span class="k">async</span> <span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="c1"># 要检查的前 10 个网站列表</span>
    <span class="n">sites</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;https://www.google.com/&#39;</span><span class="p">,</span>
        <span class="s1">&#39;https://www.youtube.com/&#39;</span><span class="p">,</span>
        <span class="s1">&#39;https://www.facebook.com/&#39;</span><span class="p">,</span>
        <span class="s1">&#39;https://twitter.com/&#39;</span><span class="p">,</span>
        <span class="s1">&#39;https://www.instagram.com/&#39;</span><span class="p">,</span>
        <span class="s1">&#39;https://www.baidu.com/&#39;</span><span class="p">,</span>
        <span class="s1">&#39;https://www.wikipedia.org/&#39;</span><span class="p">,</span>
        <span class="s1">&#39;https://yandex.ru/&#39;</span><span class="p">,</span>
        <span class="s1">&#39;https://yahoo.com/&#39;</span><span class="p">,</span>
        <span class="s1">&#39;https://www.whatsapp.com/&#39;</span>
        <span class="p">]</span>
    <span class="c1"># 检查所有网站的状态</span>
    <span class="k">for</span> <span class="n">url</span> <span class="ow">in</span> <span class="n">sites</span><span class="p">:</span>
        <span class="c1"># 获取 url 的状态</span>
        <span class="n">status</span> <span class="o">=</span> <span class="k">await</span> <span class="n">get_status</span><span class="p">(</span><span class="n">url</span><span class="p">)</span>
        <span class="c1"># 报告 url 及其状态</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">url</span><span class="si">:</span><span class="s1">30</span><span class="si">}</span><span class="s1">:</span><span class="se">\t</span><span class="si">{</span><span class="n">status</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

<span class="c1"># 运行异步程序</span>
<span class="n">asyncio</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">main</span><span class="p">())</span>
</code></pre></div>
<p>运行该示例首先创建 <strong>main()</strong> 协程并将其用作程序的入口点。</p>
<p><strong>main()</strong> 协程运行，定义前 10 个网站的列表。</p>
<p>然后按顺序遍历网站列表。 <strong>main()</strong> 协程挂起并调用 <strong>get_status()</strong> 协程来查询某个网站的状态。</p>
<p><strong>get_status()</strong> 协程运行、解析 URL 并打开连接。 它构造一个 HTTP GET 查询并将其写入主机。 响应被读取、解码并返回。</p>
<p><strong>main()</strong> 协程恢复并报告 URL 的 HTTP 状态。</p>
<p>对列表中的每个 URL 重复此操作。</p>
<p>该程序大约需要 5.6 秒才能完成，或者平均每个 URL 大约需要半秒。</p>
<p>这突出显示了我们如何使用 asyncio 来查询网页的 HTTP 状态。</p>
<p>尽管如此，它并没有充分利用 asyncio 来并发执行任务。</p>
<div class="highlight"><pre><span></span><code>https://www.google.com/       : HTTP/1.1 200 OK
https://www.youtube.com/      : HTTP/1.1 200 OK
https://www.facebook.com/     : HTTP/1.1 302 Found
https://twitter.com/          : HTTP/1.1 200 OK
https://www.instagram.com/    : HTTP/1.1 200 OK
https://www.baidu.com/        : HTTP/1.1 200 OK
https://www.wikipedia.org/    : HTTP/1.1 200 OK
https://yandex.ru/            : HTTP/1.1 302 Moved temporarily
https://yahoo.com/            : HTTP/1.1 301 Moved Permanently
https://www.whatsapp.com/     : HTTP/1.1 302 Found
</code></pre></div>
<p>接下来，让我们看看如何更新示例以同时执行协程。</p>
</div>
</div>
</div>
<h3 id="217-并发检查网站状态的示例">21.7 并发检查网站状态的示例<a class="headerlink" href="#217-并发检查网站状态的示例" title="Permanent link">&para;</a></h3>
<p><strong>21.7 Example of Checking Website Status Concurrently</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="128:2"><input checked="checked" id="__tabbed_128_1" name="__tabbed_128" type="radio" /><input id="__tabbed_128_2" name="__tabbed_128" type="radio" /><div class="tabbed-labels"><label for="__tabbed_128_1">English</label><label for="__tabbed_128_2">Chinese</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<p>A benefit of asyncio is that we can execute many coroutines concurrently.</p>
<p>We can query the status of websites concurrently in asyncio using the <a href="https://docs.python.org/3/library/asyncio-task.html#asyncio.gather">asyncio.gather()</a> function.</p>
<p>This function takes one or more coroutines, suspends executing the provided coroutines, and returns the results from each as an iterable. We can then traverse the list of URLs and iterable of return values from the coroutines and report results.</p>
<p>This may be a simpler approach than the above.</p>
<p>First, we can create a list of coroutines.</p>
<div class="highlight"><pre><span></span><code><span class="o">...</span>
<span class="c1"># create all coroutine requests</span>
<span class="n">coros</span> <span class="o">=</span> <span class="p">[</span><span class="n">get_status</span><span class="p">(</span><span class="n">url</span><span class="p">)</span> <span class="k">for</span> <span class="n">url</span> <span class="ow">in</span> <span class="n">sites</span><span class="p">]</span>
</code></pre></div>
<p>Next, we can execute the coroutines and get the iterable of results using asyncio.gather().</p>
<p>Note that we cannot provide the list of coroutines directly, but instead must unpack the list into separate expressions that are provided as positional arguments to the function.</p>
<div class="highlight"><pre><span></span><code><span class="o">...</span>
<span class="c1"># execute all coroutines and wait</span>
<span class="n">results</span> <span class="o">=</span> <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="o">*</span><span class="n">coros</span><span class="p">)</span>
</code></pre></div>
<p>This will execute all of the coroutines concurrently and retrieve their results.</p>
<p>We can then traverse the list of URLs and returned status and report each in turn.</p>
<div class="highlight"><pre><span></span><code><span class="o">...</span>
<span class="c1"># process all results</span>
<span class="k">for</span> <span class="n">url</span><span class="p">,</span> <span class="n">status</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">sites</span><span class="p">,</span> <span class="n">results</span><span class="p">):</span>
    <span class="c1"># report status</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">url</span><span class="si">:</span><span class="s1">30</span><span class="si">}</span><span class="s1">:</span><span class="se">\t</span><span class="si">{</span><span class="n">status</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
</code></pre></div>
<p>Tying this together, the complete example is listed below.</p>
<div class="highlight"><pre><span></span><code><span class="c1"># SuperFastPython.com</span>
<span class="c1"># check the status of many webpages</span>
<span class="kn">import</span> <span class="nn">asyncio</span>
<span class="kn">from</span> <span class="nn">urllib.parse</span> <span class="kn">import</span> <span class="n">urlsplit</span>

<span class="c1"># get the HTTP/S status of a webpage</span>
<span class="k">async</span> <span class="k">def</span> <span class="nf">get_status</span><span class="p">(</span><span class="n">url</span><span class="p">):</span>
    <span class="c1"># split the url into components</span>
    <span class="n">url_parsed</span> <span class="o">=</span> <span class="n">urlsplit</span><span class="p">(</span><span class="n">url</span><span class="p">)</span>
    <span class="c1"># open the connection</span>
    <span class="k">if</span> <span class="n">url_parsed</span><span class="o">.</span><span class="n">scheme</span> <span class="o">==</span> <span class="s1">&#39;https&#39;</span><span class="p">:</span>
        <span class="n">reader</span><span class="p">,</span> <span class="n">writer</span> <span class="o">=</span> <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">open_connection</span><span class="p">(</span><span class="n">url_parsed</span><span class="o">.</span><span class="n">hostname</span><span class="p">,</span> <span class="mi">443</span><span class="p">,</span> <span class="n">ssl</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">reader</span><span class="p">,</span> <span class="n">writer</span> <span class="o">=</span> <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">open_connection</span><span class="p">(</span><span class="n">url_parsed</span><span class="o">.</span><span class="n">hostname</span><span class="p">,</span> <span class="mi">80</span><span class="p">)</span>
    <span class="c1"># send GET request</span>
    <span class="n">query</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;GET </span><span class="si">{</span><span class="n">url_parsed</span><span class="o">.</span><span class="n">path</span><span class="si">}</span><span class="s1"> HTTP/1.1</span><span class="se">\r\n</span><span class="s1">Host: </span><span class="si">{</span><span class="n">url_parsed</span><span class="o">.</span><span class="n">hostname</span><span class="si">}</span><span class="se">\r\n\r\n</span><span class="s1">&#39;</span>
    <span class="c1"># write query to socket</span>
    <span class="n">writer</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">query</span><span class="o">.</span><span class="n">encode</span><span class="p">())</span>
    <span class="c1"># wait for the bytes to be written to the socket</span>
    <span class="k">await</span> <span class="n">writer</span><span class="o">.</span><span class="n">drain</span><span class="p">()</span>
    <span class="c1"># read the single line response</span>
    <span class="n">response</span> <span class="o">=</span> <span class="k">await</span> <span class="n">reader</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>
    <span class="c1"># close the connection</span>
    <span class="n">writer</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    <span class="c1"># decode and strip white space</span>
    <span class="n">status</span> <span class="o">=</span> <span class="n">response</span><span class="o">.</span><span class="n">decode</span><span class="p">()</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
    <span class="c1"># return the response</span>
    <span class="k">return</span> <span class="n">status</span>

<span class="c1"># main coroutine</span>
<span class="k">async</span> <span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="c1"># list of top 10 websites to check</span>
    <span class="n">sites</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;https://www.google.com/&#39;</span><span class="p">,</span>
        <span class="s1">&#39;https://www.youtube.com/&#39;</span><span class="p">,</span>
        <span class="s1">&#39;https://www.facebook.com/&#39;</span><span class="p">,</span>
        <span class="s1">&#39;https://twitter.com/&#39;</span><span class="p">,</span>
        <span class="s1">&#39;https://www.instagram.com/&#39;</span><span class="p">,</span>
        <span class="s1">&#39;https://www.baidu.com/&#39;</span><span class="p">,</span>
        <span class="s1">&#39;https://www.wikipedia.org/&#39;</span><span class="p">,</span>
        <span class="s1">&#39;https://yandex.ru/&#39;</span><span class="p">,</span>
        <span class="s1">&#39;https://yahoo.com/&#39;</span><span class="p">,</span>
        <span class="s1">&#39;https://www.whatsapp.com/&#39;</span>
        <span class="p">]</span>
    <span class="c1"># create all coroutine requests</span>
    <span class="n">coros</span> <span class="o">=</span> <span class="p">[</span><span class="n">get_status</span><span class="p">(</span><span class="n">url</span><span class="p">)</span> <span class="k">for</span> <span class="n">url</span> <span class="ow">in</span> <span class="n">sites</span><span class="p">]</span>
    <span class="c1"># execute all coroutines and wait</span>
    <span class="n">results</span> <span class="o">=</span> <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="o">*</span><span class="n">coros</span><span class="p">)</span>
    <span class="c1"># process all results</span>
    <span class="k">for</span> <span class="n">url</span><span class="p">,</span> <span class="n">status</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">sites</span><span class="p">,</span> <span class="n">results</span><span class="p">):</span>
        <span class="c1"># report status</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">url</span><span class="si">:</span><span class="s1">30</span><span class="si">}</span><span class="s1">:</span><span class="se">\t</span><span class="si">{</span><span class="n">status</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

<span class="c1"># run the asyncio program</span>
<span class="n">asyncio</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">main</span><span class="p">())</span>
</code></pre></div>
<p>Running the example executes the main() coroutine as before.</p>
<p>In this case, a list of coroutines is created in a list comprehension.</p>
<p>The asyncio.gather() function is then called, passing the coroutines and suspending the main() coroutine until they are all complete.</p>
<p>The coroutines execute, querying each website concurrently and returning their status.</p>
<p>The main() coroutine resumes and receives an iterable of status values. This iterable along with the list of URLs is then traversed using the zip() built-in function and the statuses are reported.</p>
<p>This highlights a simpler approach to executing the coroutines concurrently and reporting the results after all tasks are completed.</p>
<p>It is also faster than the sequential version above, completing in about 1.4 seconds on my system.</p>
<div class="highlight"><pre><span></span><code>https://www.google.com/       : HTTP/1.1 200 OK
https://www.youtube.com/      : HTTP/1.1 200 OK
https://www.facebook.com/     : HTTP/1.1 302 Found
https://twitter.com/          : HTTP/1.1 200 OK
https://www.instagram.com/    : HTTP/1.1 200 OK
https://www.baidu.com/        : HTTP/1.1 200 OK
https://www.wikipedia.org/    : HTTP/1.1 200 OK
https://yandex.ru/            : HTTP/1.1 302 Moved temporarily
https://yahoo.com/            : HTTP/1.1 301 Moved Permanently
https://www.whatsapp.com/     : HTTP/1.1 302 Found
</code></pre></div>
<p>Next, let’s explore common errors when getting started with asyncio.</p>
</div>
<div class="tabbed-block">
<p>asyncio 的一个好处是我们可以同时执行许多协程。</p>
<p>我们可以使用 <a href="https://docs.python.org/3/library/asyncio-task.html#asyncio.gather">asyncio.gather()</a> 函数在 asyncio 中同时查询网站的状态。</p>
<p>该函数采用一个或多个协程，暂停执行所提供的协程，并将每个协程的结果作为可迭代对象返回。 然后我们可以遍历协程的 URL 列表和可迭代的返回值并报告结果。</p>
<p>这可能是比上面更简单的方法。</p>
<p>首先，我们可以创建一个协程列表。</p>
<div class="highlight"><pre><span></span><code><span class="o">...</span>
<span class="c1"># 创建所有协程请求</span>
<span class="n">coros</span> <span class="o">=</span> <span class="p">[</span><span class="n">get_status</span><span class="p">(</span><span class="n">url</span><span class="p">)</span> <span class="k">for</span> <span class="n">url</span> <span class="ow">in</span> <span class="n">sites</span><span class="p">]</span>
</code></pre></div>
<p>接下来，我们可以执行协程并使用 <strong>asyncio.gather()</strong> 获取可迭代的结果。</p>
<p>请注意，我们无法直接提供协程列表，而是必须将列表解压缩为单独的表达式，这些表达式作为函数的位置参数提供。</p>
<div class="highlight"><pre><span></span><code><span class="o">...</span>
<span class="c1"># 执行所有协程并等待</span>
<span class="n">results</span> <span class="o">=</span> <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="o">*</span><span class="n">coros</span><span class="p">)</span>
</code></pre></div>
<p>这将同时执行所有协程并检索它们的结果。</p>
<p>然后我们可以遍历 URL 列表和返回的状态并依次报告。</p>
<div class="highlight"><pre><span></span><code><span class="o">...</span>
<span class="c1"># 处理所有结果</span>
<span class="k">for</span> <span class="n">url</span><span class="p">,</span> <span class="n">status</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">sites</span><span class="p">,</span> <span class="n">results</span><span class="p">):</span>
    <span class="c1"># 报告状态</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">url</span><span class="si">:</span><span class="s1">30</span><span class="si">}</span><span class="s1">:</span><span class="se">\t</span><span class="si">{</span><span class="n">status</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
</code></pre></div>
<p>将它们结合在一起，下面列出了完整的示例。</p>
<div class="highlight"><pre><span></span><code><span class="c1"># SuperFastPython.com</span>
<span class="c1"># 检查许多网页的状态</span>
<span class="kn">import</span> <span class="nn">asyncio</span>
<span class="kn">from</span> <span class="nn">urllib.parse</span> <span class="kn">import</span> <span class="n">urlsplit</span>

<span class="c1"># 获取网页的 HTTP/S 状态</span>
<span class="k">async</span> <span class="k">def</span> <span class="nf">get_status</span><span class="p">(</span><span class="n">url</span><span class="p">):</span>
    <span class="c1"># 将 url 拆分为多个组件</span>
    <span class="n">url_parsed</span> <span class="o">=</span> <span class="n">urlsplit</span><span class="p">(</span><span class="n">url</span><span class="p">)</span>
    <span class="c1"># 打开连接</span>
    <span class="k">if</span> <span class="n">url_parsed</span><span class="o">.</span><span class="n">scheme</span> <span class="o">==</span> <span class="s1">&#39;https&#39;</span><span class="p">:</span>
        <span class="n">reader</span><span class="p">,</span> <span class="n">writer</span> <span class="o">=</span> <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">open_connection</span><span class="p">(</span><span class="n">url_parsed</span><span class="o">.</span><span class="n">hostname</span><span class="p">,</span> <span class="mi">443</span><span class="p">,</span> <span class="n">ssl</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">reader</span><span class="p">,</span> <span class="n">writer</span> <span class="o">=</span> <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">open_connection</span><span class="p">(</span><span class="n">url_parsed</span><span class="o">.</span><span class="n">hostname</span><span class="p">,</span> <span class="mi">80</span><span class="p">)</span>
    <span class="c1"># 发送 GET 请求</span>
    <span class="n">query</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;GET </span><span class="si">{</span><span class="n">url_parsed</span><span class="o">.</span><span class="n">path</span><span class="si">}</span><span class="s1"> HTTP/1.1</span><span class="se">\r\n</span><span class="s1">Host: </span><span class="si">{</span><span class="n">url_parsed</span><span class="o">.</span><span class="n">hostname</span><span class="si">}</span><span class="se">\r\n\r\n</span><span class="s1">&#39;</span>
    <span class="c1"># 将查询写入套接字</span>
    <span class="n">writer</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">query</span><span class="o">.</span><span class="n">encode</span><span class="p">())</span>
    <span class="c1"># 等待字节写入套接字</span>
    <span class="k">await</span> <span class="n">writer</span><span class="o">.</span><span class="n">drain</span><span class="p">()</span>
    <span class="c1"># 读取单行响应</span>
    <span class="n">response</span> <span class="o">=</span> <span class="k">await</span> <span class="n">reader</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>
    <span class="c1"># 关闭连接</span>
    <span class="n">writer</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    <span class="c1"># 解码并去除空白字符</span>
    <span class="n">status</span> <span class="o">=</span> <span class="n">response</span><span class="o">.</span><span class="n">decode</span><span class="p">()</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
    <span class="c1"># 返回响应</span>
    <span class="k">return</span> <span class="n">status</span>

<span class="c1"># 主协程</span>
<span class="k">async</span> <span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="c1"># 要检查的前 10 个网站列表</span>
    <span class="n">sites</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;https://www.google.com/&#39;</span><span class="p">,</span>
        <span class="s1">&#39;https://www.youtube.com/&#39;</span><span class="p">,</span>
        <span class="s1">&#39;https://www.facebook.com/&#39;</span><span class="p">,</span>
        <span class="s1">&#39;https://twitter.com/&#39;</span><span class="p">,</span>
        <span class="s1">&#39;https://www.instagram.com/&#39;</span><span class="p">,</span>
        <span class="s1">&#39;https://www.baidu.com/&#39;</span><span class="p">,</span>
        <span class="s1">&#39;https://www.wikipedia.org/&#39;</span><span class="p">,</span>
        <span class="s1">&#39;https://yandex.ru/&#39;</span><span class="p">,</span>
        <span class="s1">&#39;https://yahoo.com/&#39;</span><span class="p">,</span>
        <span class="s1">&#39;https://www.whatsapp.com/&#39;</span>
        <span class="p">]</span>
    <span class="c1"># 创建所有协程请求</span>
    <span class="n">coros</span> <span class="o">=</span> <span class="p">[</span><span class="n">get_status</span><span class="p">(</span><span class="n">url</span><span class="p">)</span> <span class="k">for</span> <span class="n">url</span> <span class="ow">in</span> <span class="n">sites</span><span class="p">]</span>
    <span class="c1"># 执行所有协程并等待</span>
    <span class="n">results</span> <span class="o">=</span> <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="o">*</span><span class="n">coros</span><span class="p">)</span>
    <span class="c1"># 处理所有结果</span>
    <span class="k">for</span> <span class="n">url</span><span class="p">,</span> <span class="n">status</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">sites</span><span class="p">,</span> <span class="n">results</span><span class="p">):</span>
        <span class="c1"># 报告状态</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">url</span><span class="si">:</span><span class="s1">30</span><span class="si">}</span><span class="s1">:</span><span class="se">\t</span><span class="si">{</span><span class="n">status</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

<span class="c1"># 运行异步程序</span>
<span class="n">asyncio</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">main</span><span class="p">())</span>
</code></pre></div>
<p>运行该示例会像以前一样执行 <strong>main()</strong> 协程。</p>
<p>在这种情况下，协程列表是在列表推导式中创建的。</p>
<p>然后调用 <strong>asyncio.gather()</strong> 函数，传递协程并挂起 <strong>main()</strong> 协程，直到它们全部完成。</p>
<p>协程执行，同时查询每个网站并返回其状态。</p>
<p><strong>main()</strong> 协程恢复并接收可迭代的状态值。 然后使用 <strong>zip()</strong> 内置函数遍历该可迭代对象以及 URL 列表，并报告状态。</p>
<p>这突出显示了一种<strong>更简单的方法</strong>来<strong>同时执行协程</strong>并在所有任务完成后报告结果。</p>
<p>它也比上面的顺序版本更快，在我的系统上大约需要 1.4 秒即可完成。</p>
<div class="highlight"><pre><span></span><code>https://www.google.com/       : HTTP/1.1 200 OK
https://www.youtube.com/      : HTTP/1.1 200 OK
https://www.facebook.com/     : HTTP/1.1 302 Found
https://twitter.com/          : HTTP/1.1 200 OK
https://www.instagram.com/    : HTTP/1.1 200 OK
https://www.baidu.com/        : HTTP/1.1 200 OK
https://www.wikipedia.org/    : HTTP/1.1 200 OK
https://yandex.ru/            : HTTP/1.1 302 Moved temporarily
https://yahoo.com/            : HTTP/1.1 301 Moved Permanently
https://www.whatsapp.com/     : HTTP/1.1 302 Found
</code></pre></div>
<p>接下来，让我们探讨一下 <strong>asyncio</strong> 入门时的常见错误。</p>
</div>
</div>
</div>
<h2 id="22-python-asyncio-常见错误">22. Python Asyncio 常见错误<a class="headerlink" href="#22-python-asyncio-常见错误" title="Permanent link">&para;</a></h2>
<p><strong>22. Python Asyncio Common Errors</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="129:2"><input checked="checked" id="__tabbed_129_1" name="__tabbed_129" type="radio" /><input id="__tabbed_129_2" name="__tabbed_129" type="radio" /><div class="tabbed-labels"><label for="__tabbed_129_1">English</label><label for="__tabbed_129_2">Chinese</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<p>This section gives examples of general errors encountered by developers when using asyncio in Python.</p>
<p>The 5 most common asyncio errors are:</p>
<ol>
<li>Trying to run coroutines by calling them.</li>
<li>Not letting coroutines run in the event loop.</li>
<li>Using the asyncio low-level API.</li>
<li>Exiting the main coroutine too early.</li>
<li>Assuming race conditions and deadlocks are not possible.</li>
</ol>
<p>Let’s take a closer look at each in turn.</p>
</div>
<div class="tabbed-block">
<p>本节提供了开发人员在 Python 中使用 asyncio 时遇到的常见错误的示例。</p>
<p>5 个最常见的异步错误是：</p>
<ol>
<li>尝试通过调用协程来运行它们。</li>
<li>不让协程在事件循环中运行。</li>
<li>使用 asyncio 低级 API。</li>
<li>过早退出主协程。</li>
<li>假设竞争条件和死锁是不存在的。</li>
</ol>
<p>让我们依次仔细看看每一个问题。</p>
</div>
</div>
</div>
<h3 id="221-错误-1-尝试通过函数调用的方式来运行协程">22.1 错误 1: 尝试通过函数调用的方式来运行协程<a class="headerlink" href="#221-错误-1-尝试通过函数调用的方式来运行协程" title="Permanent link">&para;</a></h3>
<p><strong>22.1 Error 1: Trying to Run Coroutines by Calling Them</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="130:2"><input checked="checked" id="__tabbed_130_1" name="__tabbed_130" type="radio" /><input id="__tabbed_130_2" name="__tabbed_130" type="radio" /><div class="tabbed-labels"><label for="__tabbed_130_1">English</label><label for="__tabbed_130_2">Chinese</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<p>The most common error encountered by beginners to asyncio is calling a coroutine like a function.</p>
<p>For example, we can define a coroutine using the “async def” expression:</p>
<div class="highlight"><pre><span></span><code><span class="c1"># custom coroutine</span>
<span class="k">async</span> <span class="k">def</span> <span class="nf">custom_coro</span><span class="p">():</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;hi there&#39;</span><span class="p">)</span>
</code></pre></div>
<p>The beginner will then attempt to call this coroutine like a function and expect the print message to be reported.</p>
<p>For example:</p>
<div class="highlight"><pre><span></span><code><span class="o">...</span>
<span class="c1"># error attempt at calling a coroutine like a function</span>
<span class="n">custom_coro</span><span class="p">()</span>
</code></pre></div>
<p>Calling a coroutine like a function will not execute the body of the coroutine.</p>
<p>Instead, it will create a coroutine object.</p>
<p>This object can then be awaited within the asyncio runtime, e.g. the event loop.</p>
<p>We can start the event loop to run the coroutine using the asyncio.run() function.</p>
<p>For example:</p>
<div class="highlight"><pre><span></span><code><span class="o">...</span>
<span class="c1"># run a coroutine</span>
<span class="n">asyncio</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">custom_coro</span><span class="p">())</span>
</code></pre></div>
<p>Alternatively, we can suspend the current coroutine and schedule the other coroutine using the “await” expression.</p>
<p>For example:</p>
<div class="highlight"><pre><span></span><code><span class="o">...</span>
<span class="c1"># schedule a coroutine</span>
<span class="k">await</span> <span class="n">custom_coro</span><span class="p">()</span>
</code></pre></div>
<p>You can learn more about running coroutines in the tutorial:</p>
<ul>
<li><a href="https://superfastpython.com/asyncio-run-coroutine">How to Run an Asyncio Coroutine in Python</a></li>
</ul>
</div>
<div class="tabbed-block">
<p>asyncio 初学者遇到的最常见错误是像函数一样调用协程。</p>
<p>例如，我们可以使用“async def”表达式定义一个协程：</p>
<div class="highlight"><pre><span></span><code><span class="c1"># 自定义协程</span>
<span class="k">async</span> <span class="k">def</span> <span class="nf">custom_coro</span><span class="p">():</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;hi there&#39;</span><span class="p">)</span>
</code></pre></div>
<p>然后，初学者将尝试像函数一样调用这个协程，并期望报告打印消息。</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code><span class="o">...</span>
<span class="c1"># 尝试像函数一样调用协程时出错</span>
<span class="n">custom_coro</span><span class="p">()</span>
</code></pre></div>
<p>像函数一样调用协程不会执行协程主体。</p>
<p>相反，它将创建一个协程对象。</p>
<p>然后可以在 asyncio 运行时中等待该对象，例如：事件循环（Event Loop）。</p>
<p>我们可以使用 <code>asyncio.run()</code> 函数启动事件循环来运行协程。</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code><span class="o">...</span>
<span class="c1"># 运行协程</span>
<span class="n">asyncio</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">custom_coro</span><span class="p">())</span>
</code></pre></div>
<p>或者，我们可以挂起当前协程并使用“<strong>await</strong>”表达式调度另一个协程。</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code><span class="o">...</span>
<span class="c1"># 调度一个协程</span>
<span class="k">await</span> <span class="n">custom_coro</span><span class="p">()</span>
</code></pre></div>
<p>您可以在教程中了解有关运行协程的更多信息：</p>
<ul>
<li><a href="https://superfastpython.com/asyncio-run-coroutine">如何在 Python 中运行 Asyncio 协程</a></li>
</ul>
</div>
</div>
</div>
<h3 id="222-错误-2-不在事件循环中运行协程">22.2 错误 2: 不在事件循环中运行协程<a class="headerlink" href="#222-错误-2-不在事件循环中运行协程" title="Permanent link">&para;</a></h3>
<p><strong>22.2 Error 2: Not Letting Coroutines Run in the Event Loop</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="131:2"><input checked="checked" id="__tabbed_131_1" name="__tabbed_131" type="radio" /><input id="__tabbed_131_2" name="__tabbed_131" type="radio" /><div class="tabbed-labels"><label for="__tabbed_131_1">English</label><label for="__tabbed_131_2">Chinese</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<p>If a coroutine is not run, you will get a runtime warning as follows:</p>
<div class="highlight"><pre><span></span><code>sys:1: RuntimeWarning: coroutine &#39;custom_coro&#39; was never awaited
</code></pre></div>
<p>This will happen if you create a coroutine object but do not schedule it for execution within the asyncio event loop.</p>
<p>For example, you may attempt to call a coroutine from a regular Python program:</p>
<div class="highlight"><pre><span></span><code><span class="o">...</span>
<span class="c1"># attempt to call the coroutine</span>
<span class="n">custom_coro</span><span class="p">()</span>
</code></pre></div>
<p>This will not call the coroutine.</p>
<p>Instead, it will create a coroutine object.</p>
<p>For example:</p>
<div class="highlight"><pre><span></span><code><span class="o">...</span>
<span class="c1"># create a coroutine object</span>
<span class="n">coro</span> <span class="o">=</span> <span class="n">custom_coro</span><span class="p">()</span>
</code></pre></div>
<p>If you do not allow this coroutine to run, you will get a runtime error.</p>
<p>You can let the coroutine run, as we saw in the previous section, by starting the asyncio event loop and passing it the coroutine object.</p>
<p>For example:</p>
<div class="highlight"><pre><span></span><code><span class="o">...</span>
<span class="c1"># create a coroutine object</span>
<span class="n">coro</span> <span class="o">=</span> <span class="n">custom_coro</span><span class="p">()</span>
<span class="c1"># run a coroutine</span>
<span class="n">asyncio</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">coro</span><span class="p">)</span>
</code></pre></div>
<p>Or, on one line in a compound statement:</p>
<div class="highlight"><pre><span></span><code><span class="o">...</span>
<span class="c1"># run a coroutine</span>
<span class="n">asyncio</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">custom_coro</span><span class="p">())</span>
</code></pre></div>
<p>You can learn more about running coroutines in the tutorial:</p>
<ul>
<li><a href="https://superfastpython.com/asyncio-run-coroutine">How to Run an Asyncio Coroutine in Python</a></li>
</ul>
<p>If you get this error within an asyncio program, it is because you have created a coroutine and have not scheduled it for execution.</p>
<p>This can be achieved using the await expression.</p>
<p>For example:</p>
<div class="highlight"><pre><span></span><code><span class="o">...</span>
<span class="c1"># create a coroutine object</span>
<span class="n">coro</span> <span class="o">=</span> <span class="n">custom_coro</span><span class="p">()</span>
<span class="c1"># suspend and allow the other coroutine to run</span>
<span class="k">await</span> <span class="n">coro</span>
</code></pre></div>
<p>Or, you can schedule it to run independently as a task.</p>
<p>For example:</p>
<div class="highlight"><pre><span></span><code><span class="o">...</span>
<span class="c1"># create a coroutine object</span>
<span class="n">coro</span> <span class="o">=</span> <span class="n">custom_coro</span><span class="p">()</span>
<span class="c1"># schedule the coro to run as a task interdependently</span>
<span class="n">task</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">create_task</span><span class="p">(</span><span class="n">coro</span><span class="p">)</span>
</code></pre></div>
<p>You can learn more about creating tasks in the tutorial:</p>
<ul>
<li>How to Create an Asyncio Task in Python</li>
</ul>
</div>
<div class="tabbed-block">
<p>如果协程未运行，您将收到如下运行时警告：</p>
<div class="highlight"><pre><span></span><code>sys:1: RuntimeWarning: coroutine &#39;custom_coro&#39; was never awaited
</code></pre></div>
<p>如果您创建一个协程对象但没有安排它在 asyncio 事件循环中执行，就会发生这种情况。</p>
<p>例如，您可以尝试从常规 Python 程序调用协程：</p>
<div class="highlight"><pre><span></span><code><span class="o">...</span>
<span class="c1"># 尝试调用协程</span>
<span class="n">custom_coro</span><span class="p">()</span>
</code></pre></div>
<p>这不会调用协程。</p>
<p>相反，它将创建一个协程对象。</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code><span class="o">...</span>
<span class="c1"># 创建一个协程对象</span>
<span class="n">coro</span> <span class="o">=</span> <span class="n">custom_coro</span><span class="p">()</span>
</code></pre></div>
<p>如果您不允许该协程运行，您将收到运行时错误。</p>
<p>正如我们在上一节中看到的，您可以通过启动 asyncio 事件循环并向其传递协程对象来让协程运行。</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code><span class="o">...</span>
<span class="c1"># 创建一个协程对象</span>
<span class="n">coro</span> <span class="o">=</span> <span class="n">custom_coro</span><span class="p">()</span>
<span class="c1"># 运行协程</span>
<span class="n">asyncio</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">coro</span><span class="p">)</span>
</code></pre></div>
<p>或者，在复合语句的一行中：</p>
<div class="highlight"><pre><span></span><code><span class="o">...</span>
<span class="c1"># 运行协程</span>
<span class="n">asyncio</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">custom_coro</span><span class="p">())</span>
</code></pre></div>
<p>您可以在教程中了解有关运行协程的更多信息：</p>
<ul>
<li><a href="https://superfastpython.com/asyncio-run-coroutine">如何在 Python 中运行 Asyncio 协程</a></li>
</ul>
<p>如果您在 asyncio 程序中收到此错误，那是因为您创建了一个协程但尚未安排其执行。</p>
<p>这可以使用 <strong>await</strong> 表达式来实现。</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code><span class="o">...</span>
<span class="c1"># 创建一个协程对象</span>
<span class="n">coro</span> <span class="o">=</span> <span class="n">custom_coro</span><span class="p">()</span>
<span class="c1"># 挂起并允许其他协程运行</span>
<span class="k">await</span> <span class="n">coro</span>
</code></pre></div>
<p>或者，您可以安排它作为任务独立运行。</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code><span class="o">...</span>
<span class="c1"># 创建一个协程对象</span>
<span class="n">coro</span> <span class="o">=</span> <span class="n">custom_coro</span><span class="p">()</span>
<span class="c1"># 安排 coro 作为任务相互依赖地运行</span>
<span class="n">task</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">create_task</span><span class="p">(</span><span class="n">coro</span><span class="p">)</span>
</code></pre></div>
<p>您可以在教程中了解有关创建任务的更多信息：</p>
<ul>
<li><a href="https://superfastpython.com/asyncio-create-task">如何在 Python 中创建Asyncio任务</a></li>
</ul>
</div>
</div>
</div>
<h3 id="223-错误-3-使用低级的-asyncio-api">22.3 错误 3: 使用低级的 Asyncio API<a class="headerlink" href="#223-错误-3-使用低级的-asyncio-api" title="Permanent link">&para;</a></h3>
<p><strong>22.3 Error 3: Using the Low-Level Asyncio API</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="132:2"><input checked="checked" id="__tabbed_132_1" name="__tabbed_132" type="radio" /><input id="__tabbed_132_2" name="__tabbed_132" type="radio" /><div class="tabbed-labels"><label for="__tabbed_132_1">English</label><label for="__tabbed_132_2">Chinese</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<p>A big problem with beginners is that they use the wrong asyncio API.</p>
<p>This is common for a number of reasons.</p>
<ul>
<li>The API has changed a lot with recent versions of Python.</li>
<li>The API docs page makes things confusing, showing both APIs.</li>
<li>Examples elsewhere on the web mix up using the different APIs.</li>
</ul>
<p>Using the wrong API makes things more verbose (e.g. more code), more difficult, and way less understandable.</p>
<p>Asyncio offers <a href="https://docs.python.org/3/library/asyncio.html">two APIs</a>.</p>
<ol>
<li>High-level API for application developers (us)</li>
<li>Low-level API for framework and library developers (not us)</li>
</ol>
<p>The lower-level API provides the foundation for the high-level API and includes the internals of the event loop, transport protocols, policies, and more.</p>
<blockquote>
<p>… there are low-level APIs for library and framework developers</p>
<p>— <a href="https://docs.python.org/3/library/asyncio.html">ASYNCIO — ASYNCHRONOUS I/O</a>
We should almost always stick to the high-level API.</p>
</blockquote>
<p>We absolutely must stick to the high-level API when getting started.</p>
<p>We may dip into the low-level API to achieve specific outcomes on occasion.</p>
<p>If you start getting a handle on the event loop or use a “loop” variable to do things, you are doing it wrong.</p>
<p>I am not saying don’t learn the low-level API.</p>
<p>Go for it. It’s great.</p>
<p>Just don’t start there.</p>
<p>Drive asyncio via the high-level API for a while. Develop some programs. Get comfortable with asynchronous programming and running coroutines at will.</p>
<p>Then later, dip in and have a look around.</p>
</div>
<div class="tabbed-block">
<p>初学者的一个大问题是他们使用了错误的 asyncio API。</p>
<p>由于多种原因，这种情况很常见。</p>
<ul>
<li>API 在最新版本的 Python 中发生了很大变化。</li>
<li>API 文档页面显示了这两个 API，这让事情变得混乱。</li>
<li>网络上其他地方的示例混合使用不同的 API。</li>
</ul>
<p>使用错误的 API 会使事情变得更加冗长（例如更多代码）、更加困难并且更难以理解。</p>
<p>Asyncio 提供<a href="https://docs.python.org/3/library/asyncio.html">两个 API</a>.</p>
<ol>
<li>面向应用程序开发人员（我们）的高级 API</li>
<li>面向框架和库开发人员（不是我们）的低级 API</li>
</ol>
<p>较低级别的 API 为高级 API 提供基础，包括事件循环、传输协议、策略等的内部结构。</p>
<blockquote>
<p>… 有供库和框架开发人员使用的低级 API</p>
<p>— <a href="https://docs.python.org/3/library/asyncio.html">ASYNCIO — ASYNCHRONOUS I/O</a></p>
</blockquote>
<p>我们几乎应该始终坚持使用高级 API。</p>
<p>开始时我们绝对必须坚持使用高级 API。</p>
<p>有时我们可能会利用低级 API 来实现特定的结果。</p>
<p>如果您开始获取事件循环的句柄或使用“loop”变量来执行操作，那么您就做错了。</p>
<p>我并不是说不要学习低级 API。</p>
<p>大胆试试吧。 这很棒。</p>
<p>只是不要从那里开始。</p>
<p>通过高级 API 驱动 asyncio 一段时间。 开发一些程序。 熟悉异步编程并随意运行协程。</p>
<p>然后，深入看看相关技术细节。</p>
</div>
</div>
</div>
<h3 id="224-错误-4-退出主协程太早">22.4 错误 4: 退出主协程太早<a class="headerlink" href="#224-错误-4-退出主协程太早" title="Permanent link">&para;</a></h3>
<p><strong>22.4 Error 4: Exiting the Main Coroutine Too Early</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="133:2"><input checked="checked" id="__tabbed_133_1" name="__tabbed_133" type="radio" /><input id="__tabbed_133_2" name="__tabbed_133" type="radio" /><div class="tabbed-labels"><label for="__tabbed_133_1">English</label><label for="__tabbed_133_2">Chinese</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<p>A major point of confusion in asyncio programs is not giving tasks enough time to complete.</p>
<p>We can schedule many coroutines to run independently within an asyncio program via the <strong>asyncio.create_task()</strong> method.</p>
<p>The main coroutine, the entry point for the asyncio program, can then carry on with other activities.</p>
<p>If the main coroutine exits, then the asyncio program will terminate.</p>
<p>The program will terminate even if there are one or many coroutines running independently as tasks.</p>
<p>This can catch you off guard.</p>
<p>You may issue many tasks and then allow the main coroutine to resume, expecting all issued tasks to complete in their own time.</p>
<p>Instead, if the main coroutine has nothing else to do, it should wait on the remaining tasks.</p>
<p>This can be achieved by first getting a set of all running tasks via the <strong>asyncio.all_tasks()</strong> function, removing itself from this set, then waiting on the remaining tasks via the <strong>asyncio.wait()</strong> function.</p>
<p>For example:</p>
<div class="highlight"><pre><span></span><code><span class="o">...</span>
<span class="c1"># get a set of all running tasks</span>
<span class="n">all_tasks</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">all_tasks</span><span class="p">()</span>
<span class="c1"># get the current tasks</span>
<span class="n">current_task</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">current_task</span><span class="p">()</span>
<span class="c1"># remove the current task from the list of all tasks</span>
<span class="n">all_tasks</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">current_task</span><span class="p">)</span>
<span class="c1"># suspend until all tasks are completed</span>
<span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">wait</span><span class="p">(</span><span class="n">all_tasks</span><span class="p">)</span>
</code></pre></div>
</div>
<div class="tabbed-block">
<p>异步程序中的一个主要混乱点是没有给任务足够的时间来完成。</p>
<p>我们可以通过 <strong>asyncio.create_task()</strong> 方法安排许多协程在 asyncio 程序中独立运行。</p>
<p>主协程（asyncio 程序的入口点）可以继续执行其他活动。</p>
<p>如果主协程退出，则 asyncio 程序将终止。</p>
<p>即使有一个或多个协程作为任务独立运行，程序也会终止。</p>
<p>这可能会让你措手不及。</p>
<p>您可以发出许多任务，然后允许主协程恢复，并期望所有发出的任务都能在自己的时间内完成。</p>
<p>相反，如果主协程没有其他事情可做，它应该等待剩余的任务。</p>
<p>这可以通过首先通过 <strong>asyncio.all_tasks()</strong> 函数获取一组所有正在运行的任务，将其自身从该组中删除，然后通过 <strong>asyncio.wait()</strong> 函数等待剩余任务来实现。</p>
<p>例如:</p>
<div class="highlight"><pre><span></span><code><span class="o">...</span>
<span class="c1"># 获取所有正在运行的任务的集合</span>
<span class="n">all_tasks</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">all_tasks</span><span class="p">()</span>
<span class="c1"># 获取当前任务</span>
<span class="n">current_task</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">current_task</span><span class="p">()</span>
<span class="c1"># 从所有任务列表中删除当前任务</span>
<span class="n">all_tasks</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">current_task</span><span class="p">)</span>
<span class="c1"># 暂停直到所有任务完成</span>
<span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">wait</span><span class="p">(</span><span class="n">all_tasks</span><span class="p">)</span>
</code></pre></div>
</div>
</div>
</div>
<h3 id="225-错误-5-假设竞争条件和死锁是不可能的">22.5 错误 5: 假设竞争条件和死锁是不可能的<a class="headerlink" href="#225-错误-5-假设竞争条件和死锁是不可能的" title="Permanent link">&para;</a></h3>
<p><strong>22.5 Error 5: Assuming Race Conditions and Deadlocks are Impossible</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="134:2"><input checked="checked" id="__tabbed_134_1" name="__tabbed_134" type="radio" /><input id="__tabbed_134_2" name="__tabbed_134" type="radio" /><div class="tabbed-labels"><label for="__tabbed_134_1">English</label><label for="__tabbed_134_2">Chinese</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<p>Concurrent programming has the hazard of concurrency-specific failure modes.</p>
<p>This includes problems such as race conditions and deadlocks.</p>
<p>A race condition involves two or more units of concurrency executing the same critical section at the same time and leaving a resource or data in an inconsistent or unexpected state. This can lead to data corruption and data loss.</p>
<p>A deadlock is when a unit of concurrency waits for a condition that can never occur, such as for a resource to become available.</p>
<p>Many Python developers believe these problems are not possible with coroutines in asyncio.</p>
<p>The reason being that only one coroutine can run within the event loop at any one time.</p>
<p>It is true that only one coroutine can run at a time.</p>
<p>The problem is, coroutines can suspend and resume and may do so while using a shared resource or shared variable.</p>
<p>Without protecting critical sections, race conditions can occur in asyncio programs.</p>
<p>Without careful management of synchronization primitives, deadlocks can occur</p>
<p>As such, it is important that asyncio programs are created ensuring coroutine-safety, a concept similar to thread-safety and process-safety, applied to coroutines.</p>
</div>
<div class="tabbed-block">
<p>并发编程存在并发特定故障模式的危险。</p>
<p>这包括竞争条件和死锁等问题。</p>
<p>竞争条件涉及两个或多个并发单元同时执行同一关键部分，并使资源或数据处于不一致或意外状态。 这可能会导致数据损坏和数据丢失。</p>
<p>死锁是指并发单元等待永远不会发生的条件，例如资源可用。</p>
<p>许多 Python 开发人员认为 <strong>asyncio</strong> 中的协程不可能出现这些问题。</p>
<p>原因是任一时间只有一个协程可以在事件循环内运行。</p>
<p>确实，一次只能运行一个协程。</p>
<p>问题是，协程可以挂起和恢复，并且可以在使用共享资源或共享变量时执行此操作。</p>
<p>如果不保护关键部分，异步程序中可能会出现竞争条件。</p>
<p>如果不仔细管理同步原语，可能会发生死锁</p>
<p>因此，创建 <strong>asyncio</strong> 程序以确保协程安全（类似于线程安全和进程安全的概念）非常重要，适用于协程。</p>
</div>
</div>
</div>
<h2 id="23-python-asyncio-常见问题">23. Python Asyncio 常见问题<a class="headerlink" href="#23-python-asyncio-常见问题" title="Permanent link">&para;</a></h2>
<p><strong>23. Python Asyncio Common Questions</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="135:2"><input checked="checked" id="__tabbed_135_1" name="__tabbed_135" type="radio" /><input id="__tabbed_135_2" name="__tabbed_135" type="radio" /><div class="tabbed-labels"><label for="__tabbed_135_1">English</label><label for="__tabbed_135_2">Chinese</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<p>This section answers common questions asked by developers when using asyncio in Python.</p>
<p><strong>Do you have a question about asyncio?</strong></p>
<p>Ask your question in the comments below and I will do my best to answer it and perhaps add it to this list of questions.</p>
</div>
<div class="tabbed-block">
<p>本节回答开发人员在 Python 中使用 <strong>asyncio</strong> 时提出的常见问题。</p>
<p><strong>您对 asyncio 有疑问吗?</strong></p>
<p>在下面的评论中提出您的问题，我会尽力回答它，也许会将其添加到这个问题列表中。</p>
</div>
</div>
</div>
<h3 id="231-如何停止任务">23.1 如何停止任务？<a class="headerlink" href="#231-如何停止任务" title="Permanent link">&para;</a></h3>
<p><strong>23.1 How to Stop a Task?</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="136:2"><input checked="checked" id="__tabbed_136_1" name="__tabbed_136" type="radio" /><input id="__tabbed_136_2" name="__tabbed_136" type="radio" /><div class="tabbed-labels"><label for="__tabbed_136_1">English</label><label for="__tabbed_136_2">Chinese</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<p>We can cancel a task via the <strong>cancel()</strong> method on an <a href="https://docs.python.org/3/library/asyncio-task.html#asyncio.Task.cancel">asyncio.Task</a> object.</p>
<p>The <strong>cancel()</strong> method returns True if the task was canceled, or False otherwise.</p>
<p>For example:</p>
<div class="highlight"><pre><span></span><code><span class="o">...</span>
<span class="c1"># cancel the task</span>
<span class="n">was_cancelled</span> <span class="o">=</span> <span class="n">task</span><span class="o">.</span><span class="n">cancel</span><span class="p">()</span>
</code></pre></div>
<p>If the task is already done, it cannot be canceled and the cancel() method will return False and the task will not have the status of canceled.</p>
<p>The next time the task is given an opportunity to run, it will raise a CancelledError exception.</p>
<p>If the CancelledError exception is not handled within the wrapped coroutine, the task will be canceled.</p>
<p>Otherwise, if the CancelledError exception is handled within the wrapped coroutine, the task will not be canceled.</p>
<p>The cancel() method can also take a message argument which will be used in the content of the CancelledError.</p>
<p>We can explore how to cancel a running task.</p>
<p>In this example, we define a task coroutine that reports a message and then blocks for a moment.</p>
<p>We then define the main coroutine that is used as the entry point into the asyncio program. It reports a message, creates and schedules the task, then waits a moment.</p>
<p>The main coroutine then resumes and cancels the task while it is running. It waits a moment more to allow the task to respond to the request to cancel. The main coroutine then reports whether the request to cancel the task was successful.</p>
<p>The task is canceled and is then done.</p>
<p>The main coroutine then reports whether the status of the task is canceled before closing the program.</p>
<p>The complete example is listed below.</p>
<div class="highlight"><pre><span></span><code><span class="c1"># SuperFastPython.com</span>
<span class="c1"># example of canceling a running task</span>
<span class="kn">import</span> <span class="nn">asyncio</span>

<span class="c1"># define a coroutine for a task</span>
<span class="k">async</span> <span class="k">def</span> <span class="nf">task_coroutine</span><span class="p">():</span>
    <span class="c1"># report a message</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;executing the task&#39;</span><span class="p">)</span>
    <span class="c1"># block for a moment</span>
    <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

<span class="c1"># custom coroutine</span>
<span class="k">async</span> <span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="c1"># report a message</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;main coroutine started&#39;</span><span class="p">)</span>
    <span class="c1"># create and schedule the task</span>
    <span class="n">task</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">create_task</span><span class="p">(</span><span class="n">task_coroutine</span><span class="p">())</span>
    <span class="c1"># wait a moment</span>
    <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">0.1</span><span class="p">)</span>
    <span class="c1"># cancel the task</span>
    <span class="n">was_cancelled</span> <span class="o">=</span> <span class="n">task</span><span class="o">.</span><span class="n">cancel</span><span class="p">()</span>
    <span class="c1"># report whether the cancel request was successful</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;was canceled: </span><span class="si">{</span><span class="n">was_cancelled</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="c1"># wait a moment</span>
    <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">0.1</span><span class="p">)</span>
    <span class="c1"># check the status of the task</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;canceled: </span><span class="si">{</span><span class="n">task</span><span class="o">.</span><span class="n">cancelled</span><span class="p">()</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="c1"># report a final message</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;main coroutine done&#39;</span><span class="p">)</span>

<span class="c1"># start the asyncio program</span>
<span class="n">asyncio</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">main</span><span class="p">())</span>
</code></pre></div>
<p>Running the example starts the asyncio event loop and executes the <strong>main()</strong> coroutine.</p>
<p>The <strong>main()</strong> coroutine reports a message, then creates and schedules the task coroutine.</p>
<p>It then suspends and awaits a moment to allow the task coroutine to begin running.</p>
<p>The task runs, reports a message and sleeps for a while.</p>
<p>The <strong>main()</strong> coroutine resumes and cancels the task. It reports that the request to cancel the task was successful.</p>
<p>It then sleeps for a moment to allow the task to respond to the request to be canceled.</p>
<p>The <strong>task_coroutine()</strong> resumes and a <strong>CancelledError</strong> exception is raised that causes the task to fail and be done.</p>
<p>The <strong>main()</strong> coroutine resumes and reports whether the task has the status of canceled. In this case, it does.</p>
<p>This example highlights the normal case of canceling a running task.</p>
<div class="highlight"><pre><span></span><code>main coroutine started
executing the task
was canceled: True
canceled: True
main coroutine done
</code></pre></div>
</div>
<div class="tabbed-block">
<p>我们可以通过 <a href="https://docs.python.org/3/library/asyncio-task.html#asyncio.Task.cancel">asyncio.Task</a> 对象上的 <strong>cancel()</strong> 方法取消任务。</p>
<p>如果任务被取消，则 <strong>cancel()</strong> 方法返回 <code>True</code>，否则返回 <code>False</code>。</p>
<p>例如:</p>
<div class="highlight"><pre><span></span><code><span class="o">...</span>
<span class="c1"># 取消任务</span>
<span class="n">was_cancelled</span> <span class="o">=</span> <span class="n">task</span><span class="o">.</span><span class="n">cancel</span><span class="p">()</span>
</code></pre></div>
<p>如果任务已经完成，则无法取消，<strong>cancel()</strong> 方法将返回 <code>False</code>，任务不会处于已取消状态。</p>
<p>下次任务有机会运行时，它将引发 <strong>CancelledError</strong> 异常。</p>
<p>如果未在包装的协程内处理 <strong>CancelledError</strong> 异常，则任务将被取消。</p>
<p>否则，如果在包装的协程内处理 <strong>CancelledError</strong> 异常，则任务将不会被取消。</p>
<p><strong>cancel()</strong> 方法同样还可以传递一个消息参数，作为 <strong>CancelledError</strong> 异常的内容。</p>
<p>我们可以探讨如何取消正在运行的任务。</p>
<p>在这个例子中，我们定义了一个任务协程，它报告一条消息，然后阻塞一会儿。</p>
<p>然后，我们定义用作 <strong>asyncio</strong> 程序入口点的主协程。 它报告一条消息，创建并安排任务，然后等待片刻。</p>
<p>然后，主协程在任务运行时恢复并取消任务。 它会再等待一段时间，以便任务响应取消请求。 然后主协程报告取消任务的请求是否成功。</p>
<p>任务被取消，然后完成。</p>
<p>然后主协程在关闭程序之前报告任务的状态是否已取消。</p>
<p>下面列出了完整的示例。</p>
<div class="highlight"><pre><span></span><code><span class="c1"># SuperFastPython.com</span>
<span class="c1"># 取消一个正在运行的任务的例子</span>
<span class="kn">import</span> <span class="nn">asyncio</span>

<span class="c1"># 为任务定义一个协程</span>
<span class="k">async</span> <span class="k">def</span> <span class="nf">task_coroutine</span><span class="p">():</span>
    <span class="c1"># 报告一条消息</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;executing the task&#39;</span><span class="p">)</span>
    <span class="c1"># 阻塞片刻</span>
    <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

<span class="c1"># 自定义协程</span>
<span class="k">async</span> <span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="c1"># 报告一条消息</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;main coroutine started&#39;</span><span class="p">)</span>
    <span class="c1"># 创建并调度任务</span>
    <span class="n">task</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">create_task</span><span class="p">(</span><span class="n">task_coroutine</span><span class="p">())</span>
    <span class="c1"># 等待一下</span>
    <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">0.1</span><span class="p">)</span>
    <span class="c1"># 取消任务</span>
    <span class="n">was_cancelled</span> <span class="o">=</span> <span class="n">task</span><span class="o">.</span><span class="n">cancel</span><span class="p">()</span>
    <span class="c1"># 报告取消请求是否成功</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;was canceled: </span><span class="si">{</span><span class="n">was_cancelled</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="c1"># 等待一下</span>
    <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">0.1</span><span class="p">)</span>
    <span class="c1"># 检查任务的状态</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;canceled: </span><span class="si">{</span><span class="n">task</span><span class="o">.</span><span class="n">cancelled</span><span class="p">()</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="c1"># 报告最后的消息</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;main coroutine done&#39;</span><span class="p">)</span>

<span class="c1"># 启动异步程序</span>
<span class="n">asyncio</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">main</span><span class="p">())</span>
</code></pre></div>
<p>运行该示例将启动 <strong>asyncio</strong> 事件循环并执行 <strong>main()</strong> 协程。</p>
<p><strong>main()</strong> 协程报告一条消息，然后创建并调度任务协程。</p>
<p>然后它会挂起并等待一段时间以允许任务协程开始运行。</p>
<p>该任务运行，报告消息并休眠一段时间。</p>
<p><strong>main()</strong> 协程恢复并取消任务。 它报告取消任务的请求已成功。</p>
<p>然后它会休眠一会儿，以允许任务响应要取消的请求。</p>
<p><strong>task_coroutine()</strong> 恢复并引发 <strong>CancelledError</strong> 异常，导致任务失败并完成。</p>
<p><strong>main()</strong> 协程恢复并报告任务是否处于已取消状态。 在这种情况下，确实如此。</p>
<p>此示例重点介绍了取消正在运行的任务的正常情况。</p>
<div class="highlight"><pre><span></span><code>main coroutine started
executing the task
was canceled: True
canceled: True
main coroutine done
</code></pre></div>
</div>
</div>
</div>
<h3 id="232-如何等待任务完成">23.2 如何等待任务完成？<a class="headerlink" href="#232-如何等待任务完成" title="Permanent link">&para;</a></h3>
<p><strong>23.2 How to Wait for a Task To Finish?</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="137:2"><input checked="checked" id="__tabbed_137_1" name="__tabbed_137" type="radio" /><input id="__tabbed_137_2" name="__tabbed_137" type="radio" /><div class="tabbed-labels"><label for="__tabbed_137_1">English</label><label for="__tabbed_137_2">Chinese</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<p>We can wait for a task to finish by awaiting the <strong>asyncio.Task</strong> object directly.</p>
<p>For example:</p>
<div class="highlight"><pre><span></span><code><span class="o">...</span>
<span class="c1"># wait for the task to finish</span>
<span class="k">await</span> <span class="n">task</span>
</code></pre></div>
<p>We may create and wait for the task in a single line.</p>
<p>For example:</p>
<div class="highlight"><pre><span></span><code><span class="o">...</span>
<span class="c1"># create and wait for the task to finish</span>
<span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">create_task</span><span class="p">(</span><span class="n">custom_coro</span><span class="p">())</span>
</code></pre></div>
</div>
<div class="tabbed-block">
<p>我们可以通过直接等待 <strong>asyncio.Task</strong> 对象来等待任务完成。</p>
<p>例如:</p>
<div class="highlight"><pre><span></span><code><span class="o">...</span>
<span class="c1"># 等待任务完成</span>
<span class="k">await</span> <span class="n">task</span>
</code></pre></div>
<p>我们可以在一行中创建并等待任务完成。</p>
<p>例如:</p>
<div class="highlight"><pre><span></span><code><span class="o">...</span>
<span class="c1"># 创建并等待任务完成</span>
<span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">create_task</span><span class="p">(</span><span class="n">custom_coro</span><span class="p">())</span>
</code></pre></div>
</div>
</div>
</div>
<h3 id="233-如何获取任务的返回值">23.3 如何获取任务的返回值？<a class="headerlink" href="#233-如何获取任务的返回值" title="Permanent link">&para;</a></h3>
<p><strong>23.3 How to Get a Return Value from a Task?</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="138:2"><input checked="checked" id="__tabbed_138_1" name="__tabbed_138" type="radio" /><input id="__tabbed_138_2" name="__tabbed_138" type="radio" /><div class="tabbed-labels"><label for="__tabbed_138_1">English</label><label for="__tabbed_138_2">Chinese</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<p>We may need to return values from coroutines to the caller.</p>
<p>We can retrieve a return value from a coroutine by awaiting it.</p>
<p>It assumes that the other coroutine being awaited returns a value.</p>
<p>For example:</p>
<div class="highlight"><pre><span></span><code><span class="c1"># coroutine that returns a value</span>
<span class="k">async</span> <span class="k">def</span> <span class="nf">other_coro</span><span class="p">():</span>
    <span class="k">return</span> <span class="mi">100</span>
</code></pre></div>
<p>Awaiting the other coroutine will suspend the calling coroutine and schedule the other coroutine for execution. Once the other coroutine has been completed, the calling coroutine will resume. The return value will be passed from the other coroutine to the caller.</p>
<p>For example:</p>
<div class="highlight"><pre><span></span><code><span class="o">...</span>
<span class="c1"># execute coroutine and retrieve return value</span>
<span class="n">value</span> <span class="o">=</span> <span class="k">await</span> <span class="n">other_coro</span><span class="p">()</span>
</code></pre></div>
<p>A coroutine can be wrapped in an <strong>asyncio.Task</strong> object.</p>
<p>This is helpful for independently executing the coroutine without having the current coroutine await it.</p>
<p>This can be achieved using the <a href="https://docs.python.org/3/library/asyncio-task.html#asyncio.create_task">asyncio.create_task()</a> function.</p>
<p>For example:</p>
<div class="highlight"><pre><span></span><code><span class="o">...</span>
<span class="c1"># wrap coroutine in a task and schedule it for execution</span>
<span class="n">task</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">create_task</span><span class="p">(</span><span class="n">other_coro</span><span class="p">())</span>
</code></pre></div>
<p>You can learn more about how to create tasks in the tutorial:</p>
<ul>
<li><a href="https://superfastpython.com/asyncio-create-task">How to Create an Asyncio Task in Python</a></li>
</ul>
<p>There are two ways to retrieve the return value from an asyncio.Task, they are:</p>
<ol>
<li>Await the task.</li>
<li>Call the result() method.</li>
</ol>
<p>We can await the task to retrieve the return value.</p>
<p>If the task is scheduled or running, then the caller will suspend until the task is complete and the return value will be provided.</p>
<p>If the task is completed, the return value will be provided immediately.</p>
<p>For example:</p>
<div class="highlight"><pre><span></span><code><span class="o">...</span>
<span class="c1"># get the return value from a task</span>
<span class="n">value</span> <span class="o">=</span> <span class="k">await</span> <span class="n">task</span>
</code></pre></div>
<p>Unlike a coroutine, we can await a task more than once without raising an error.</p>
<p>For example:</p>
<div class="highlight"><pre><span></span><code><span class="o">...</span>
<span class="c1"># get the return value from a task</span>
<span class="n">value</span> <span class="o">=</span> <span class="k">await</span> <span class="n">task</span>
<span class="c1"># get the return value from a task</span>
<span class="n">value</span> <span class="o">=</span> <span class="k">await</span> <span class="n">task</span>
</code></pre></div>
<p>We can also get the return value from the task by calling the <a href="https://docs.python.org/3/library/asyncio-task.html#asyncio.Task.result">result()</a> method on the <strong>asyncio.Task</strong> object.</p>
<p>For example:</p>
<div class="highlight"><pre><span></span><code><span class="o">...</span>
<span class="c1"># get the return value from a task</span>
<span class="n">value</span> <span class="o">=</span> <span class="n">task</span><span class="o">.</span><span class="n">result</span><span class="p">()</span>
</code></pre></div>
<p>This requires that the task is done. If not, an <strong>InvalidStateError</strong> exception will be raised.</p>
<p>If the task was canceled a <strong>CancelledError</strong> exception will be raised.</p>
<p>You can learn more about getting the result from tasks in the tutorial:</p>
<ul>
<li><a href="https://superfastpython.com/asyncio-task-result">How to Get Asyncio Task Results</a></li>
</ul>
</div>
<div class="tabbed-block">
<p>我们可能需要将值从协程返回给调用者。</p>
<p>我们可以通过等待协程来检索返回值。</p>
<p>它假设正在等待的另一个协程返回一个值。</p>
<p>例如:</p>
<div class="highlight"><pre><span></span><code><span class="c1"># 有返回值的协程</span>
<span class="k">async</span> <span class="k">def</span> <span class="nf">other_coro</span><span class="p">():</span>
    <span class="k">return</span> <span class="mi">100</span>
</code></pre></div>
<p>等待另一个协程将挂起<strong>调用协程</strong>并安排另一个协程执行。 一旦其他协程完成，调用协程将恢复。 返回值将从另一个协程传递给调用者。</p>
<p>例如:</p>
<div class="highlight"><pre><span></span><code><span class="o">...</span>
<span class="c1"># 执行协程并获取返回值</span>
<span class="n">value</span> <span class="o">=</span> <span class="k">await</span> <span class="n">other_coro</span><span class="p">()</span>
</code></pre></div>
<p>协程可以包装在 <strong>asyncio.Task</strong> 对象中。</p>
<p><strong>这对于独立执行协程很有帮助，而无需当前协程等待它。</strong></p>
<p>这可以使用 <a href="https://docs.python.org/3/library/asyncio-task.html#asyncio.create_task">asyncio.create_task()</a> 函数来实现。</p>
<p>例如:</p>
<div class="highlight"><pre><span></span><code><span class="o">...</span>
<span class="c1"># 将协程包装在任务中并安排其执行</span>
<span class="n">task</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">create_task</span><span class="p">(</span><span class="n">other_coro</span><span class="p">())</span>
</code></pre></div>
<p>您可以在教程中了解有关如何创建任务的更多信息：</p>
<ul>
<li><a href="https://superfastpython.com/asyncio-create-task">在Python中如何创建一个Asyncio任务</a></li>
</ul>
<p>有两种方法可以从 <strong>asyncio.Task</strong> 中检索返回值，它们是：</p>
<ol>
<li>等待任务.</li>
<li>调用 <strong>result()</strong> 方法.</li>
</ol>
<p>我们可以等待任务来检索返回值。</p>
<p>如果任务已调度或正在运行，则调用者将挂起，直到任务完成并提供返回值。</p>
<p>如果任务完成，将立即提供返回值。</p>
<p>例如:</p>
<div class="highlight"><pre><span></span><code><span class="o">...</span>
<span class="c1"># 获取任务的返回值</span>
<span class="n">value</span> <span class="o">=</span> <span class="k">await</span> <span class="n">task</span>
</code></pre></div>
<p>与协程不同，我们可以多次等待任务而不会引发错误。</p>
<p>例如:</p>
<div class="highlight"><pre><span></span><code><span class="o">...</span>
<span class="c1"># 获取任务的返回值</span>
<span class="n">value</span> <span class="o">=</span> <span class="k">await</span> <span class="n">task</span>
<span class="c1"># 获取任务的返回值</span>
<span class="n">value</span> <span class="o">=</span> <span class="k">await</span> <span class="n">task</span>
</code></pre></div>
<p>我们还可以通过调用 <strong>asyncio.Task</strong> 对象上的 <a href="https://docs.python.org/3/library/asyncio-task.html#asyncio.Task.result">result()</a> 方法来获取任务的返回值。</p>
<p>例如:</p>
<div class="highlight"><pre><span></span><code><span class="o">...</span>
<span class="c1"># 获取任务的返回值</span>
<span class="n">value</span> <span class="o">=</span> <span class="n">task</span><span class="o">.</span><span class="n">result</span><span class="p">()</span>
</code></pre></div>
<p>这就要求任务完成。 如果不是，将引发 <strong>InvalidStateError</strong> 异常。</p>
<p>如果任务被取消，则会引发 <strong>CancelledError</strong> 异常。</p>
<p>您可以了解有关从教程中的任务获取结果的更多信息：</p>
<ul>
<li><a href="https://superfastpython.com/asyncio-task-result">如何获取 Asyncio 任务结果</a></li>
</ul>
</div>
</div>
</div>
<h3 id="234-如何在后台运行任务">23.4 如何在后台运行任务？<a class="headerlink" href="#234-如何在后台运行任务" title="Permanent link">&para;</a></h3>
<p><strong>23.4 How to Run a Task in the Background?</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="139:2"><input checked="checked" id="__tabbed_139_1" name="__tabbed_139" type="radio" /><input id="__tabbed_139_2" name="__tabbed_139" type="radio" /><div class="tabbed-labels"><label for="__tabbed_139_1">English</label><label for="__tabbed_139_2">Chinese</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<p>We can run a coroutine in the background by wrapping it in an <strong>asyncio.Task</strong> object.</p>
<p>This can be achieved by calling the <strong>asyncio.create_task()</strong> function and passing it the coroutine.</p>
<p>The coroutine will be wrapped in a Task object and will be scheduled for execution. The task object will be returned and the caller will not suspend.</p>
<p>For example:</p>
<div class="highlight"><pre><span></span><code><span class="o">...</span>
<span class="c1"># schedule the task for execution</span>
<span class="n">task</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">create_task</span><span class="p">(</span><span class="n">other_coroutine</span><span class="p">())</span>
</code></pre></div>
<p>The task will not begin executing until at least the current coroutine is suspended, for any reason.</p>
<p>We can help things along by suspending for a moment to allow the task to start running.</p>
<p>This can be achieved by sleeping for zero seconds.</p>
<p>For example:</p>
<div class="highlight"><pre><span></span><code><span class="o">...</span>
<span class="c1"># suspend for a moment to allow the task to start running</span>
<span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
</code></pre></div>
<p>This will suspend the caller only for a brief moment and allow the ask an opportunity to run.</p>
<p>This is not required as the caller may suspend at some future time or terminate as part of normal execution.</p>
<p>We may also await the task directly once the caller has run out of things to do.</p>
<p>For example:</p>
<div class="highlight"><pre><span></span><code><span class="o">...</span>
<span class="c1"># wait for the task to complete</span>
<span class="k">await</span> <span class="n">task</span>
</code></pre></div>
</div>
<div class="tabbed-block">
<p>我们可以通过将协程包装在 <strong>asyncio.Task</strong> 对象中来在后台运行协程。</p>
<p>这可以通过调用 <strong>asyncio.create_task()</strong> 函数并向其传递协程来实现。</p>
<p>协程将被包装在 Task 对象中并被安排执行。 任务对象将被返回，并且调用者不会挂起。</p>
<p>例如:</p>
<div class="highlight"><pre><span></span><code><span class="o">...</span>
<span class="c1"># 调度任务执行</span>
<span class="n">task</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">create_task</span><span class="p">(</span><span class="n">other_coroutine</span><span class="p">())</span>
</code></pre></div>
<p>至少在当前协程出于任何原因被挂起之前，该任务不会开始执行。</p>
<p>我们可以通过暂停片刻以允许任务开始运行来帮助完成任务。</p>
<p>这可以通过休眠零秒来实现。</p>
<p>例如:</p>
<div class="highlight"><pre><span></span><code><span class="o">...</span>
<span class="c1"># 暂停片刻以允许任务开始运行</span>
<span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
</code></pre></div>
<p>这只会将调用者暂停一小会儿，并允许有机会运行。</p>
<p>这不是必需的，因为调用者可能会在将来的某个时间挂起或作为正常执行的一部分终止。</p>
<p>一旦调用者没有事情可做，我们也可以直接等待任务。</p>
<p>例如:</p>
<div class="highlight"><pre><span></span><code><span class="o">...</span>
<span class="c1"># 等待任务完成</span>
<span class="k">await</span> <span class="n">task</span>
</code></pre></div>
</div>
</div>
</div>
<h3 id="235-如何等待所有后台任务">23.5 如何等待所有后台任务？<a class="headerlink" href="#235-如何等待所有后台任务" title="Permanent link">&para;</a></h3>
<p><strong>23.5 How to Wait for All Background Tasks?</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="140:2"><input checked="checked" id="__tabbed_140_1" name="__tabbed_140" type="radio" /><input id="__tabbed_140_2" name="__tabbed_140" type="radio" /><div class="tabbed-labels"><label for="__tabbed_140_1">English</label><label for="__tabbed_140_2">Chinese</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<p>We can wait for all independent tasks in an asyncio program.</p>
<p>This can be achieved by first getting a set of all currently running tasks via the <strong>asyncio.all_tasks()</strong> function.</p>
<p>For example:</p>
<div class="highlight"><pre><span></span><code><span class="o">...</span>
<span class="c1"># get a set of all running tasks</span>
<span class="n">all_tasks</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">all_tasks</span><span class="p">()</span>
</code></pre></div>
<p>This will return a set that contains one <strong>asyncio.Task</strong> object for each task that is currently running, including the <strong>main()</strong> coroutine.</p>
<p>We cannot wait on this set directly, as it will block forever as it includes the task that is the current task.</p>
<p>Therefore we can get the <strong>asyncio.Task</strong> object for the currently running task and remove it from the set.</p>
<p>This can be achieved by first calling the <strong>asyncio.current_task()</strong> method to get the task for the current coroutine and then remove it from the set via the <strong>remove()</strong> method.</p>
<p>For example:</p>
<div class="highlight"><pre><span></span><code><span class="o">...</span>
<span class="c1"># get the current tasks</span>
<span class="n">current_task</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">current_task</span><span class="p">()</span>
<span class="c1"># remove the current task from the list of all tasks</span>
<span class="n">all_tasks</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">current_task</span><span class="p">)</span>
</code></pre></div>
<p>Finally, we can wait on the set of remaining tasks.</p>
<p>This will suspend the caller until all tasks in the set are complete.</p>
<p>For example:</p>
<div class="highlight"><pre><span></span><code><span class="o">...</span>
<span class="c1"># suspend until all tasks are completed</span>
<span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">wait</span><span class="p">(</span><span class="n">all_tasks</span><span class="p">)</span>
</code></pre></div>
<p>Tying this together, the snippet below added to the end of the <strong>main()</strong> coroutine will wait for all background tasks to complete.</p>
<div class="highlight"><pre><span></span><code><span class="o">...</span>
<span class="c1"># get a set of all running tasks</span>
<span class="n">all_tasks</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">all_tasks</span><span class="p">()</span>
<span class="c1"># get the current tasks</span>
<span class="n">current_task</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">current_task</span><span class="p">()</span>
<span class="c1"># remove the current task from the list of all tasks</span>
<span class="n">all_tasks</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">current_task</span><span class="p">)</span>
<span class="c1"># suspend until all tasks are completed</span>
<span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">wait</span><span class="p">(</span><span class="n">all_tasks</span><span class="p">)</span>
</code></pre></div>
</div>
<div class="tabbed-block">
<p>我们可以等待 asyncio 程序中的所有独立任务。</p>
<p>首先可以通过 <strong>asyncio.all_tasks()</strong> 函数获取一组所有当前正在运行的任务来实现。</p>
<p>例如:</p>
<div class="highlight"><pre><span></span><code><span class="o">...</span>
<span class="c1"># 获取所有正在运行的任务的集合</span>
<span class="n">all_tasks</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">all_tasks</span><span class="p">()</span>
</code></pre></div>
<p>这将返回一个集合，其中包含当前正在运行的每个任务的一个 <strong>asyncio.Task</strong> 对象，包括 <strong>main()</strong> 协程。</p>
<p>我们不能直接等待这个集合，因为它会永远阻塞，因为它包含当前任务的任务。</p>
<p>因此，我们可以获取当前正在运行的任务的 <strong>asyncio.Task</strong> 对象并将其从集合中删除。</p>
<p>这首先可以通过调用 <strong>asyncio.current_task()</strong> 方法来获取当前协程的任务，然后通过 <strong>remove()</strong> 方法将其从集合中删除来实现。</p>
<p>例如:</p>
<div class="highlight"><pre><span></span><code><span class="o">...</span>
<span class="c1"># 获取当前任务</span>
<span class="n">current_task</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">current_task</span><span class="p">()</span>
<span class="c1"># 从所有任务列表中删除当前任务</span>
<span class="n">all_tasks</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">current_task</span><span class="p">)</span>
</code></pre></div>
<p>最后，我们可以等待剩余的任务集。</p>
<p>这将挂起调用者，直到该组中的所有任务完成。</p>
<p>例如:</p>
<div class="highlight"><pre><span></span><code><span class="o">...</span>
<span class="c1"># 挂起直到所有任务完成</span>
<span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">wait</span><span class="p">(</span><span class="n">all_tasks</span><span class="p">)</span>
</code></pre></div>
<p>将它们结合在一起，添加到 <strong>main()</strong> 协程末尾的下面的代码片段将等待所有后台任务完成。</p>
<div class="highlight"><pre><span></span><code><span class="o">...</span>
<span class="c1"># 获取所有正在运行的任务的集合</span>
<span class="n">all_tasks</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">all_tasks</span><span class="p">()</span>
<span class="c1"># 获取当前任务</span>
<span class="n">current_task</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">current_task</span><span class="p">()</span>
<span class="c1"># 从所有任务列表中删除当前任务</span>
<span class="n">all_tasks</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">current_task</span><span class="p">)</span>
<span class="c1"># 挂起直到所有任务完成</span>
<span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">wait</span><span class="p">(</span><span class="n">all_tasks</span><span class="p">)</span>
</code></pre></div>
</div>
</div>
</div>
<h3 id="236-正在运行的任务是否会阻止事件循环退出">23.6 正在运行的任务是否会阻止事件循环退出？<a class="headerlink" href="#236-正在运行的任务是否会阻止事件循环退出" title="Permanent link">&para;</a></h3>
<p><strong>23.6 Does a Running Task Stop the Event Loop from Exiting?</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="141:2"><input checked="checked" id="__tabbed_141_1" name="__tabbed_141" type="radio" /><input id="__tabbed_141_2" name="__tabbed_141" type="radio" /><div class="tabbed-labels"><label for="__tabbed_141_1">English</label><label for="__tabbed_141_2">Chinese</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<p>No.</p>
<p>A task that is scheduled and run independently will not stop the event loop from exiting.</p>
<p>If your main coroutine has no other activities to complete and there are independent tasks running in the background, you should retrieve the running tasks and wait on them</p>
<p>The previous question/answer shows exactly how to do this.</p>
</div>
<div class="tabbed-block">
<p>不。</p>
<p>独立调度和运行的任务不会阻止事件循环退出。</p>
<p>如果您的主协程没有其他活动需要完成，并且有独立任务在后台运行，您应该检索正在运行的任务并等待它们</p>
<p>上一个问题/答案准确地展示了如何做到这一点。</p>
</div>
</div>
</div>
<h3 id="237-如何显示运行任务的进度">23.7 如何显示运行任务的进度？<a class="headerlink" href="#237-如何显示运行任务的进度" title="Permanent link">&para;</a></h3>
<p><strong>23.7 How to Show Progress of Running Tasks?</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="142:2"><input checked="checked" id="__tabbed_142_1" name="__tabbed_142" type="radio" /><input id="__tabbed_142_2" name="__tabbed_142" type="radio" /><div class="tabbed-labels"><label for="__tabbed_142_1">English</label><label for="__tabbed_142_2">Chinese</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<p>We can show progress using a done callback function on each task.</p>
<p>A done callback is a function that we can register on an <strong>asyncio.Task</strong>.</p>
<p>It is called once the task is done, either normally or if it fails.</p>
<p>The done callback function is a regular function, not a coroutine, and takes the <strong>asyncio.Task</strong> that it is associated with as an argument.</p>
<p>We can use the same callback function for all tasks and report progress in a general way, such as by reporting a message.</p>
<p>For example:</p>
<div class="highlight"><pre><span></span><code><span class="c1"># callback function to show progress of tasks</span>
<span class="k">def</span> <span class="nf">progress</span><span class="p">(</span><span class="n">task</span><span class="p">):</span>
    <span class="c1"># report progress of the task</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
</code></pre></div>
<p>We can register a callback function on each <strong>asyncio.Task</strong> that we issue.</p>
<p>This can be achieved using the <a href="https://docs.python.org/3/library/asyncio-task.html#asyncio.Task.add_done_callback">add_done_callback()</a> method on each task and passing it the name of the callback function.</p>
<p>For example:</p>
<div class="highlight"><pre><span></span><code><span class="o">...</span>
<span class="c1"># add a done callback to a task</span>
<span class="n">task</span><span class="o">.</span><span class="n">add_done_callback</span><span class="p">(</span><span class="n">progress</span><span class="p">)</span>
</code></pre></div>
</div>
<div class="tabbed-block">
<p>我们可以使用每个任务的回调函数来显示进度。</p>
<p>执行完成后的回调函数是我们可以在 <strong>asyncio.Task</strong> 上注册的函数。</p>
<p>一旦任务执行完，无论正常还是失败，都会调用它。</p>
<p>done 回调函数是一个常规函数，而不是协程，并且将与其关联的 <strong>asyncio.Task</strong> 作为参数。</p>
<p>我们可以对所有任务使用相同的回调函数，并以通用方式报告进度，例如报告消息。</p>
<p>例如:</p>
<div class="highlight"><pre><span></span><code><span class="c1"># 回调函数显示任务进度</span>
<span class="k">def</span> <span class="nf">progress</span><span class="p">(</span><span class="n">task</span><span class="p">):</span>
    <span class="c1"># 报告任务进度</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
</code></pre></div>
<p>我们可以在我们发出的每个 <strong>asyncio.Task</strong> 上注册一个回调函数。</p>
<p>这可以通过在每个任务上使用 <a href="https://docs.python.org/3/library/asyncio-task.html#asyncio.Task.add_done_callback">add_done_callback()</a> 方法并向其传递回调函数的名称来实现。</p>
<p>例如:</p>
<div class="highlight"><pre><span></span><code><span class="o">...</span>
<span class="c1"># 向任务添加回调函数</span>
<span class="n">task</span><span class="o">.</span><span class="n">add_done_callback</span><span class="p">(</span><span class="n">progress</span><span class="p">)</span>
</code></pre></div>
</div>
</div>
</div>
<h3 id="238-如何在延迟后运行任务">23.8 如何在延迟后运行任务？<a class="headerlink" href="#238-如何在延迟后运行任务" title="Permanent link">&para;</a></h3>
<p><strong>23.8 How to Run a Task After a Delay?</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="143:2"><input checked="checked" id="__tabbed_143_1" name="__tabbed_143" type="radio" /><input id="__tabbed_143_2" name="__tabbed_143" type="radio" /><div class="tabbed-labels"><label for="__tabbed_143_1">English</label><label for="__tabbed_143_2">Chinese</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<p>We can develop a custom wrapper coroutine to execute a target coroutine after a delay.</p>
<p>The wrapper coroutine may take two arguments, a coroutine and a time in seconds.</p>
<p>It will sleep for the given delay interval in seconds, then await the provided coroutine.</p>
<p>The <strong>delay()</strong> coroutine below implements this.</p>
<div class="highlight"><pre><span></span><code><span class="c1"># coroutine that will start another coroutine after a delay in seconds</span>
<span class="k">async</span> <span class="k">def</span> <span class="nf">delay</span><span class="p">(</span><span class="n">coro</span><span class="p">,</span> <span class="n">seconds</span><span class="p">):</span>
    <span class="c1"># suspend for a time limit in seconds</span>
    <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="n">seconds</span><span class="p">)</span>
    <span class="c1"># execute the other coroutine</span>
    <span class="k">await</span> <span class="n">coro</span>
</code></pre></div>
<p>To use the wrapper coroutine, a coroutine object can be created and either awaited directly or executed independently as a task.</p>
<p>For example, the caller may suspend and schedule the delayed coroutine and wait for it to be done:</p>
<div class="highlight"><pre><span></span><code><span class="o">...</span>
<span class="c1"># execute a coroutine after a delay</span>
<span class="k">await</span> <span class="n">delay</span><span class="p">(</span><span class="n">coro</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
</code></pre></div>
<p>Alternatively, the caller may schedule the delayed coroutine to run independently:</p>
<div class="highlight"><pre><span></span><code><span class="o">...</span>
<span class="c1"># execute a coroutine after a delay independently</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">create_task</span><span class="p">(</span><span class="n">delay</span><span class="p">(</span><span class="n">coro</span><span class="p">,</span> <span class="mi">10</span><span class="p">))</span>
</code></pre></div>
</div>
<div class="tabbed-block">
<p>我们可以开发一个自定义包装协程来在延迟后执行目标协程。</p>
<p>包装协程可以采用两个参数，一个协程和一个以秒为单位的时间。</p>
<p>它将休眠给定的延迟间隔（以秒为单位），然后等待提供的协程执行完毕。</p>
<p>下面的 <strong>delay()</strong> 协程实现了这一点。</p>
<div class="highlight"><pre><span></span><code><span class="c1"># 延迟几秒后启动另一个协程的协程</span>
<span class="k">async</span> <span class="k">def</span> <span class="nf">delay</span><span class="p">(</span><span class="n">coro</span><span class="p">,</span> <span class="n">seconds</span><span class="p">):</span>
    <span class="c1"># 暂停时间限制（以秒为单位）</span>
    <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="n">seconds</span><span class="p">)</span>
    <span class="c1"># 执行另一个协程</span>
    <span class="k">await</span> <span class="n">coro</span>
</code></pre></div>
<p>要使用包装协程，可以创建协程对象并直接等待或作为任务独立执行。</p>
<p>例如，调用者可以挂起并调度延迟协程并等待其完成：</p>
<div class="highlight"><pre><span></span><code><span class="o">...</span>
<span class="c1"># 延迟后执行协程</span>
<span class="k">await</span> <span class="n">delay</span><span class="p">(</span><span class="n">coro</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
</code></pre></div>
<p>或者，调用者可以安排延迟协程独立运行：</p>
<div class="highlight"><pre><span></span><code><span class="o">...</span>
<span class="c1"># 在延迟后独立执行协程</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">create_task</span><span class="p">(</span><span class="n">delay</span><span class="p">(</span><span class="n">coro</span><span class="p">,</span> <span class="mi">10</span><span class="p">))</span>
</code></pre></div>
</div>
</div>
</div>
<h3 id="239-如何运行后续任务">23.9 如何运行后续任务？<a class="headerlink" href="#239-如何运行后续任务" title="Permanent link">&para;</a></h3>
<p><strong>23.9 How to Run a Follow-Up Task?</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="144:2"><input checked="checked" id="__tabbed_144_1" name="__tabbed_144" type="radio" /><input id="__tabbed_144_2" name="__tabbed_144" type="radio" /><div class="tabbed-labels"><label for="__tabbed_144_1">English</label><label for="__tabbed_144_2">Chinese</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<p>There are three main ways to issue follow-up tasks in asyncio.</p>
<p>They are:</p>
<ol>
<li>Schedule the follow-up task from the completed task itself.</li>
<li>Schedule the follow-up task from the caller.</li>
<li>Schedule the follow-up task automatically using a done callback.</li>
</ol>
<p>Let’s take a closer look at each approach.</p>
<p>The task that is completed can issue its own follow-up task.</p>
<p>This may require checking some state in order to determine whether the follow-up task should be issued or not.</p>
<p>The task can then be scheduled via a call to <code>asyncio.create_task()</code>.</p>
<p>For example:</p>
<div class="highlight"><pre><span></span><code><span class="o">...</span>
<span class="c1"># schedule a follow-up task</span>
<span class="n">task</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">create_task</span><span class="p">(</span><span class="n">followup_task</span><span class="p">())</span>
</code></pre></div>
<p>The task itself may choose to await the follow-up task or let it complete in the background independently.</p>
<p>For example:</p>
<div class="highlight"><pre><span></span><code><span class="o">...</span>
<span class="c1"># wait for the follow-up task to complete</span>
<span class="k">await</span> <span class="n">task</span>
</code></pre></div>
<p>The caller that issued the task can choose to issue a follow-up task.</p>
<p>For example, when the caller issues the first task, it may keep the asyncio.Task object.</p>
<p>It can then check the result of the task or whether the task was completed successfully or not.</p>
<p>The caller can then decide to issue a follow-up task.</p>
<p>It may or may not await the follow-up task directly.</p>
<p>For example:</p>
<div class="highlight"><pre><span></span><code><span class="o">...</span>
<span class="c1"># issue and await the first task</span>
<span class="n">task</span> <span class="o">=</span> <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">create_task</span><span class="p">(</span><span class="n">task</span><span class="p">())</span>
<span class="c1"># check the result of the task</span>
<span class="k">if</span> <span class="n">task</span><span class="o">.</span><span class="n">result</span><span class="p">():</span>
    <span class="c1"># issue the follow-up task</span>
    <span class="n">followup</span> <span class="o">=</span> <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">create_task</span><span class="p">(</span><span class="n">followup_task</span><span class="p">())</span>
</code></pre></div>
<p>We can execute a follow-up task automatically using a done callback function.</p>
<p>For example, the caller that issues the task can register a done callback function on the task itself.</p>
<p>The done callback function must take the asyncio.Task object as an argument and will be called only after the task is done. It can then choose to issue a follow-up task.</p>
<p>The done callback function is a regular Python function, not a coroutine, so it cannot await the follow-up task</p>
<p>For example, the callback function may look as follows:</p>
<div class="highlight"><pre><span></span><code><span class="c1"># callback function</span>
<span class="k">def</span> <span class="nf">callback</span><span class="p">(</span><span class="n">task</span><span class="p">):</span>
    <span class="c1"># schedule and await the follow-up task</span>
    <span class="n">_</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">create_task</span><span class="p">(</span><span class="n">followup</span><span class="p">())</span>
</code></pre></div>
<p>The caller can issue the first task and register the done callback function.</p>
<p>For example:</p>
<div class="highlight"><pre><span></span><code><span class="o">...</span>
<span class="c1"># schedule and the task</span>
<span class="n">task</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">create_task</span><span class="p">(</span><span class="n">work</span><span class="p">())</span>
<span class="c1"># add the done callback function</span>
<span class="n">task</span><span class="o">.</span><span class="n">add_done_callback</span><span class="p">(</span><span class="n">callback</span><span class="p">)</span>
</code></pre></div>
</div>
<div class="tabbed-block">
<p><strong>asyncio</strong> 中发出<strong>后续任务</strong>(follow-up tasks)的方式主要有三种。</p>
<p>他们是:</p>
<ol>
<li>从已完成的任务本身调度后续任务。</li>
<li>从调用者调度后续任务。</li>
<li>使用回调函数自动调度后续任务。</li>
</ol>
<p>让我们仔细看看每种方法。</p>
<p>完成的任务可以发出自己的后续任务。</p>
<p>这可能需要检查某些状态以确定是否应该发出后续任务。</p>
<p>然后可以通过调用 <code>asyncio.create_task()</code> 来安排任务 .</p>
<p>例如:</p>
<div class="highlight"><pre><span></span><code><span class="o">...</span>
<span class="c1"># schedule a follow-up task</span>
<span class="n">task</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">create_task</span><span class="p">(</span><span class="n">followup_task</span><span class="p">())</span>
</code></pre></div>
<p>任务本身可以<strong>选择等待</strong>后续任务或让它在后台独立完成。</p>
<p>例如:</p>
<div class="highlight"><pre><span></span><code><span class="o">...</span>
<span class="c1"># 等待后续任务执行完毕</span>
<span class="k">await</span> <span class="n">task</span>
</code></pre></div>
<p>下发任务的调用者可以选择下发后续任务。</p>
<p>例如，当调用者发出第一个任务时，它可能会保留 <code>asyncio.Task</code> 对象。</p>
<p>然后它可以检查任务的结果或任务是否成功完成。</p>
<p>然后调用者可以决定是否发出后续任务。</p>
<p>它也可以直接选择等待/不等待后续任务执行完毕。</p>
<p>例如:</p>
<div class="highlight"><pre><span></span><code><span class="o">...</span>
<span class="c1"># 发出并等待第一个任务</span>
<span class="n">task</span> <span class="o">=</span> <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">create_task</span><span class="p">(</span><span class="n">task</span><span class="p">())</span>
<span class="c1"># 检查任务结果</span>
<span class="k">if</span> <span class="n">task</span><span class="o">.</span><span class="n">result</span><span class="p">():</span>
    <span class="c1"># 下达后续任务</span>
    <span class="n">followup</span> <span class="o">=</span> <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">create_task</span><span class="p">(</span><span class="n">followup_task</span><span class="p">())</span>
</code></pre></div>
<p>我们可以使用回调函数自动执行后续任务。</p>
<p>例如，发出任务的调用者可以在任务本身上注册执行完成后的回调函数。</p>
<p>回调函数必须将 <code>asyncio.Task</code> 对象作为参数，并且只有在任务完成后才会被调用。 然后它可以选择是否发出后续任务。</p>
<p>回调函数是一个常规的Python函数，而不是协程，因此它不能等待后续任务</p>
<p>例如，回调函数可能如下所示：</p>
<div class="highlight"><pre><span></span><code><span class="c1"># 回调函数</span>
<span class="k">def</span> <span class="nf">callback</span><span class="p">(</span><span class="n">task</span><span class="p">):</span>
    <span class="c1"># 调度并等待后续任务</span>
    <span class="n">_</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">create_task</span><span class="p">(</span><span class="n">followup</span><span class="p">())</span>
</code></pre></div>
<p>调用者可以发出第一个任务并注册执行完成后的回调函数。</p>
<p>例如:</p>
<div class="highlight"><pre><span></span><code><span class="o">...</span>
<span class="c1"># 调度任务</span>
<span class="n">task</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">create_task</span><span class="p">(</span><span class="n">work</span><span class="p">())</span>
<span class="c1"># 添加执行完后的回调函数</span>
<span class="n">task</span><span class="o">.</span><span class="n">add_done_callback</span><span class="p">(</span><span class="n">callback</span><span class="p">)</span>
</code></pre></div>
</div>
</div>
</div>
<h3 id="2310-如何在-asyncio-中执行阻塞-io-或-cpu-密集型函数">23.10 如何在 Asyncio 中执行阻塞 I/O 或 CPU 密集型函数？<a class="headerlink" href="#2310-如何在-asyncio-中执行阻塞-io-或-cpu-密集型函数" title="Permanent link">&para;</a></h3>
<p><strong>23.10 How to Execute a Blocking I/O or CPU-bound Function in Asyncio?</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="145:2"><input checked="checked" id="__tabbed_145_1" name="__tabbed_145" type="radio" /><input id="__tabbed_145_2" name="__tabbed_145" type="radio" /><div class="tabbed-labels"><label for="__tabbed_145_1">English</label><label for="__tabbed_145_2">Chinese</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<p>The asyncio module provides two approaches for executing blocking calls in asyncio programs.</p>
<p>The first is to use the <a href="https://docs.python.org/3/library/asyncio-task.html#asyncio.to_thread">asyncio.to_thread()</a> function.</p>
<p>This is in the high-level API and is intended for application developers.</p>
<p>The <a href="https://docs.python.org/3/library/asyncio-task.html#asyncio.to_thread">asyncio.to_thread()</a> function takes a function name to execute and any arguments.</p>
<p>The function is executed in a separate thread. It returns a coroutine that can be awaited or scheduled as an independent task.</p>
<p>For example:</p>
<div class="highlight"><pre><span></span><code><span class="o">...</span>
<span class="c1"># execute a function in a separate thread</span>
<span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">to_thread</span><span class="p">(</span><span class="n">task</span><span class="p">)</span>
</code></pre></div>
<p>The task will not begin executing until the returned coroutine is given an opportunity to run in the event loop.</p>
<p>The asyncio.to_thread() function creates a <strong>ThreadPoolExecutor</strong> behind the scenes to execute blocking calls.</p>
<p>As such, the <code>asyncio.to_thread()</code> function is only appropriate for IO-bound tasks.</p>
<p>An alternative approach is to use the <a href="https://docs.python.org/3/library/asyncio-eventloop.html#asyncio.loop.run_in_executor">loop.run_in_executor()</a> function.</p>
<p>This is in the low-level asyncio API and first requires access to the event loop, such as via the <a href="https://docs.python.org/3/library/asyncio-eventloop.html#asyncio.get_running_loop">asyncio.get_running_loop()</a> function.</p>
<p>The <code>loop.run_in_executor()</code> function takes an executor and a function to execute.</p>
<p>If None is provided for the executor, then the default executor is used, which is a ThreadPoolExecutor.</p>
<p>The <code>loop.run_in_executor()</code> function returns an awaitable that can be awaited if needed. The task will begin executing immediately, so the returned awaitable does not need to be awaited or scheduled for the blocking call to start executing.</p>
<p>For example:</p>
<div class="highlight"><pre><span></span><code><span class="o">...</span>
<span class="c1"># get the event loop</span>
<span class="n">loop</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">get_running_loop</span><span class="p">()</span>
<span class="c1"># execute a function in a separate thread</span>
<span class="k">await</span> <span class="n">loop</span><span class="o">.</span><span class="n">run_in_executor</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">task</span><span class="p">)</span>
</code></pre></div>
<p>Alternatively, an executor can be created and passed to the loop.run_in_executor() function, which will execute the asynchronous call in the executor.</p>
<p>The caller must manage the executor in this case, shutting it down once the caller is finished with it.</p>
<p>For example:</p>
<div class="highlight"><pre><span></span><code><span class="o">...</span>
<span class="c1"># create a process pool</span>
<span class="k">with</span> <span class="n">ProcessPoolExecutor</span> <span class="k">as</span> <span class="n">exe</span><span class="p">:</span>
    <span class="c1"># get the event loop</span>
    <span class="n">loop</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">get_running_loop</span><span class="p">()</span>
    <span class="c1"># execute a function in a separate thread</span>
    <span class="k">await</span> <span class="n">loop</span><span class="o">.</span><span class="n">run_in_executor</span><span class="p">(</span><span class="n">exe</span><span class="p">,</span> <span class="n">task</span><span class="p">)</span>
    <span class="c1"># process pool is shutdown automatically...</span>
</code></pre></div>
<p>These two approaches allow a blocking call to be executed as an asynchronous task in an asyncio program.</p>
</div>
<div class="tabbed-block">
<p>asyncio 模块提供了两种在 asyncio 程序中执行阻塞调用的方法。</p>
<p>第一种是使用 <a href="https://docs.python.org/3/library/asyncio-task.html#asyncio.to_thread">asyncio.to_thread()</a> 函数。</p>
<p>这是高级 API 中的内容，适用于应用程序开发人员。</p>
<p><code>asyncio.to_thread()</code> 函数接受要执行的函数名称和任何参数。</p>
<p>该函数在单独的线程中执行。 它返回一个可以作为独立任务等待或调度的协程。</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code><span class="o">...</span>
<span class="c1"># 在单独的线程中执行函数</span>
<span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">to_thread</span><span class="p">(</span><span class="n">task</span><span class="p">)</span>
</code></pre></div>
<p>任务一开始并不会执行。直到协程返回并且给个在事件循环中运行的机会时，才会运行。</p>
<p><code>asyncio.to_thread()</code> 函数在后台创建一个 <strong>ThreadPoolExecutor</strong> 来执行阻塞调用。</p>
<p>因此，<code>asyncio.to_thread()</code> 函数仅适用于 IO 密集型任务。</p>
<p>另一种方法是使用<a href="https://docs.python.org/3/library/asyncio-eventloop.html#asyncio.loop.run_in_executor">loop.run_in_executor()</a>函数。</p>
<p>这是在低级 asyncio API 中，首先需要访问事件循环，例如通过 <a href="https://docs.python.org/3/library/asyncio-eventloop.html#asyncio.get_running_loop">asyncio.get_running_loop()</a> 函数。</p>
<p><code>Loop.run_in_executor()</code> 函数需要一个执行器和一个要执行的函数。</p>
<p>如果没有为执行器提供参数，则默认值为 None，将使用默认执行器，即 <strong>ThreadPoolExecutor</strong>。</p>
<p><code>Loop.run_in_executor()</code> 函数返回一个可等待的对象，如果需要可以等待。 该任务将立即开始执行，因此不需要等待或安排返回的可等待对象来开始执行阻塞调用。</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code><span class="o">...</span>
<span class="c1"># 获取事件循环</span>
<span class="n">loop</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">get_running_loop</span><span class="p">()</span>
<span class="c1"># 在单独的线程中执行函数</span>
<span class="k">await</span> <span class="n">loop</span><span class="o">.</span><span class="n">run_in_executor</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">task</span><span class="p">)</span>
</code></pre></div>
<p>或者，可以创建一个执行器并将其传递给<code>loop.run_in_executor()</code>函数，该函数将在执行器中执行异步调用。</p>
<p>在这种情况下，调用者必须管理执行器，在调用者完成后将其关闭。</p>
<p>例如:</p>
<div class="highlight"><pre><span></span><code><span class="o">...</span>
<span class="c1"># 创建一个进程池</span>
<span class="k">with</span> <span class="n">ProcessPoolExecutor</span> <span class="k">as</span> <span class="n">exe</span><span class="p">:</span>
    <span class="c1"># 获取事件循环</span>
    <span class="n">loop</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">get_running_loop</span><span class="p">()</span>
    <span class="c1"># 在单独的线程中执行函数</span>
    <span class="c1"># process pool is shutdown automatically...</span>
    <span class="c1"># 进程池自动关闭...</span>
</code></pre></div>
<p>这两种方法允许阻塞调用作为 asyncio 程序中的异步任务执行。</p>
</div>
</div>
</div>
<h2 id="24-使用-asyncio-的常见反对意见">24. 使用 Asyncio 的常见反对意见<a class="headerlink" href="#24-使用-asyncio-的常见反对意见" title="Permanent link">&para;</a></h2>
<p><strong>24. Common Objections to Using Asyncio</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="146:2"><input checked="checked" id="__tabbed_146_1" name="__tabbed_146" type="radio" /><input id="__tabbed_146_2" name="__tabbed_146" type="radio" /><div class="tabbed-labels"><label for="__tabbed_146_1">English</label><label for="__tabbed_146_2">Chinese</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<p>Asyncio and coroutines may not be the best solution for all concurrency problems in your program.</p>
<p>That being said, there may also be some misunderstandings that are preventing you from making full and best use of the capabilities of the asyncio in Python.</p>
<p>In this section, we review some of the common objections seen by developers when considering using the asyncio.</p>
</div>
<div class="tabbed-block">
<p>异步和协程可能不是解决程序中所有并发问题的最佳解决方案。</p>
<p>话虽如此，也可能存在一些误解，阻碍您充分、最佳地利用 Python 中 asyncio 的功能。</p>
<p>在本节中，我们将回顾开发人员在考虑使用 asyncio 时遇到的一些常见反对意见。</p>
</div>
</div>
</div>
<h3 id="241-全局解释器锁-gil-怎么样">24.1 全局解释器锁 (GIL) 怎么样？<a class="headerlink" href="#241-全局解释器锁-gil-怎么样" title="Permanent link">&para;</a></h3>
<p><strong>24.1 What About the Global Interpreter Lock (GIL)?</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="147:2"><input checked="checked" id="__tabbed_147_1" name="__tabbed_147" type="radio" /><input id="__tabbed_147_2" name="__tabbed_147" type="radio" /><div class="tabbed-labels"><label for="__tabbed_147_1">English</label><label for="__tabbed_147_2">Chinese</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<p>The GIL protects the internals of the Python interpreter from concurrent access and modification from multiple threads.</p>
<p>The asyncio event loop runs in one thread.</p>
<p>This means that all coroutines run in a single thread.</p>
<p>As such the GIL is not an issue when using asyncio and coroutine.</p>
</div>
<div class="tabbed-block">
<p>GIL 保护 Python 解释器的内部免受多个线程的并发访问和修改。</p>
<p>asyncio 事件循环在一个线程中运行。</p>
<p>这意味着所有协程都在单个线程中运行。</p>
<p>因此，使用 asyncio 和协程时，GIL 不是问题。</p>
</div>
</div>
</div>
<h3 id="242-python-协程是真实的吗">24.2 Python 协程是“真实的”吗？<a class="headerlink" href="#242-python-协程是真实的吗" title="Permanent link">&para;</a></h3>
<p><strong>24.2 Are Python Coroutines “Real“?</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="148:2"><input checked="checked" id="__tabbed_148_1" name="__tabbed_148" type="radio" /><input id="__tabbed_148_2" name="__tabbed_148" type="radio" /><div class="tabbed-labels"><label for="__tabbed_148_1">English</label><label for="__tabbed_148_2">Chinese</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<p>Coroutines are managed in software.</p>
<p>Coroutines run and are managed (switched) within the asyncio event loop in the Python runtime.</p>
<p>They are not a software representation of a capability provided by the underlying operating system, like threads and processes.</p>
<p>In this sense, Python does not have support for “native coroutines”, but I’m not sure such things exist in modern operating systems.</p>
</div>
<div class="tabbed-block">
<p>协程由软件管理。</p>
<p>协程在 Python 运行时的 <strong>asyncio 事件循环</strong>中运行和管理（切换）。</p>
<p>它们不是底层操作系统级别提供的功能以及软件表示，例如线程和进程。</p>
<p>从这个意义上说，Python 不支持“原生协程”，但我不确定现代操作系统中是否存在这样的东西。</p>
</div>
</div>
</div>
<h3 id="243-python-的并发性不是有问题吗">24.3 Python 的并发性不是有问题吗？<a class="headerlink" href="#243-python-的并发性不是有问题吗" title="Permanent link">&para;</a></h3>
<p><strong>24.3 Isn’t Python Concurrency Buggy?</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="149:2"><input checked="checked" id="__tabbed_149_1" name="__tabbed_149" type="radio" /><input id="__tabbed_149_2" name="__tabbed_149" type="radio" /><div class="tabbed-labels"><label for="__tabbed_149_1">English</label><label for="__tabbed_149_2">Chinese</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<p>No.</p>
<p>Python provides first-class concurrency with coroutines, threads, and processes.</p>
<p>It has for a long time now and it is widely used in open source and commercial projects.</p>
</div>
<div class="tabbed-block">
<p>不🙅🏻‍♀️。</p>
<p>Python 通过协程、线程和进程提供一流的并发性。</p>
<p>它已经存在很长时间了，并且广泛应用于开源和商业项目中。</p>
</div>
</div>
</div>
<h3 id="244-对于并发来说python-不是一个糟糕的选择吗">24.4 对于并发来说，Python 不是一个糟糕的选择吗？<a class="headerlink" href="#244-对于并发来说python-不是一个糟糕的选择吗" title="Permanent link">&para;</a></h3>
<p><strong>24.4 Isn’t Python a Bad Choice for Concurrency?</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="150:2"><input checked="checked" id="__tabbed_150_1" name="__tabbed_150" type="radio" /><input id="__tabbed_150_2" name="__tabbed_150" type="radio" /><div class="tabbed-labels"><label for="__tabbed_150_1">English</label><label for="__tabbed_150_2">Chinese</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<p>Developers love python for many reasons, most commonly because it is easy to use and fast for development.</p>
<p>Python is commonly used for glue code, one-off scripts, but more and more for large-scale software systems.</p>
<p>If you are using Python and then you need concurrency, then you work with what you have. The question is moot.</p>
<p>If you need concurrency and you have not chosen a language, perhaps another language would be more appropriate, or perhaps not. Consider the full scope of functional and non-functional requirements (or user needs, wants, and desires) for your project and the capabilities of different development platforms.</p>
</div>
<div class="tabbed-block">
<p>开发人员喜爱 Python 的原因有很多，最常见的是因为它易于使用且开发速度快。</p>
<p>Python 通常用于粘合代码、一次性脚本，但越来越多地用于大型软件系统。</p>
<p>如果您使用 Python 并且需要并发性，那么您可以使用现有的东西。 这个问题毫无意义。</p>
<p>如果您需要并发性并且尚未选择一种语言，那么另一种语言可能更合适，也可能不合适。 需要考虑项目的全部功能和非功能需求（或用户的需求、想法和愿望）以及不同开发平台的功能。</p>
</div>
</div>
</div>
<h3 id="255-为什么不使用线程来代替">25.5 为什么不使用线程来代替？<a class="headerlink" href="#255-为什么不使用线程来代替" title="Permanent link">&para;</a></h3>
<p><strong>25.5 Why Not Use Threads Instead?</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="151:2"><input checked="checked" id="__tabbed_151_1" name="__tabbed_151" type="radio" /><input id="__tabbed_151_2" name="__tabbed_151" type="radio" /><div class="tabbed-labels"><label for="__tabbed_151_1">English</label><label for="__tabbed_151_2">Chinese</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<p>You can use threads instead of asyncio.</p>
<p>Any program developed using threads can be rewritten to use asyncio and coroutines.</p>
<p>Any program developed using coroutines and asyncio can be rewritten to use threads.</p>
<p>Adopting asyncio in a project is a choice, the rationale is yours.</p>
<p>For the most part, they are <strong>functionally equivalent.</strong>（功能等效）</p>
<p>Many use cases will execute faster using threads and may be more familiar(亲切) to a wider array of Python developers.</p>
<p>Some use cases in the areas of network programming and executing system commands may be simpler(最简单) (less code) when using asyncio, and significantly more scalable than using threads.</p>
</div>
<div class="tabbed-block">
<ul>
<li>
<p>您可以使用线程而不是异步。</p>
</li>
<li>
<p>任何使用<strong>线程</strong>开发的程序都可以使用 <strong>asyncio 和协程</strong>重写。</p>
</li>
<li>
<p>任何使用<strong>协程和 asyncio</strong> 开发的程序都可以使用<strong>线程</strong>重写。</p>
</li>
<li>
<p>在项目中采用 asyncio 是一种选择，其理由由您决定。</p>
</li>
<li>
<p>在大多数情况下，它们在功能上是等效的。</p>
</li>
<li>
<p>许多用例使用线程将执行得更快，并且可能为更广泛的 Python 开发人员所熟悉。</p>
</li>
<li>
<p>使用 asyncio 时，网络编程和执行系统命令领域的一些用例可能会更简单（最简单）（代码更少），并且比使用线程更具可扩展性。</p>
</li>
</ul>
</div>
</div>
</div>
<h2 id="25-进一步阅读">25. 进一步阅读<a class="headerlink" href="#25-进一步阅读" title="Permanent link">&para;</a></h2>
<p><strong>25. Further Reading</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="152:2"><input checked="checked" id="__tabbed_152_1" name="__tabbed_152" type="radio" /><input id="__tabbed_152_2" name="__tabbed_152" type="radio" /><div class="tabbed-labels"><label for="__tabbed_152_1">English</label><label for="__tabbed_152_2">Chinese</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<p>This section lists helpful additional resources on the topic.</p>
</div>
<div class="tabbed-block">
<p>本节列出了有关该主题的有用的其他资源。</p>
</div>
</div>
</div>
<h3 id="251-python-异步书籍">25.1 Python 异步书籍<a class="headerlink" href="#251-python-异步书籍" title="Permanent link">&para;</a></h3>
<p><strong>25.1 Python Asyncio Books</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="153:2"><input checked="checked" id="__tabbed_153_1" name="__tabbed_153" type="radio" /><input id="__tabbed_153_2" name="__tabbed_153" type="radio" /><div class="tabbed-labels"><label for="__tabbed_153_1">English</label><label for="__tabbed_153_2">Chinese</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<p>This section lists my books on Python asyncio, designed to help you get started and get good, super fast.</p>
<ul>
<li><a href="https://superfastpython.com/paj-further-reading">Python Asyncio Jump-Start</a>, Jason Brownlee, 2022. (my book!)</li>
<li><a href="https://amzn.to/3XFEZgj">Python Asyncio Interview Questions</a></li>
<li><a href="https://superfastpython.gumroad.com/l/pacs">Asyncio Module API Cheat Sheet</a></li>
</ul>
<p>Other books on asyncio include:</p>
<ul>
<li><a href="https://amzn.to/3LZvxNn">Python Concurrency with asyncio</a>, Matthew Fowler, 2022.</li>
<li><a href="https://amzn.to/3lNp2ml">Using Asyncio in Python</a>, Caleb Hattingh, 2020.</li>
</ul>
</div>
<div class="tabbed-block">
<p>本节列出了我有关 Python asyncio 的书籍，旨在帮助您快速入门并获得良好的效果。</p>
<ul>
<li><a href="https://superfastpython.com/paj-further-reading">Python Asyncio Jump-Start</a>, Jason Brownlee, 2022. (my book!)</li>
<li><a href="https://amzn.to/3XFEZgj">Python Asyncio Interview Questions</a></li>
<li><a href="https://superfastpython.gumroad.com/l/pacs">Asyncio Module API Cheat Sheet</a></li>
</ul>
<p>其他关于 asyncio 的书籍包括：</p>
<ul>
<li><a href="https://amzn.to/3LZvxNn">Python Concurrency with asyncio</a>, Matthew Fowler, 2022.</li>
<li><a href="https://amzn.to/3lNp2ml">Using Asyncio in Python</a>, Caleb Hattingh, 2020.</li>
</ul>
</div>
</div>
</div>
<h3 id="252-apis">25.2 APIs<a class="headerlink" href="#252-apis" title="Permanent link">&para;</a></h3>
<div class="tabbed-set tabbed-alternate" data-tabs="154:2"><input checked="checked" id="__tabbed_154_1" name="__tabbed_154" type="radio" /><input id="__tabbed_154_2" name="__tabbed_154" type="radio" /><div class="tabbed-labels"><label for="__tabbed_154_1">English</label><label for="__tabbed_154_2">Chinese</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<ul>
<li><a href="https://docs.python.org/3/library/asyncio.html">asyncio — Asynchronous I/O</a></li>
<li><a href="https://docs.python.org/3/library/asyncio-task.html">Asyncio Coroutines and Tasks</a></li>
<li><a href="https://docs.python.org/3/library/asyncio-stream.html">Asyncio Streams</a></li>
<li><a href="https://docs.python.org/3/library/asyncio-subprocess.html">Asyncio Subprocesses</a></li>
<li><a href="https://docs.python.org/3/library/asyncio-queue.html">Asyncio Queues</a></li>
<li><a href="https://docs.python.org/3/library/asyncio-sync.html">Asyncio Synchronization Primitives</a></li>
</ul>
</div>
<div class="tabbed-block">
<ul>
<li><a href="https://docs.python.org/3/library/asyncio.html">asyncio — Asynchronous I/O</a></li>
<li><a href="https://docs.python.org/3/library/asyncio-task.html">Asyncio Coroutines and Tasks</a></li>
<li><a href="https://docs.python.org/3/library/asyncio-stream.html">Asyncio Streams</a></li>
<li><a href="https://docs.python.org/3/library/asyncio-subprocess.html">Asyncio Subprocesses</a></li>
<li><a href="https://docs.python.org/3/library/asyncio-queue.html">Asyncio Queues</a></li>
<li><a href="https://docs.python.org/3/library/asyncio-sync.html">Asyncio Synchronization Primitives</a></li>
</ul>
</div>
</div>
</div>
<h3 id="253-参考">25.3 参考<a class="headerlink" href="#253-参考" title="Permanent link">&para;</a></h3>
<p><strong>25.3 References</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="155:2"><input checked="checked" id="__tabbed_155_1" name="__tabbed_155" type="radio" /><input id="__tabbed_155_2" name="__tabbed_155" type="radio" /><div class="tabbed-labels"><label for="__tabbed_155_1">English</label><label for="__tabbed_155_2">Chinese</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<ul>
<li><a href="https://en.wikipedia.org/wiki/Asynchronous_I/O">Asynchronous I/O, Wikipedia.</a></li>
<li><a href="https://en.wikipedia.org/wiki/Coroutine">Coroutine, Wikipedia.</a></li>
</ul>
</div>
<div class="tabbed-block">
<ul>
<li><a href="https://en.wikipedia.org/wiki/Asynchronous_I/O">Asynchronous I/O, Wikipedia.</a></li>
<li><a href="https://en.wikipedia.org/wiki/Coroutine">Coroutine, Wikipedia.</a></li>
</ul>
</div>
</div>
</div>
<h2 id="26-结论">26. 结论<a class="headerlink" href="#26-结论" title="Permanent link">&para;</a></h2>
<p><strong>26. Conclusions</strong></p>
<div class="tabbed-set tabbed-alternate" data-tabs="156:2"><input checked="checked" id="__tabbed_156_1" name="__tabbed_156" type="radio" /><input id="__tabbed_156_2" name="__tabbed_156" type="radio" /><div class="tabbed-labels"><label for="__tabbed_156_1">English</label><label for="__tabbed_156_2">Chinese</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<p>This is a large guide, and you have discovered in great detail how asyncio and coroutines work in Python and how to best use them in your project.</p>
<p><strong>Did you find this guide useful?</strong></p>
<p>I’d love to know, please share a kind word in the comments below.</p>
<p><strong>Have you used asyncio on a project?</strong></p>
<p>I’d love to hear about it, please let me know in the comments.</p>
<p><strong>Do you have any questions?</strong></p>
<p>Leave your question in a comment below and I will reply fast with my best advice.</p>
<p>Join the discussion on <a href="https://www.reddit.com/r/Python/comments/yqrr94/python_asyncio_the_complete_guide/">reddit</a> and <a href="https://news.ycombinator.com/item?id=33547323">hackernews</a>.</p>
</div>
<div class="tabbed-block">
<p>这是一本很大的指南，您已经详细了解了 asyncio 和协程如何在 Python 中工作以及如何在您的项目中最好地使用它们。</p>
<p><strong>您觉得本指南有用吗？</strong></p>
<p>我很想知道，请在下面的评论中分享一句好话。</p>
<p><strong>你在项目中使用过 asyncio 吗？</strong></p>
<p>我很想听听，请在评论中告诉我。</p>
<p><strong>你有任何问题吗？</strong></p>
<p>在下面的评论中留下您的问题，我会快速回复并提供我最好的建议。</p>
<p>在 <a href="https://www.reddit.com/r/Python/comments/yqrr94/python_asyncio_the_complete_guide/">reddit</a> 和 <a href="https://news.ycombinator.com/item?id=33547323">hackernews</a> 中加入讨论。</p>
</div>
</div>
</div>

  <hr>
<div class="md-source-file">
  <small>
    
      最后更新:
      <span class="git-revision-date-localized-plugin git-revision-date-localized-plugin-date">2023年6月30日</span>
      
        <br>
        创建日期:
        <span class="git-revision-date-localized-plugin git-revision-date-localized-plugin-date">2023年6月27日</span>
      
    
  </small>
</div>





                
              </article>
            </div>
          
          
  <script>var tabs=__md_get("__tabs");if(Array.isArray(tabs))e:for(var set of document.querySelectorAll(".tabbed-set")){var tab,labels=set.querySelector(".tabbed-labels");for(tab of tabs)for(var label of labels.getElementsByTagName("label"))if(label.innerText.trim()===tab){var input=document.getElementById(label.htmlFor);input.checked=!0;continue e}}</script>

        </div>
        
          <button type="button" class="md-top md-icon" data-md-component="top" hidden>
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12Z"/></svg>
            回到页面顶部
          </button>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    <script id="__config" type="application/json">{"base": "..", "features": ["content.code.copy", "content.tabs.link", "navigation.tabs", "navigation.tabs.sticky", "navigation.indexes", "navigation.top", "toc.follow"], "search": "../assets/javascripts/workers/search.208ed371.min.js", "translations": {"clipboard.copied": "\u5df2\u590d\u5236", "clipboard.copy": "\u590d\u5236", "search.result.more.one": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.more.other": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 # \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.none": "\u6ca1\u6709\u627e\u5230\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.one": "\u627e\u5230 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.other": "# \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.placeholder": "\u952e\u5165\u4ee5\u5f00\u59cb\u641c\u7d22", "search.result.term.missing": "\u7f3a\u5c11", "select.version": "\u9009\u62e9\u5f53\u524d\u7248\u672c"}}</script>
    
    
      <script src="../assets/javascripts/bundle.b4d07000.min.js"></script>
      
        <script src="../javascripts/mathjax.js"></script>
      
        <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
      
        <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
      
        <script src="https://unpkg.com/mermaid@9.4.0/dist/mermaid.min.js"></script>
      
    
  <script>document$.subscribe(() => {const lightbox = GLightbox({"touchNavigation": true, "loop": false, "zoomable": true, "draggable": true, "openEffect": "zoom", "closeEffect": "zoom", "slideEffect": "slide"});})</script></body>
</html>