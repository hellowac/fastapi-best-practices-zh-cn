{"config":{"lang":["ja"],"separator":"[\\s\\-,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stemmer"]},"docs":[{"location":"","title":"FastAPI \u6700\u4f73\u5b9e\u8df5","text":"<p>\u6211\u4eec\u5728\u521b\u4e1a\u65f6\u4f7f\u7528\u7684\u5e76\u4e14\u81ea\u4ee5\u4e3a\u662f\u7684\u6700\u4f73\u5b9e\u8df5\u548c\u60ef\u4f8b\u5217\u8868\u3002</p> <p>\u5728\u8fc7\u53bb 1.5 \u5e74\u7684\u751f\u4ea7\u4e2d\uff0c \u6211\u4eec\u4e00\u76f4\u5728\u505a\u51fa\u597d\u7684\u548c\u574f\u7684\u51b3\u5b9a\uff0c\u8fd9\u4e9b\u51b3\u5b9a\u6781\u5927\u5730\u5f71\u54cd\u4e86\u6211\u4eec\u7684\u5f00\u53d1\u4eba\u5458\u4f53\u9a8c\u3002 \u5176\u4e2d\u4e00\u4e9b\u503c\u5f97\u5206\u4eab\u3002</p>"},{"location":"#1-\u9879\u76ee\u7ed3\u6784-\u4e00\u81f4\u4e14\u53ef\u9884\u6d4b","title":"1. \u9879\u76ee\u7ed3\u6784\u3002 \u4e00\u81f4\u4e14\u53ef\u9884\u6d4b","text":"<p>There are many ways to structure the project, but the best structure is a structure that is consistent, straightforward, and has no surprises.</p> <ul> <li>If looking at the project structure doesn't give you an idea of what the project is about, then the structure might be unclear.</li> <li>If you have to open packages to understand what modules are located in them, then your structure is unclear.</li> <li>If the frequency and location of the files feels random, then your project structure is bad.</li> <li>If looking at the module's location and its name doesn't give you an idea of what's inside it, then your structure is very bad.</li> </ul> <p>Although the project structure, where we separate files by their type (e.g. api, crud, models, schemas) presented by @tiangolo is good for microservices or projects with fewer scopes, we couldn't fit it into our monolith with a lot of domains and modules. Structure that I found more scalable and evolvable is inspired by Netflix's Dispatch with some little modifications.</p> <pre><code>fastapi-project\n\u251c\u2500\u2500 alembic/\n\u251c\u2500\u2500 src\n\u2502   \u251c\u2500\u2500 auth\n\u2502   \u2502   \u251c\u2500\u2500 router.py\n\u2502   \u2502   \u251c\u2500\u2500 schemas.py  # pydantic models\n\u2502   \u2502   \u251c\u2500\u2500 models.py  # db models\n\u2502   \u2502   \u251c\u2500\u2500 dependencies.py\n\u2502   \u2502   \u251c\u2500\u2500 config.py  # local configs\n\u2502   \u2502   \u251c\u2500\u2500 constants.py\n\u2502   \u2502   \u251c\u2500\u2500 exceptions.py\n\u2502   \u2502   \u251c\u2500\u2500 service.py\n\u2502   \u2502   \u2514\u2500\u2500 utils.py\n\u2502   \u251c\u2500\u2500 aws\n\u2502   \u2502   \u251c\u2500\u2500 client.py  # client model for external service communication\n\u2502   \u2502   \u251c\u2500\u2500 schemas.py\n\u2502   \u2502   \u251c\u2500\u2500 config.py\n\u2502   \u2502   \u251c\u2500\u2500 constants.py\n\u2502   \u2502   \u251c\u2500\u2500 exceptions.py\n\u2502   \u2502   \u2514\u2500\u2500 utils.py\n\u2502   \u2514\u2500\u2500 posts\n\u2502   \u2502   \u251c\u2500\u2500 router.py\n\u2502   \u2502   \u251c\u2500\u2500 schemas.py\n\u2502   \u2502   \u251c\u2500\u2500 models.py\n\u2502   \u2502   \u251c\u2500\u2500 dependencies.py\n\u2502   \u2502   \u251c\u2500\u2500 constants.py\n\u2502   \u2502   \u251c\u2500\u2500 exceptions.py\n\u2502   \u2502   \u251c\u2500\u2500 service.py\n\u2502   \u2502   \u2514\u2500\u2500 utils.py\n\u2502   \u251c\u2500\u2500 config.py  # global configs\n\u2502   \u251c\u2500\u2500 models.py  # global models\n\u2502   \u251c\u2500\u2500 exceptions.py  # global exceptions\n\u2502   \u251c\u2500\u2500 pagination.py  # global module e.g. pagination\n\u2502   \u251c\u2500\u2500 database.py  # db connection related stuff\n\u2502   \u2514\u2500\u2500 main.py\n\u251c\u2500\u2500 tests/\n\u2502   \u251c\u2500\u2500 auth\n\u2502   \u251c\u2500\u2500 aws\n\u2502   \u2514\u2500\u2500 posts\n\u251c\u2500\u2500 templates/\n\u2502   \u2514\u2500\u2500 index.html\n\u251c\u2500\u2500 requirements\n\u2502   \u251c\u2500\u2500 base.txt\n\u2502   \u251c\u2500\u2500 dev.txt\n\u2502   \u2514\u2500\u2500 prod.txt\n\u251c\u2500\u2500 .env\n\u251c\u2500\u2500 .gitignore\n\u251c\u2500\u2500 logging.ini\n\u2514\u2500\u2500 alembic.ini\n</code></pre> <ol> <li>Store all domain directories inside <code>src</code> folder</li> <li><code>src/</code> - highest level of an app, contains common models, configs, and constants, etc.</li> <li><code>src/main.py</code> - root of the project, which inits the FastAPI app</li> <li>Each package has its own router, schemas, models, etc.</li> <li><code>router.py</code> - is a core of each module with all the endpoints</li> <li><code>schemas.py</code> - for pydantic models</li> <li><code>models.py</code> - for db models</li> <li><code>service.py</code> - module specific business logic  </li> <li><code>dependencies.py</code> - router dependencies</li> <li><code>constants.py</code> - module specific constants and error codes</li> <li><code>config.py</code> - e.g. env vars</li> <li><code>utils.py</code> - non-business logic functions, e.g. response normalization, data enrichment, etc.</li> <li><code>exceptions</code> - module specific exceptions, e.g. <code>PostNotFound</code>, <code>InvalidUserData</code></li> <li>When package requires services or dependencies or constants from other packages - import them with an explicit module name</li> </ol> <pre><code>from src.auth import constants as auth_constants\nfrom src.notifications import service as notification_service\nfrom src.posts.constants import ErrorCode as PostsErrorCode  # in case we have Standard ErrorCode in constants module of each package\n</code></pre>"},{"location":"#2-\u8fc7\u5ea6\u4f7f\u7528-pydantic-\u8fdb\u884c\u6570\u636e\u9a8c\u8bc1","title":"2. \u8fc7\u5ea6\u4f7f\u7528 Pydantic \u8fdb\u884c\u6570\u636e\u9a8c\u8bc1","text":"<p>Pydantic has a rich set of features to validate and transform data.</p> <p>In addition to regular features like required &amp; non-required fields with default values, Pydantic has built-in comprehensive data processing tools like regex, enums for limited allowed options, length validation, email validation, etc.</p> <pre><code>from enum import Enum\nfrom pydantic import AnyUrl, BaseModel, EmailStr, Field, constr\n\nclass MusicBand(str, Enum):\n   AEROSMITH = \"AEROSMITH\"\n   QUEEN = \"QUEEN\"\n   ACDC = \"AC/DC\"\n\n\nclass UserBase(BaseModel):\n    first_name: str = Field(min_length=1, max_length=128)\n    username: constr(regex=\"^[A-Za-z0-9-_]+$\", to_lower=True, strip_whitespace=True)\n    email: EmailStr\n    age: int = Field(ge=18, default=None)  # must be greater or equal to 18\n    favorite_band: MusicBand = None  # only \"AEROSMITH\", \"QUEEN\", \"AC/DC\" values are allowed to be inputted\n    website: AnyUrl = None\n</code></pre>"},{"location":"#3-\u4f7f\u7528\u4f9d\u8d56\u9879\u8fdb\u884c\u6570\u636e\u9a8c\u8bc1\u4e0e\u6570\u636e\u5e93","title":"3. \u4f7f\u7528\u4f9d\u8d56\u9879\u8fdb\u884c\u6570\u636e\u9a8c\u8bc1\u4e0e\u6570\u636e\u5e93","text":"<p>Pydantic can only validate the values from client input. Use dependencies to validate data against database constraints like email already exists, user not found, etc.</p> <pre><code># dependencies.py\nasync def valid_post_id(post_id: UUID4) -&gt; Mapping:\n    post = await service.get_by_id(post_id)\n    if not post:\n        raise PostNotFound()\n\n    return post\n\n\n# router.py\n@router.get(\"/posts/{post_id}\", response_model=PostResponse)\nasync def get_post_by_id(post: Mapping = Depends(valid_post_id)):\n    return post\n\n\n@router.put(\"/posts/{post_id}\", response_model=PostResponse)\nasync def update_post(\n    update_data: PostUpdate,  \n    post: Mapping = Depends(valid_post_id), \n):\n    updated_post: Mapping = await service.update(id=post[\"id\"], data=update_data)\n    return updated_post\n\n\n@router.get(\"/posts/{post_id}/reviews\", response_model=list[ReviewsResponse])\nasync def get_post_reviews(post: Mapping = Depends(valid_post_id)):\n    post_reviews: list[Mapping] = await reviews_service.get_by_post_id(post[\"id\"])\n    return post_reviews\n</code></pre> <p>If we didn't put data validation to dependency, we would have to add post_id validation for every endpoint and write the same tests for each of them.</p>"},{"location":"#4-\u4f9d\u8d56dependency\u94fe","title":"4. \u4f9d\u8d56(Dependency)\u94fe","text":"<p>Dependencies can use other dependencies and avoid code repetition for similar logic.</p> <pre><code># dependencies.py\nfrom fastapi.security import OAuth2PasswordBearer\nfrom jose import JWTError, jwt\n\nasync def valid_post_id(post_id: UUID4) -&gt; Mapping:\n    post = await service.get_by_id(post_id)\n    if not post:\n        raise PostNotFound()\n\n    return post\n\n\nasync def parse_jwt_data(\n    token: str = Depends(OAuth2PasswordBearer(tokenUrl=\"/auth/token\"))\n) -&gt; dict:\n    try:\n        payload = jwt.decode(token, \"JWT_SECRET\", algorithms=[\"HS256\"])\n    except JWTError:\n        raise InvalidCredentials()\n\n    return {\"user_id\": payload[\"id\"]}\n\n\nasync def valid_owned_post(\n    post: Mapping = Depends(valid_post_id), \n    token_data: dict = Depends(parse_jwt_data),\n) -&gt; Mapping:\n    if post[\"creator_id\"] != token_data[\"user_id\"]:\n        raise UserNotOwner()\n\n    return post\n\n# router.py\n@router.get(\"/users/{user_id}/posts/{post_id}\", response_model=PostResponse)\nasync def get_user_post(post: Mapping = Depends(valid_owned_post)):\n    return post\n</code></pre>"},{"location":"#5-\u89e3\u8026\u548c\u91cd\u7528\u4f9d\u8d56\u5173\u7cfb-\u7f13\u5b58\u4f9d\u8d56dependency\u8c03\u7528\u7ed3\u679c","title":"5. \u89e3\u8026\u548c\u91cd\u7528\u4f9d\u8d56\u5173\u7cfb\u3002 \u7f13\u5b58\u4f9d\u8d56(Dependency)\u8c03\u7528\u7ed3\u679c","text":"<p>Dependencies can be reused multiple times, and they won't be recalculated - FastAPI caches dependency's result within a request's scope by default, i.e. if we have a dependency that calls service <code>get_post_by_id</code>, we won't be visiting DB each time we call this dependency - only the first function call.</p> <p>Knowing this, we can easily decouple dependencies onto multiple smaller functions that operate on a smaller domain and are easier to reuse in other routes. For example, in the code below we are using <code>parse_jwt_data</code> three times:</p> <ol> <li><code>valid_owned_post</code></li> <li><code>valid_active_creator</code></li> <li><code>get_user_post</code>,</li> </ol> <p>but <code>parse_jwt_data</code> is called only once, in the very first call.</p> <pre><code># dependencies.py\nfrom fastapi import BackgroundTasks\nfrom fastapi.security import OAuth2PasswordBearer\nfrom jose import JWTError, jwt\n\nasync def valid_post_id(post_id: UUID4) -&gt; Mapping:\n    post = await service.get_by_id(post_id)\n    if not post:\n        raise PostNotFound()\n\n    return post\n\n\nasync def parse_jwt_data(\n    token: str = Depends(OAuth2PasswordBearer(tokenUrl=\"/auth/token\"))\n) -&gt; dict:\n    try:\n        payload = jwt.decode(token, \"JWT_SECRET\", algorithms=[\"HS256\"])\n    except JWTError:\n        raise InvalidCredentials()\n\n    return {\"user_id\": payload[\"id\"]}\n\n\nasync def valid_owned_post(\n    post: Mapping = Depends(valid_post_id), \n    token_data: dict = Depends(parse_jwt_data),\n) -&gt; Mapping:\n    if post[\"creator_id\"] != token_data[\"user_id\"]:\n        raise UserNotOwner()\n\n    return post\n\n\nasync def valid_active_creator(\n    token_data: dict = Depends(parse_jwt_data),\n):\n    user = await users_service.get_by_id(token_data[\"user_id\"])\n    if not user[\"is_active\"]:\n        raise UserIsBanned()\n\n    if not user[\"is_creator\"]:\n       raise UserNotCreator()\n\n    return user\n\n\n# router.py\n@router.get(\"/users/{user_id}/posts/{post_id}\", response_model=PostResponse)\nasync def get_user_post(\n    worker: BackgroundTasks,\n    post: Mapping = Depends(valid_owned_post),\n    user: Mapping = Depends(valid_active_creator),\n):\n\"\"\"Get post that belong the active user.\"\"\"\n    worker.add_task(notifications_service.send_email, user[\"id\"])\n    return post\n</code></pre>"},{"location":"#6-\u9075\u5faa-rest-\u89c4\u8303","title":"6. \u9075\u5faa REST \u89c4\u8303","text":"<p>Developing RESTful API makes it easier to reuse dependencies in routes like these:</p> <ol> <li><code>GET /courses/:course_id</code></li> <li><code>GET /courses/:course_id/chapters/:chapter_id/lessons</code></li> <li><code>GET /chapters/:chapter_id</code></li> </ol> <p>The only caveat is to use the same variable names in the path:</p> <ul> <li>If you have two endpoints <code>GET /profiles/:profile_id</code> and <code>GET /creators/:creator_id</code> that both validate whether the given <code>profile_id</code> exists,  but <code>GET /creators/:creator_id</code> also checks if the profile is creator, then it's better to rename <code>creator_id</code> path variable to <code>profile_id</code> and chain those two dependencies.</li> </ul> <pre><code># src.profiles.dependencies\nasync def valid_profile_id(profile_id: UUID4) -&gt; Mapping:\n    profile = await service.get_by_id(post_id)\n    if not profile:\n        raise ProfileNotFound()\n\n    return profile\n\n# src.creators.dependencies\nasync def valid_creator_id(profile: Mapping = Depends(valid_profile_id)) -&gt; Mapping:\n    if not profile[\"is_creator\"]:\n       raise ProfileNotCreator()\n\n    return profile\n\n# src.profiles.router.py\n@router.get(\"/profiles/{profile_id}\", response_model=ProfileResponse)\nasync def get_user_profile_by_id(profile: Mapping = Depends(valid_profile_id)):\n\"\"\"Get profile by id.\"\"\"\n    return profile\n\n# src.creators.router.py\n@router.get(\"/creators/{profile_id}\", response_model=ProfileResponse)\nasync def get_user_profile_by_id(\n     creator_profile: Mapping = Depends(valid_creator_id)\n):\n\"\"\"Get creator's profile by id.\"\"\"\n    return creator_profile\n</code></pre> <p>Use /me endpoints for users resources (e.g. <code>GET /profiles/me</code>, <code>GET /users/me/posts</code>)</p> <ol> <li>No need to validate that user id exists - it's already checked via auth method</li> <li>No need to check whether the user id belongs to the requester</li> </ol>"},{"location":"#7-\u4e0d\u8981\u8ba9\u4f60\u7684\u8def\u7531\u5f02\u6b65\u5982\u679c\u4f60\u53ea\u6709\u963b\u585e-io-\u64cd\u4f5c","title":"7. \u4e0d\u8981\u8ba9\u4f60\u7684\u8def\u7531\u5f02\u6b65\uff0c\u5982\u679c\u4f60\u53ea\u6709\u963b\u585e I/O \u64cd\u4f5c","text":"<p>\u5728\u5e95\u5c42\uff0cFastAPI \u53ef\u4ee5\u6709\u6548\u5730\u5904\u7406 \u5f02\u6b65\u548c\u540c\u6b65 I/O \u64cd\u4f5c\u3002</p> <ul> <li>FastAPI \u5728\u7ebf\u7a0b\u6c60 \u4e2d\u8fd0\u884c<code>sync</code>(\u540c\u6b65)\u8def\u7531\uff0c\u963b\u585e I/O \u64cd\u4f5c\u4e0d\u4f1a\u963b\u6b62[\u4e8b\u4ef6\u5faa\u73af](https://docs.python.org/3/library/asyncio-eventloop.html\uff09\u6267\u884c\u4efb\u52a1\u3002</li> <li>\u5426\u5219\uff0c\u5982\u679c\u8def\u7531\u88ab\u5b9a\u4e49\u4e3a<code>async</code>\uff0c\u90a3\u4e48\u5b83\u4f1a\u901a\u8fc7<code>await</code>\u5b9a\u671f\u8c03\u7528\uff0c\u5e76\u4e14 FastAPI \u76f8\u4fe1\u60a8\u53ea\u4f1a\u6267\u884c\u975e\u963b\u585e I/O \u64cd\u4f5c\u3002</li> </ul> <p>\u9700\u8981\u6ce8\u610f\u7684\u662f\uff0c\u5982\u679c\u60a8\u672a\u80fd\u4fe1\u4efb\u5e76\u5728\u5f02\u6b65\u8def\u7531\u4e2d\u6267\u884c\u963b\u585e\u64cd\u4f5c\uff0c\u4e8b\u4ef6\u5faa\u73af\u5c06\u65e0\u6cd5\u8fd0\u884c\u4e0b\u4e00\u4e2a\u4efb\u52a1\uff0c\u76f4\u5230\u8be5\u963b\u585e\u64cd\u4f5c\u5b8c\u6210\u3002</p> <pre><code>import asyncio\nimport time\n\n@router.get(\"/terrible-ping\")\nasync def terrible_catastrophic_ping():\n    time.sleep(10) # I/O\u963b\u585e\u64cd\u4f5c10\u79d2\n    pong = service.get_pong()  # \u4ece DB \u83b7\u53d6 pong \u7684 I/O \u963b\u585e\u64cd\u4f5c\n\n    return {\"pong\": pong}\n\n@router.get(\"/good-ping\")\ndef good_ping():\n    time.sleep(10) # I/O \u963b\u585e\u64cd\u4f5c 10 \u79d2\uff0c\u4f46\u5728\u53e6\u4e00\u4e2a\u7ebf\u7a0b\u4e2d\n    pong = service.get_pong()  # \u4ece\u6570\u636e\u5e93\u4e2d\u83b7\u53d6 pong \u7684 I/O \u963b\u585e\u64cd\u4f5c\uff0c\u4f46\u5728\u53e6\u4e00\u4e2a\u7ebf\u7a0b\u4e2d\n\n    return {\"pong\": pong}\n\n@router.get(\"/perfect-ping\")\nasync def perfect_ping():\n    await asyncio.sleep(10) # \u975e\u963b\u585e I/O \u64cd\u4f5c\n    pong = await service.async_get_pong()  # \u975e\u963b\u585e I/O \u6570\u636e\u5e93\u8c03\u7528\n\n    return {\"pong\": pong}\n</code></pre> <p>\u5f53\u6211\u4eec\u8c03\u7528\u65f6\u4f1a\u53d1\u751f\u4ec0\u4e48:</p> <ol> <li><code>GET /terrible-ping</code></li> <li>FastAPI server receives a request and starts handling it</li> <li>Server's event loop and all the tasks in the queue will be waiting until <code>time.sleep()</code> is finished<ol> <li>Server thinks <code>time.sleep()</code> is not an I/O task, so it waits until it is finished</li> <li>Server won't accept any new requests while waiting</li> </ol> </li> <li>Then, event loop and all the tasks in the queue will be waiting until <code>service.get_pong</code> is finished<ol> <li>Server thinks <code>service.get_pong()</code> is not an I/O task, so it waits until it is finished</li> <li>Server won't accept any new requests while waiting</li> </ol> </li> <li>Server returns the response.<ol> <li>After a response, server starts accepting new requests</li> </ol> </li> <li><code>GET /good-ping</code></li> <li>FastAPI server receives a request and starts handling it</li> <li>FastAPI sends the whole route <code>good_ping</code> to the threadpool, where a worker thread will run the function</li> <li>While <code>good_ping</code> is being executed, event loop selects next tasks from the queue and works on them (e.g. accept new request, call db)<ul> <li>Independently of main thread (i.e. our FastAPI app),     worker thread will be waiting for <code>time.sleep</code> to finish and then for <code>service.get_pong</code> to finish</li> <li>Sync operation blocks only the side thread, not the main one.</li> </ul> </li> <li>When <code>good_ping</code> finishes its work, server returns a response to the client</li> <li><code>GET /perfect-ping</code></li> <li>FastAPI server receives a request and starts handling it</li> <li>FastAPI awaits <code>asyncio.sleep(10)</code></li> <li>Event loop selects next tasks from the queue and works on them (e.g. accept new request, call db)</li> <li>When <code>asyncio.sleep(10)</code> is done, servers goes to the next lines and awaits <code>service.async_get_pong</code></li> <li>Event loop selects next tasks from the queue and works on them (e.g. accept new request, call db)</li> <li>When <code>service.async_get_pong</code> is done, server returns a response to the client</li> </ol> <p>The second caveat is that operations that are non-blocking awaitables or are sent to the thread pool must be I/O intensive tasks (e.g. open file, db call, external API call).</p> <ul> <li>Awaiting CPU-intensive tasks (e.g. heavy calculations, data processing, video transcoding) is worthless since the CPU has to work to finish the tasks, while I/O operations are external and server does nothing while waiting for that operations to finish, thus it can go to the next tasks.</li> <li>Running CPU-intensive tasks in other threads also isn't effective, because of GIL. In short, GIL allows only one thread to work at a time, which makes it useless for CPU tasks.</li> <li>If you want to optimize CPU intensive tasks you should send them to workers in another process.</li> </ul> <p>Related StackOverflow questions of confused users</p> <ol> <li>https://stackoverflow.com/questions/62976648/architecture-flask-vs-fastapi/70309597#70309597</li> <li>Here you can also check my answer</li> <li>https://stackoverflow.com/questions/65342833/fastapi-uploadfile-is-slow-compared-to-flask</li> <li>https://stackoverflow.com/questions/71516140/fastapi-runs-api-calls-in-serial-instead-of-parallel-fashion</li> </ol>"},{"location":"#8-\u4ece\u7b2c-0-\u5929\u5f00\u59cb\u7684\u81ea\u5b9a\u4e49\u57fa\u7840\u6a21\u578b","title":"8. \u4ece\u7b2c 0 \u5929\u5f00\u59cb\u7684\u81ea\u5b9a\u4e49\u57fa\u7840\u6a21\u578b","text":"<p>\u62e5\u6709\u53ef\u63a7\u7684\u5168\u5c40\u57fa\u7840\u6a21\u578b\u4f7f\u6211\u4eec\u80fd\u591f\u81ea\u5b9a\u4e49\u5e94\u7528\u7a0b\u5e8f\u4e2d\u7684\u6240\u6709\u6a21\u578b\u3002</p> <p>\u4f8b\u5982\uff0c\u6211\u4eec\u53ef\u4ee5\u6709\u4e00\u4e2a\u6807\u51c6\u7684\u65e5\u671f\u65f6\u95f4\u683c\u5f0f\u6216\u4e3a\u57fa\u7840\u6a21\u578b\u7684\u6240\u6709\u5b50\u7c7b\u6dfb\u52a0\u4e00\u4e2a\u8d85\u7ea7\u65b9\u6cd5\u3002</p> <pre><code>from datetime import datetime\nfrom zoneinfo import ZoneInfo\n\nimport orjson\nfrom fastapi.encoders import jsonable_encoder\nfrom pydantic import BaseModel, root_validator\n\n\ndef orjson_dumps(v, *, default):\n    # orjson.dumps \u8fd4\u56de\u5b57\u8282\uff0c\u4e3a\u4e86\u5339\u914d\u6807\u51c6\u7684 json.dumps, \u6211\u4eec\u9700\u8981\u89e3\u7801\u3002\n    return orjson.dumps(v, default=default).decode()\n\n\ndef convert_datetime_to_gmt(dt: datetime) -&gt; str:\n    if not dt.tzinfo:\n        dt = dt.replace(tzinfo=ZoneInfo(\"UTC\"))\n\n    return dt.strftime(\"%Y-%m-%dT%H:%M:%S%z\")\n\n\nclass ORJSONModel(BaseModel):\n    class Config:\n        json_loads = orjson.loads\n        json_dumps = orjson_dumps\n        json_encoders = {datetime: convert_datetime_to_gmt}  # method for customer JSON encoding of datetime fields\n\n    @root_validator()\n    def set_null_microseconds(cls, data: dict) -&gt; dict:\n\"\"\"Drops microseconds in all the datetime field values.\"\"\"\n        datetime_fields = {\n            k: v.replace(microsecond=0)\n            for k, v in data.items()\n            if isinstance(k, datetime)\n        }\n\n        return {**data, **datetime_fields}\n\n    def serializable_dict(self, **kwargs):\n\"\"\"Return a dict which contains only serializable fields.\"\"\"\n        default_dict = super().dict(**kwargs)\n\n        return jsonable_encoder(default_dict)\n</code></pre> <p>In the example above we have decided to make a global base model which:</p> <ul> <li>uses orjson to serialize data</li> <li>drops microseconds to 0 in all date formats</li> <li>serializes all datetime fields to standard format with explicit timezone</li> </ul>"},{"location":"#9-\u6587\u6863docs","title":"9. \u6587\u6863(Docs)","text":"<ol> <li>Unless your API is public, hide docs by default. Show it explicitly on the selected envs only.</li> </ol> <pre><code>from fastapi import FastAPI\nfrom starlette.config import Config\n\nconfig = Config(\".env\")  # parse .env file for env variables\n\nENVIRONMENT = config(\"ENVIRONMENT\")  # get current env name\nSHOW_DOCS_ENVIRONMENT = (\"local\", \"staging\")  # explicit list of allowed envs\n\napp_configs = {\"title\": \"My Cool API\"}\nif ENVIRONMENT not in SHOW_DOCS_ENVIRONMENT:\n   app_configs[\"openapi_url\"] = None  # set url for docs as null\n\napp = FastAPI(**app_configs)\n</code></pre> <ol> <li>Help FastAPI to generate an easy-to-understand docs</li> <li>Set <code>response_model</code>, <code>status_code</code>, <code>description</code>, etc.</li> <li>If models and statuses vary, use <code>responses</code> route attribute to add docs for different responses</li> </ol> <pre><code>from fastapi import APIRouter, status\n\nrouter = APIRouter()\n\n@router.post(\n    \"/endpoints\",\n    response_model=DefaultResponseModel,  # default response pydantic model \n    status_code=status.HTTP_201_CREATED,  # default status code\n    description=\"Description of the well documented endpoint\",\n    tags=[\"Endpoint Category\"],\n    summary=\"Summary of the Endpoint\",\n    responses={\n        status.HTTP_200_OK: {\n            \"model\": OkResponse, # custom pydantic model for 200 response\n            \"description\": \"Ok Response\",\n        },\n        status.HTTP_201_CREATED: {\n            \"model\": CreatedResponse,  # custom pydantic model for 201 response\n            \"description\": \"Creates something from user request \",\n        },\n        status.HTTP_202_ACCEPTED: {\n            \"model\": AcceptedResponse,  # custom pydantic model for 202 response\n            \"description\": \"Accepts request and handles it later\",\n        },\n    },\n)\nasync def documented_route():\n    pass\n</code></pre> <p>Will generate docs like this: </p>"},{"location":"#10-\u4f7f\u7528-pydantic-\u7684-basesettings-\u8fdb\u884c\u914d\u7f6e","title":"10. \u4f7f\u7528 Pydantic \u7684 BaseSettings \u8fdb\u884c\u914d\u7f6e","text":"<p>Pydantic \u63d0\u4f9b\u4e86\u4e00\u4e2a\u5f3a\u5927\u7684\u5de5\u5177 \u6765\u89e3\u6790\u73af\u5883\u53d8\u91cf\u5e76\u4f7f\u7528\u5176\u9a8c\u8bc1\u5668\u5904\u7406\u5b83\u4eec\u3002</p> <pre><code>from pydantic import AnyUrl, BaseSettings, PostgresDsn\n\nclass AppSettings(BaseSettings):\n    class Config:\n        env_file = \".env\"\n        env_file_encoding = \"utf-8\"\n        env_prefix = \"app_\"\n\n    DATABASE_URL: PostgresDsn\n    IS_GOOD_ENV: bool = True\n    ALLOWED_CORS_ORIGINS: set[AnyUrl]\n</code></pre>"},{"location":"#11-sqlalchemy-\u8bbe\u7f6e\u6570\u636e\u5e93\u952e\u547d\u540d\u7ea6\u5b9a","title":"11. SQLAlchemy: \u8bbe\u7f6e\u6570\u636e\u5e93\u952e\u547d\u540d\u7ea6\u5b9a","text":"<p>Explicitly setting the indexes' namings according to your database's convention is preferable over sqlalchemy's.</p> <p>\u6839\u636e\u60a8\u7684\u6570\u636e\u5e93\u7ea6\u5b9a\u660e\u786e\u8bbe\u7f6e\u7d22\u5f15\u7684\u547d\u540d\u4f18\u4e8e <code>sqlalchemy</code> \u81ea\u52a8\u547d\u540d\u3002</p> <pre><code>from sqlalchemy import MetaData\n\nPOSTGRES_INDEXES_NAMING_CONVENTION = {\n    \"ix\": \"%(column_0_label)s_idx\",\n    \"uq\": \"%(table_name)s_%(column_0_name)s_key\",\n    \"ck\": \"%(table_name)s_%(constraint_name)s_check\",\n    \"fk\": \"%(table_name)s_%(column_0_name)s_fkey\",\n    \"pk\": \"%(table_name)s_pkey\",\n}\nmetadata = MetaData(naming_convention=POSTGRES_INDEXES_NAMING_CONVENTION)\n</code></pre>"},{"location":"#12-\u8fc1\u79fb-alembic","title":"12. \u8fc1\u79fb: Alembic","text":"<ol> <li>\u8fc1\u79fb\u5fc5\u987b\u662f\u9759\u6001\u7684\u548c\u53ef\u6062\u590d\u7684\u3002 \u5982\u679c\u60a8\u7684\u8fc1\u79fb\u4f9d\u8d56\u4e8e\u52a8\u6001\u751f\u6210\u7684\u6570\u636e\uff0c\u90a3\u4e48\u8bf7\u786e\u4fdd\u552f\u4e00\u52a8\u6001\u7684\u662f\u6570\u636e\u672c\u8eab\uff0c\u800c\u4e0d\u662f\u5176\u7ed3\u6784\u3002</li> <li>\u751f\u6210\u5177\u6709\u63cf\u8ff0\u6027\u540d\u79f0\u548c slug \u7684\u8fc1\u79fb\u3002 Slug \u662f\u5fc5\u9700\u7684\uff0c\u5e94\u8be5\u89e3\u91ca\u8fd9\u4e9b\u53d8\u5316\u3002</li> <li>\u4e3a\u65b0\u8fc1\u79fb\u8bbe\u7f6e\u4eba\u7c7b\u53ef\u8bfb\u7684\u6587\u4ef6\u6a21\u677f\u3002 \u6211\u4eec\u4f7f\u7528 <code>*date*_*slug*.py</code> \u6a21\u5f0f\uff0c\u4f8b\u5982 <code>2022-08-24_post_content_idx.py</code></li> </ol> <pre><code># alembic.ini\nfile_template = %%(year)d-%%(month).2d-%%(day).2d_%%(slug)s\n</code></pre>"},{"location":"#13-\u8bbe\u7f6e\u6570\u636e\u5e93\u8868\u5b57\u5178\u547d\u540d\u7ea6\u5b9a","title":"13. \u8bbe\u7f6e\u6570\u636e\u5e93(\u8868/\u5b57\u5178)\u547d\u540d\u7ea6\u5b9a","text":"<p>\u547d\u540d\u4fdd\u6301\u4e00\u81f4\u5f88\u91cd\u8981\u3002 \u6211\u4eec\u9075\u5faa\u7684\u4e00\u4e9b\u89c4\u5219\uff1a</p> <ol> <li>lower_case_snake (\u5c0f\u5199\u9a7c\u5cf0\u547d\u540d)</li> <li>\u5355\u6570\u5f62\u5f0f (\u4f8b\u5982. <code>post</code>, <code>post_like</code>, <code>user_playlist</code>)</li> <li>\u4f7f\u7528\u6a21\u5757\u524d\u7f00\u5bf9\u76f8\u4f3c\u8868\u8fdb\u884c\u5206\u7ec4, \u4f8b\u5982. <code>payment_account</code>, <code>payment_bill</code>, <code>post</code>, <code>post_like</code></li> <li>\u8de8\u8868\u547d\u540d\u4fdd\u6301\u4e00\u81f4\uff0c\u4f46\u5177\u4f53\u7684\u547d\u540d\u662f\u53ef\u4ee5\u7684, \u4f8b\u5982.</li> <li>\u5728\u6240\u6709\u8868\u4e2d\u4f7f\u7528 <code>profile_id</code>\uff0c\u4f46\u5982\u679c\u5176\u4e2d\u4e00\u4e9b\u53ea\u9700\u8981\u4f5c\u4e3a\u521b\u5efa\u8005\u7684\u914d\u7f6e\u6587\u4ef6\uff0c\u8bf7\u4f7f\u7528 <code>creator_id</code></li> <li>\u5728\u6240\u6709\u62bd\u8c61\u8868\uff0c\u5f62\u5982 <code>post_like</code> \u3001 <code>post_view</code> \u4e2d\u4f7f\u7528 <code>post_id</code> \uff0c\u4f46\u5728\u76f8\u5173\u6a21\u5757\u4e2d\u4f7f\u7528\u5177\u4f53\u547d\u540d\uff0c\u5982 <code>chapters.course_id</code> \u4e2d\u7684 <code>course_id</code> \u3002</li> <li><code>_at</code> \u4f5c\u4e3a <code>datetime</code> \u7c7b\u578b\u7684\u540e\u7f00</li> <li><code>_date</code> \u4f5c\u4e3a <code>date</code> \u7c7b\u578b\u7684\u540e\u7f00</li> </ol>"},{"location":"#14-\u4ece\u7b2c0\u5929\u5f00\u59cb\u5199\u57fa\u4e8e\u5f02\u6b65\u7684\u6d4b\u8bd5","title":"14. \u4ece\u7b2c0\u5929\u5f00\u59cb\u5199\u57fa\u4e8e\u5f02\u6b65\u7684\u6d4b\u8bd5","text":"<p>\u57fa\u4e8eDB\u5199\u96c6\u6210\u6d4b\u8bd5\u5f88\u6709\u53ef\u80fd\u5bfc\u81f4\u5728\u5c06\u6765\u51fa\u73b0\u57fa\u4e8e\u4e8b\u4ef6\u5faa\u73af\u7684\u9519\u8bef\u3002</p> <p>\u7acb\u5373\u5f00\u59cb\u57fa\u4e8e\u5f02\u6b65\u6d4b\u8bd5\u5ba2\u6237\u7aef\u7684\u6d4b\u8bd5\uff0c \u4f8b\u5982. async_asgi_testclient \u6216 httpx</p> <pre><code>import pytest\nfrom async_asgi_testclient import TestClient\n\nfrom src.main import app  # inited FastAPI app\n\n\n@pytest.fixture\nasync def client():\n    host, port = \"127.0.0.1\", \"5555\"\n    scope = {\"client\": (host, port)}\n\n    async with TestClient(\n        app, scope=scope, headers={\"X-User-Fingerprint\": \"Test\"}\n    ) as client:\n        yield client\n\n\n@pytest.mark.asyncio\nasync def test_create_post(client: TestClient):\n    resp = await client.post(\"/posts\")\n\n    assert resp.status_code == 201\n</code></pre> <p>\u9664\u975e\u4f60\u6709\u540c\u6b65\u5230\u6570\u636e\u5e93\u8fde\u63a5\uff08\u6253\u6270\u4e86\uff1f\uff09\u6216\u8005\u4e0d\u6253\u7b97\u7f16\u5199\u96c6\u6210\u6d4b\u8bd5\u3002</p>"},{"location":"#15-\u540e\u53f0\u4efb\u52a1\u4f7f\u7528-asynciocreate_task","title":"15. \u540e\u53f0\u4efb\u52a1\u4f7f\u7528 asyncio.create_task","text":"<p>BackgroundTasks can effectively run both blocking and non-blocking I/O operations the same way FastAPI handles blocking routes (<code>sync</code> tasks are run in a threadpool, while <code>async</code> tasks are awaited later)</p> <ul> <li>Don't lie to the worker and don't mark blocking I/O operations as <code>async</code></li> <li>Don't use it for heavy CPU intensive tasks.</li> </ul> <pre><code>from fastapi import APIRouter, BackgroundTasks\nfrom pydantic import UUID4\n\nfrom src.notifications import service as notifications_service\n\n\nrouter = APIRouter()\n\n\n@router.post(\"/users/{user_id}/email\")\nasync def send_user_email(worker: BackgroundTasks, user_id: UUID4):\n\"\"\"Send email to user\"\"\"\n    worker.add_task(notifications_service.send_email, user_id)  # send email after responding client\n    return {\"status\": \"ok\"}\n</code></pre>"},{"location":"#16-\u7c7b\u578b\u6ce8\u89e3\u5f88\u91cd\u8981","title":"16. \u7c7b\u578b\u6ce8\u89e3\u5f88\u91cd\u8981","text":"<p>FastAPI, Pydantic, \u4ee5\u53ca\u73b0\u4ee3\u7684 IDE \u9f13\u52b1\u4f7f\u7528\u7c7b\u578b\u63d0\u793a\u3002</p> <p>\u6ca1\u6709\u7c7b\u578b\u63d0\u793a:</p> <p></p> <p>\u6709\u7c7b\u578b\u63d0\u793a:</p> <p></p>"},{"location":"#17-\u4ee5chunks\u5757\u7684\u5f62\u5f0f\u4fdd\u5b58\u6587\u4ef6","title":"17. \u4ee5chunks(\u5757)\u7684\u5f62\u5f0f\u4fdd\u5b58\u6587\u4ef6","text":"<p>\u4e0d\u8981\u671f\u671b\u60a8\u7684\u5ba2\u6237\u7aef\u53d1\u9001\u5c0f\u6587\u4ef6\u3002</p> <pre><code>import aiofiles\nfrom fastapi import UploadFile\n\nDEFAULT_CHUNK_SIZE = 1024 * 1024 * 50  # 50 megabytes MB(\u5146\u5b57\u8282)\n\nasync def save_video(video_file: UploadFile):\n   async with aiofiles.open(\"/file/path/name.mp4\", \"wb\") as f:\n     while chunk := await video_file.read(DEFAULT_CHUNK_SIZE):\n         await f.write(chunk)\n</code></pre>"},{"location":"#18-\u5c0f\u5fc3pydantic\u7684\u52a8\u6001\u5b57\u6bb5","title":"18. \u5c0f\u5fc3pydantic\u7684\u52a8\u6001\u5b57\u6bb5","text":"<p>\u5982\u679c\u4f60\u6709\u4e00\u4e2a\u53ef\u4ee5\u63a5\u53d7\u8054\u5408\u7c7b\u578b(Union)\u7684 pydantic \u5b57\u6bb5\uff0c\u8bf7\u786e\u4fdd\u9a8c\u8bc1\u5668\u660e\u786e\u77e5\u9053\u8fd9\u4e9b\u7c7b\u578b\u4e4b\u95f4\u7684\u533a\u522b\u3002</p> <pre><code>from pydantic import BaseModel\n\n\nclass Article(BaseModel):\n   text: str | None\n   extra: str | None\n\n\nclass Video(BaseModel):\n   video_id: int\n   text: str | None\n   extra: str | None\n\n\nclass Post(BaseModel):\n   content: Article | Video\n\n\npost = Post(content={\"video_id\": 1, \"text\": \"text\"})\nprint(type(post.content))\n# OUTPUT: Article\n# Article \u975e\u5e38\u5305\u5bb9\uff0c\u6240\u6709\u5b57\u6bb5\u90fd\u662f\u53ef\u9009\u7684\uff0c\u5141\u8bb8\u4efb\u4f55\u5b57\u5178\u751f\u6548\n</code></pre> <p>\u89e3\u51b3\u65b9\u6848:</p> <ol> <li>\u9a8c\u8bc1\u8f93\u5165\u53ea\u5141\u8bb8\u6709\u6548\u5b57\u6bb5\u5e76\u5728\u63d0\u4f9b\u672a\u77e5\u6570\u65f6\u5f15\u53d1\u9519\u8bef</li> </ol> <pre><code>from pydantic import BaseModel, Extra\n\nclass Article(BaseModel):\n   text: str | None\n   extra: str | None\n\n   class Config:\n        extra = Extra.forbid\n\n\nclass Video(BaseModel):\n   video_id: int\n   text: str | None\n   extra: str | None\n\n   class Config:\n        extra = Extra.forbid\n\n\nclass Post(BaseModel):\n   content: Article | Video\n</code></pre> <ol> <li>\u5982\u679c\u5b57\u6bb5\u5f88\u7b80\u5355\uff0c\u8bf7\u4f7f\u7528 Pydantic \u7684 Smart Union (&gt;v1.9)</li> </ol> <p>\u5982\u679c\u5b57\u6bb5\u5f88\u7b80\u5355\uff0c\u5982 <code>int</code> \u6216 <code>bool</code>\uff0c\u8fd9\u662f\u4e00\u4e2a\u5f88\u597d\u7684\u89e3\u51b3\u65b9\u6848\uff0c\u4f46\u5b83\u4e0d\u9002\u7528\u4e8e\u7c7b\u7b49\u590d\u6742\u5b57\u6bb5\u3002</p> <p>\u6ca1\u6709 Smart Union :</p> <pre><code>from pydantic import BaseModel\n\n\nclass Post(BaseModel):\n   field_1: bool | int\n   field_2: int | str\n   content: Article | Video\n\np = Post(field_1=1, field_2=\"1\", content={\"video_id\": 1})\nprint(p.field_1)\n# OUTPUT: True\nprint(type(p.field_2))\n# OUTPUT: int\nprint(type(p.content))\n# OUTPUT: Article\n</code></pre> <p>\u6709 Smart Union :</p> <pre><code>class Post(BaseModel):\n   field_1: bool | int\n   field_2: int | str\n   content: Article | Video\n\n   class Config:\n      smart_union = True\n\n\np = Post(field_1=1, field_2=\"1\", content={\"video_id\": 1})\nprint(p.field_1)\n# OUTPUT: 1\nprint(type(p.field_2))\n# OUTPUT: str\nprint(type(p.content))\n# OUTPUT: Article, \u56e0\u4e3a smart_union \u4e0d\u9002\u7528\u4e8e\u50cf\u7c7b\u8fd9\u6837\u7684\u590d\u6742\u5b57\u6bb5\n</code></pre> <ol> <li>\u5feb\u901f\u89e3\u51b3\u65b9\u6cd5</li> </ol> <p>\u6b63\u786e\u6392\u5e8f\u5b57\u6bb5\u7c7b\u578b: \u4ece\u6700\u4e25\u683c\u7684\u5230\u5bbd\u677e\u7684\u6821\u9a8c\u3002</p> <pre><code>class Post(BaseModel):\n   content: Video | Article\n</code></pre>"},{"location":"#19-sql-\u7b2c\u4e00-pydantic-\u7b2c\u4e8c","title":"19. SQL-\u7b2c\u4e00, Pydantic-\u7b2c\u4e8c","text":"<ul> <li>\u901a\u5e38\uff0c\u6570\u636e\u5e93\u5904\u7406\u6570\u636e\u7684\u901f\u5ea6\u6bd4 CPython \u66f4\u5feb\u3001\u66f4\u5e72\u51c0\u3002</li> <li>\u6700\u597d\u4f7f\u7528 SQL \u6267\u884c\u6240\u6709\u590d\u6742\u7684\u8fde\u63a5\u548c\u7b80\u5355\u7684\u6570\u636e\u64cd\u4f5c\u3002</li> <li>\u6700\u597d\u5728\u6570\u636e\u5e93\u4e2d\u805a\u5408 JSON \u4ee5\u54cd\u5e94\u5d4c\u5957\u5bf9\u8c61\u3002</li> </ul> <pre><code># src.posts.service\nfrom typing import Mapping\n\nfrom pydantic import UUID4\nfrom sqlalchemy import desc, func, select, text\nfrom sqlalchemy.sql.functions import coalesce\n\nfrom src.database import database, posts, profiles, post_review, products\n\nasync def get_posts(\n    creator_id: UUID4, *, limit: int = 10, offset: int = 0\n) -&gt; list[Mapping]: \n    select_query = (\n        select(\n            (\n                posts.c.id,\n                posts.c.type,\n                posts.c.slug,\n                posts.c.title,\n                func.json_build_object(\n                   text(\"'id', profiles.id\"),\n                   text(\"'first_name', profiles.first_name\"),\n                   text(\"'last_name', profiles.last_name\"),\n                   text(\"'username', profiles.username\"),\n                ).label(\"creator\"),\n            )\n        )\n        .select_from(posts.join(profiles, posts.c.owner_id == profiles.c.id))\n        .where(posts.c.owner_id == creator_id)\n        .limit(limit)\n        .offset(offset)\n        .group_by(\n            posts.c.id,\n            posts.c.type,\n            posts.c.slug,\n            posts.c.title,\n            profiles.c.id,\n            profiles.c.first_name,\n            profiles.c.last_name,\n            profiles.c.username,\n            profiles.c.avatar,\n        )\n        .order_by(\n            desc(coalesce(posts.c.updated_at, posts.c.published_at, posts.c.created_at))\n        )\n    )\n\n    return await database.fetch_all(select_query)\n\n# src.posts.schemas\nimport orjson\nfrom enum import Enum\n\nfrom pydantic import BaseModel, UUID4, validator\n\n\nclass PostType(str, Enum):\n    ARTICLE = \"ARTICLE\"\n    COURSE = \"COURSE\"\n\n\nclass Creator(BaseModel):\n    id: UUID4\n    first_name: str\n    last_name: str\n    username: str\n\n\nclass Post(BaseModel):\n    id: UUID4\n    type: PostType\n    slug: str\n    title: str\n    creator: Creator\n\n    @validator(\"creator\", pre=True)  # before default validation\n    def parse_json(cls, creator: str | dict | Creator) -&gt; dict | Creator:\n       if isinstance(creator, str):  # i.e. json\n          return orjson.loads(creator)\n\n       return creator\n\n# src.posts.router\nfrom fastapi import APIRouter, Depends\n\nrouter = APIRouter()\n\n\n@router.get(\"/creators/{creator_id}/posts\", response_model=list[Post])\nasync def get_creator_posts(creator: Mapping = Depends(valid_creator_id)):\n   posts = await service.get_posts(creator[\"id\"])\n\n   return posts\n</code></pre> <p>\u5982\u679c\u805a\u5408\u6570\u636e\u8868\u5355 DB \u662f\u4e00\u4e2a\u7b80\u5355\u7684 JSON\uff0c\u90a3\u4e48\u770b\u770b Pydantic \u7684<code>Json</code>\u5b57\u6bb5\u7c7b\u578b\uff0c\u5b83\u5c06\u9996\u5148\u52a0\u8f7d\u539f\u59cb JSON\u3002</p> <pre><code>from pydantic import BaseModel, Json\n\nclass A(BaseModel):\n    numbers: Json[list[int]]\n    dicts: Json[dict[str, int]]\n\nvalid_a = A(numbers=\"[1, 2, 3]\", dicts='{\"key\": 1000}')  # becomes A(numbers=[1,2,3], dicts={\"key\": 1000})\ninvalid_a = A(numbers='[\"a\", \"b\", \"c\"]', dicts='{\"key\": \"str instead of int\"}')  # raises ValueError\n</code></pre>"},{"location":"#20-\u9a8c\u8bc1host\u5982\u679c\u7528\u6237\u53ef\u4ee5\u53d1\u9001\u516c\u5f00\u53ef\u7528\u7684-url","title":"20. \u9a8c\u8bc1host\uff0c\u5982\u679c\u7528\u6237\u53ef\u4ee5\u53d1\u9001\u516c\u5f00\u53ef\u7528\u7684 URL","text":"<p>\u4f8b\u5982\uff0c\u6211\u4eec\u6709\u4e00\u4e2a\u7279\u5b9a\u7684\u5165\u53e3\uff1a</p> <ol> <li>\u63a5\u53d7\u6765\u81ea\u7528\u6237\u7684\u5a92\u4f53\u6587\u4ef6\uff0c</li> <li>\u4e3a\u6b64\u6587\u4ef6\u751f\u6210\u552f\u4e00\u7684 url\uff0c</li> <li>\u8fd4\u56de url \u7ed9\u7528\u6237\uff0c</li> <li>\u4ed6\u4eec\u5c06\u5728\u5176\u4ed6\u5165\u53e3\u4f7f\u7528\u5b83\u4eec\uff0c\u4f8b\u5982 <code>PUT /profiles/me</code>, <code>POST /posts</code></li> <li>\u8fd9\u4e9b\u7aef\u70b9\u53ea\u63a5\u53d7\u6765\u81ea\u767d\u540d\u5355\u4e3b\u673a\u7684\u6587\u4ef6</li> <li>\u4f7f\u7528\u6b64\u540d\u79f0\u548c\u5339\u914d\u7684 URL \u5c06\u6587\u4ef6\u4e0a\u4f20\u5230 AWS\u3002</li> </ol> <p>\u5982\u679c\u6211\u4eec\u4e0d\u5c06 URL \u4e3b\u673a\u5217\u5165\u767d\u540d\u5355\uff0c\u90a3\u4e48\u4e0d\u826f\u7528\u6237\u5c31\u6709\u673a\u4f1a\u4e0a\u4f20\u5371\u9669\u94fe\u63a5\u3002</p> <pre><code>from pydantic import AnyUrl, BaseModel\n\nALLOWED_MEDIA_URLS = {\"mysite.com\", \"mysite.org\"}\n\nclass CompanyMediaUrl(AnyUrl):\n    @classmethod\n    def validate_host(cls, parts: dict) -&gt; tuple[str, str, str, bool]:\n\"\"\"\u5c06 pydantic \u7684 AnyUrl \u9a8c\u8bc1\u6269\u5c55\u5230\u767d\u540d\u5355 URL \u4e3b\u673a\u3002\"\"\"\n        host, tld, host_type, rebuild = super().validate_host(parts)\n        if host not in ALLOWED_MEDIA_URLS:\n            raise ValueError(\n                \"Forbidden host url. Upload files only to internal services.\"\n            )\n\n        return host, tld, host_type, rebuild\n\n\nclass Profile(BaseModel):\n    avatar_url: CompanyMediaUrl  # only whitelisted urls for avatar\n</code></pre>"},{"location":"#21-\u5982\u679cschema\u76f4\u63a5\u9762\u5411\u5ba2\u6237\u7aef\u5728pydantic\u7684\u81ea\u5b9a\u4e49\u6821\u9a8c\u4e2d\u629b\u51favalueerror","title":"21. \u5982\u679cschema\u76f4\u63a5\u9762\u5411\u5ba2\u6237\u7aef\uff0c\u5728pydantic\u7684\u81ea\u5b9a\u4e49\u6821\u9a8c\u4e2d\u629b\u51faValueError","text":"<p>\u5b83\u5c06\u5411\u7528\u6237\u8fd4\u56de\u4e00\u4e2a\u5f88\u597d\u7684\u8be6\u7ec6\u54cd\u5e94\u3002</p> <pre><code># src.profiles.schemas\nfrom pydantic import BaseModel, validator\n\nclass ProfileCreate(BaseModel):\n    username: str\n\n    @validator(\"username\")\n    def validate_bad_words(cls, username: str):\n        if username  == \"me\":\n            raise ValueError(\"bad username, choose another\")\n\n        return username\n\n\n# src.profiles.routes\nfrom fastapi import APIRouter\n\nrouter = APIRouter()\n\n\n@router.post(\"/profiles\")\nasync def get_creator_posts(profile_data: ProfileCreate):\n   pass\n</code></pre> <p>Response \u4f8b\u5b50:</p> <p></p>"},{"location":"#22-\u4e0d\u8981\u5fd8\u8bb0-fastapi-\u5c06-response-\u7684-pydantic-\u5bf9\u8c61\u8f6c\u6362\u4e3a-dict\u7136\u540e\u8f6c\u6362\u4e3a-responsemodel-\u7684\u5b9e\u4f8b\u7136\u540e\u8f6c\u6362\u4e3a-dict\u7136\u540e\u8f6c\u6362\u4e3a-json","title":"22. \u4e0d\u8981\u5fd8\u8bb0 FastAPI \u5c06 Response \u7684 Pydantic \u5bf9\u8c61\u8f6c\u6362\u4e3a Dict\uff0c\u7136\u540e\u8f6c\u6362\u4e3a ResponseModel \u7684\u5b9e\u4f8b\uff0c\u7136\u540e\u8f6c\u6362\u4e3a Dict\uff0c\u7136\u540e\u8f6c\u6362\u4e3a JSON","text":"<pre><code>from fastapi import FastAPI\nfrom pydantic import BaseModel, root_validator\n\napp = FastAPI()\n\n\nclass ProfileResponse(BaseModel):\n    @root_validator\n    def debug_usage(cls, data: dict):\n        print(\"created pydantic model\")\n\n        return data\n\n    def dict(self, *args, **kwargs):\n        print(\"called dict\")\n        return super().dict(*args, **kwargs)\n\n\n@app.get(\"/\", response_model=ProfileResponse)\nasync def root():\n    return ProfileResponse()\n</code></pre> <p>\u65e5\u5fd7\u8f93\u51fa:</p> <pre><code>[INFO] [2022-08-28 12:00:00.000000] created pydantic model\n[INFO] [2022-08-28 12:00:00.000010] called dict\n[INFO] [2022-08-28 12:00:00.000020] created pydantic model\n[INFO] [2022-08-28 12:00:00.000030] called dict\n</code></pre>"},{"location":"#23-\u5982\u679c\u4f60\u5fc5\u987b\u4f7f\u7528sync\u540c\u6b65-sdk-\u8bf7\u5728\u7ebf\u7a0b\u6c60\u4e2d\u8fd0\u884c","title":"23. \u5982\u679c\u4f60\u5fc5\u987b\u4f7f\u7528sync(\u540c\u6b65) SDK, \u8bf7\u5728\u7ebf\u7a0b\u6c60\u4e2d\u8fd0\u884c","text":"<p>\u5982\u679c\u60a8\u5fc5\u987b\u4f7f\u7528\u5e93\u4e0e\u5916\u90e8\u670d\u52a1\u4ea4\u4e92\uff0c\u5e76\u4e14\u5b83\u4e0d\u652f\u6301<code>async</code>(\u5f02\u6b65)\uff0c\u5219\u5728\u5916\u90e8\u5de5\u4f5c\u7ebf\u7a0b\u4e2d\u8fdb\u884c HTTP \u8c03\u7528\u3002</p> <p>\u4e3e\u4e2a\u7b80\u5355\u7684\u4f8b\u5b50\uff0c\u6211\u4eec\u53ef\u4ee5\u4f7f\u7528\u6765\u81ea starlette \u7684\u8457\u540d\u7684<code>run_in_threadpool</code>\u3002</p> <pre><code>from fastapi import FastAPI\nfrom fastapi.concurrency import run_in_threadpool\nfrom my_sync_library import SyncAPIClient \n\napp = FastAPI()\n\n\n@app.get(\"/\")\nasync def call_my_sync_library():\n    my_data = await service.get_my_data()\n\n    client = SyncAPIClient()\n    await run_in_threadpool(client.make_request, data=my_data)\n</code></pre>"},{"location":"#24-\u4f7f\u7528-linters-black-isort-autoflake","title":"24. \u4f7f\u7528 linters (black, isort, autoflake)","text":"<p>With linters, you can forget about formatting the code and focus on writing the business logic.</p> <p>Black is the uncompromising code formatter that eliminates so many small decisions you have to make during development. Other linters help you write cleaner code and follow the PEP8.</p> <p>It's a popular good practice to use pre-commit hooks, but just using the script was ok for us.</p> <pre><code>#!/bin/sh -e\nset -x\n\nautoflake --remove-all-unused-imports --recursive --remove-unused-variables --in-place src tests --exclude=__init__.py\nisort src tests --profile black\nblack src tests\n</code></pre>"},{"location":"#\u60ca\u559c\u90e8\u5206","title":"\u60ca\u559c\u90e8\u5206","text":"<p>\u4e00\u4e9b\u975e\u5e38\u5584\u826f\u7684\u4eba\u5206\u4eab\u4e86\u4ed6\u4eec\u81ea\u5df1\u7684\u7ecf\u9a8c\u548c\u6700\u4f73\u5b9e\u8df5\uff0c\u7edd\u5bf9\u503c\u5f97\u4e00\u8bfb\u3002</p> <p>\u5728\u9879\u76ee\u7684 issues \u90e8\u5206\u67e5\u770b\u5b83\u4eec\u3002</p> <p>\u4f8b\u5982\uff0clowercase00 \u8be6\u7ec6\u63cf\u8ff0\u4e86\u4ed6\u4eec\u4f7f\u7528\u6743\u9650\u548c\u6388\u6743\u3001\u57fa\u4e8e\u7c7b\u7684\u670d\u52a1\u548c\u89c6\u56fe\u3001\u4efb\u52a1\u961f\u5217\u7684\u6700\u4f73\u5b9e\u8df5\uff0c \u81ea\u5b9a\u4e49\u54cd\u5e94\u5e8f\u5217\u5316\u7a0b\u5e8f\uff0c\u4f7f\u7528 dynaconf \u8fdb\u884c\u914d\u7f6e\u7b49\u3002</p> <p>\u5982\u679c\u60a8\u6709\u4efb\u4f55\u5173\u4e8e\u4f7f\u7528 FastAPI \u7684\u7ecf\u9a8c\u8981\u5206\u4eab\uff0c\u65e0\u8bba\u662f\u597d\u662f\u574f\uff0c\u90fd\u975e\u5e38\u6b22\u8fce\u60a8\u521b\u5efa\u4e00\u4e2a\u65b0\u95ee\u9898\u3002 \u9605\u8bfb\u5b83\u662f\u6211\u4eec\u7684\u8363\u5e78\u3002</p>"},{"location":"about/","title":"\u5173\u4e8e","text":"<ul> <li>\u7ffb\u8bd1\u81ea https://github.com/zhanymkanov/fastapi-best-practices \u6709\u6548\u6027\u53c2\u8003\u539f\u6587\u3002</li> </ul>"},{"location":"about/#\u5176\u4ed6","title":"\u5176\u4ed6","text":"<p>\u4f5c\u8005\u8fd8\u6709\u4e00\u4e2a\u4ed3\u5e93: https://github.com/zhanymkanov/fastapi_production_template - \u4e00\u4e2a\u57fa\u4e8efastapi\u7684\u751f\u4ea7\u6a21\u7248\u4ed3\u5e93\uff0c\u4e5f\u633a\u4e0d\u9519\u7684\u3002</p>"},{"location":"raw_en/","title":"FastAPI Best Practices","text":"<p>Opinionated list of best practices and conventions we used at our startup.</p> <p>For the last 1.5 years in production, we have been making good and bad decisions that impacted our developer experience dramatically. Some of them are worth sharing.</p>"},{"location":"raw_en/#1-project-structure-consistent--predictable","title":"1. Project Structure. Consistent &amp; predictable","text":"<p>There are many ways to structure the project, but the best structure is a structure that is consistent, straightforward, and has no surprises.</p> <ul> <li>If looking at the project structure doesn't give you an idea of what the project is about, then the structure might be unclear.</li> <li>If you have to open packages to understand what modules are located in them, then your structure is unclear.</li> <li>If the frequency and location of the files feels random, then your project structure is bad.</li> <li>If looking at the module's location and its name doesn't give you an idea of what's inside it, then your structure is very bad.</li> </ul> <p>Although the project structure, where we separate files by their type (e.g. api, crud, models, schemas) presented by @tiangolo is good for microservices or projects with fewer scopes, we couldn't fit it into our monolith with a lot of domains and modules. Structure that I found more scalable and evolvable is inspired by Netflix's Dispatch with some little modifications.</p> <pre><code>fastapi-project\n\u251c\u2500\u2500 alembic/\n\u251c\u2500\u2500 src\n\u2502   \u251c\u2500\u2500 auth\n\u2502   \u2502   \u251c\u2500\u2500 router.py\n\u2502   \u2502   \u251c\u2500\u2500 schemas.py  # pydantic models\n\u2502   \u2502   \u251c\u2500\u2500 models.py  # db models\n\u2502   \u2502   \u251c\u2500\u2500 dependencies.py\n\u2502   \u2502   \u251c\u2500\u2500 config.py  # local configs\n\u2502   \u2502   \u251c\u2500\u2500 constants.py\n\u2502   \u2502   \u251c\u2500\u2500 exceptions.py\n\u2502   \u2502   \u251c\u2500\u2500 service.py\n\u2502   \u2502   \u2514\u2500\u2500 utils.py\n\u2502   \u251c\u2500\u2500 aws\n\u2502   \u2502   \u251c\u2500\u2500 client.py  # client model for external service communication\n\u2502   \u2502   \u251c\u2500\u2500 schemas.py\n\u2502   \u2502   \u251c\u2500\u2500 config.py\n\u2502   \u2502   \u251c\u2500\u2500 constants.py\n\u2502   \u2502   \u251c\u2500\u2500 exceptions.py\n\u2502   \u2502   \u2514\u2500\u2500 utils.py\n\u2502   \u2514\u2500\u2500 posts\n\u2502   \u2502   \u251c\u2500\u2500 router.py\n\u2502   \u2502   \u251c\u2500\u2500 schemas.py\n\u2502   \u2502   \u251c\u2500\u2500 models.py\n\u2502   \u2502   \u251c\u2500\u2500 dependencies.py\n\u2502   \u2502   \u251c\u2500\u2500 constants.py\n\u2502   \u2502   \u251c\u2500\u2500 exceptions.py\n\u2502   \u2502   \u251c\u2500\u2500 service.py\n\u2502   \u2502   \u2514\u2500\u2500 utils.py\n\u2502   \u251c\u2500\u2500 config.py  # global configs\n\u2502   \u251c\u2500\u2500 models.py  # global models\n\u2502   \u251c\u2500\u2500 exceptions.py  # global exceptions\n\u2502   \u251c\u2500\u2500 pagination.py  # global module e.g. pagination\n\u2502   \u251c\u2500\u2500 database.py  # db connection related stuff\n\u2502   \u2514\u2500\u2500 main.py\n\u251c\u2500\u2500 tests/\n\u2502   \u251c\u2500\u2500 auth\n\u2502   \u251c\u2500\u2500 aws\n\u2502   \u2514\u2500\u2500 posts\n\u251c\u2500\u2500 templates/\n\u2502   \u2514\u2500\u2500 index.html\n\u251c\u2500\u2500 requirements\n\u2502   \u251c\u2500\u2500 base.txt\n\u2502   \u251c\u2500\u2500 dev.txt\n\u2502   \u2514\u2500\u2500 prod.txt\n\u251c\u2500\u2500 .env\n\u251c\u2500\u2500 .gitignore\n\u251c\u2500\u2500 logging.ini\n\u2514\u2500\u2500 alembic.ini\n</code></pre> <ol> <li>Store all domain directories inside <code>src</code> folder</li> <li><code>src/</code> - highest level of an app, contains common models, configs, and constants, etc.</li> <li><code>src/main.py</code> - root of the project, which inits the FastAPI app</li> <li>Each package has its own router, schemas, models, etc.</li> <li><code>router.py</code> - is a core of each module with all the endpoints</li> <li><code>schemas.py</code> - for pydantic models</li> <li><code>models.py</code> - for db models</li> <li><code>service.py</code> - module specific business logic  </li> <li><code>dependencies.py</code> - router dependencies</li> <li><code>constants.py</code> - module specific constants and error codes</li> <li><code>config.py</code> - e.g. env vars</li> <li><code>utils.py</code> - non-business logic functions, e.g. response normalization, data enrichment, etc.</li> <li><code>exceptions</code> - module specific exceptions, e.g. <code>PostNotFound</code>, <code>InvalidUserData</code></li> <li>When package requires services or dependencies or constants from other packages - import them with an explicit module name</li> </ol> <pre><code>from src.auth import constants as auth_constants\nfrom src.notifications import service as notification_service\nfrom src.posts.constants import ErrorCode as PostsErrorCode  # in case we have Standard ErrorCode in constants module of each package\n</code></pre>"},{"location":"raw_en/#2-excessively-use-pydantic-for-data-validation","title":"2. Excessively use Pydantic for data validation","text":"<p>Pydantic has a rich set of features to validate and transform data.</p> <p>In addition to regular features like required &amp; non-required fields with default values, Pydantic has built-in comprehensive data processing tools like regex, enums for limited allowed options, length validation, email validation, etc.</p> <pre><code>from enum import Enum\nfrom pydantic import AnyUrl, BaseModel, EmailStr, Field, constr\n\nclass MusicBand(str, Enum):\n   AEROSMITH = \"AEROSMITH\"\n   QUEEN = \"QUEEN\"\n   ACDC = \"AC/DC\"\n\n\nclass UserBase(BaseModel):\n    first_name: str = Field(min_length=1, max_length=128)\n    username: constr(regex=\"^[A-Za-z0-9-_]+$\", to_lower=True, strip_whitespace=True)\n    email: EmailStr\n    age: int = Field(ge=18, default=None)  # must be greater or equal to 18\n    favorite_band: MusicBand = None  # only \"AEROSMITH\", \"QUEEN\", \"AC/DC\" values are allowed to be inputted\n    website: AnyUrl = None\n</code></pre>"},{"location":"raw_en/#3-use-dependencies-for-data-validation-vs-db","title":"3. Use dependencies for data validation vs DB","text":"<p>Pydantic can only validate the values from client input. Use dependencies to validate data against database constraints like email already exists, user not found, etc.</p> <pre><code># dependencies.py\nasync def valid_post_id(post_id: UUID4) -&gt; Mapping:\n    post = await service.get_by_id(post_id)\n    if not post:\n        raise PostNotFound()\n\n    return post\n\n\n# router.py\n@router.get(\"/posts/{post_id}\", response_model=PostResponse)\nasync def get_post_by_id(post: Mapping = Depends(valid_post_id)):\n    return post\n\n\n@router.put(\"/posts/{post_id}\", response_model=PostResponse)\nasync def update_post(\n    update_data: PostUpdate,  \n    post: Mapping = Depends(valid_post_id), \n):\n    updated_post: Mapping = await service.update(id=post[\"id\"], data=update_data)\n    return updated_post\n\n\n@router.get(\"/posts/{post_id}/reviews\", response_model=list[ReviewsResponse])\nasync def get_post_reviews(post: Mapping = Depends(valid_post_id)):\n    post_reviews: list[Mapping] = await reviews_service.get_by_post_id(post[\"id\"])\n    return post_reviews\n</code></pre> <p>If we didn't put data validation to dependency, we would have to add post_id validation for every endpoint and write the same tests for each of them.</p>"},{"location":"raw_en/#4-chain-dependencies","title":"4. Chain dependencies","text":"<p>Dependencies can use other dependencies and avoid code repetition for similar logic.</p> <pre><code># dependencies.py\nfrom fastapi.security import OAuth2PasswordBearer\nfrom jose import JWTError, jwt\n\nasync def valid_post_id(post_id: UUID4) -&gt; Mapping:\n    post = await service.get_by_id(post_id)\n    if not post:\n        raise PostNotFound()\n\n    return post\n\n\nasync def parse_jwt_data(\n    token: str = Depends(OAuth2PasswordBearer(tokenUrl=\"/auth/token\"))\n) -&gt; dict:\n    try:\n        payload = jwt.decode(token, \"JWT_SECRET\", algorithms=[\"HS256\"])\n    except JWTError:\n        raise InvalidCredentials()\n\n    return {\"user_id\": payload[\"id\"]}\n\n\nasync def valid_owned_post(\n    post: Mapping = Depends(valid_post_id), \n    token_data: dict = Depends(parse_jwt_data),\n) -&gt; Mapping:\n    if post[\"creator_id\"] != token_data[\"user_id\"]:\n        raise UserNotOwner()\n\n    return post\n\n# router.py\n@router.get(\"/users/{user_id}/posts/{post_id}\", response_model=PostResponse)\nasync def get_user_post(post: Mapping = Depends(valid_owned_post)):\n    return post\n</code></pre>"},{"location":"raw_en/#5-decouple--reuse-dependencies-dependency-calls-are-cached","title":"5. Decouple &amp; Reuse dependencies. Dependency calls are cached","text":"<p>Dependencies can be reused multiple times, and they won't be recalculated - FastAPI caches dependency's result within a request's scope by default, i.e. if we have a dependency that calls service <code>get_post_by_id</code>, we won't be visiting DB each time we call this dependency - only the first function call.</p> <p>Knowing this, we can easily decouple dependencies onto multiple smaller functions that operate on a smaller domain and are easier to reuse in other routes. For example, in the code below we are using <code>parse_jwt_data</code> three times:</p> <ol> <li><code>valid_owned_post</code></li> <li><code>valid_active_creator</code></li> <li><code>get_user_post</code>,</li> </ol> <p>but <code>parse_jwt_data</code> is called only once, in the very first call.</p> <pre><code># dependencies.py\nfrom fastapi import BackgroundTasks\nfrom fastapi.security import OAuth2PasswordBearer\nfrom jose import JWTError, jwt\n\nasync def valid_post_id(post_id: UUID4) -&gt; Mapping:\n    post = await service.get_by_id(post_id)\n    if not post:\n        raise PostNotFound()\n\n    return post\n\n\nasync def parse_jwt_data(\n    token: str = Depends(OAuth2PasswordBearer(tokenUrl=\"/auth/token\"))\n) -&gt; dict:\n    try:\n        payload = jwt.decode(token, \"JWT_SECRET\", algorithms=[\"HS256\"])\n    except JWTError:\n        raise InvalidCredentials()\n\n    return {\"user_id\": payload[\"id\"]}\n\n\nasync def valid_owned_post(\n    post: Mapping = Depends(valid_post_id), \n    token_data: dict = Depends(parse_jwt_data),\n) -&gt; Mapping:\n    if post[\"creator_id\"] != token_data[\"user_id\"]:\n        raise UserNotOwner()\n\n    return post\n\n\nasync def valid_active_creator(\n    token_data: dict = Depends(parse_jwt_data),\n):\n    user = await users_service.get_by_id(token_data[\"user_id\"])\n    if not user[\"is_active\"]:\n        raise UserIsBanned()\n\n    if not user[\"is_creator\"]:\n       raise UserNotCreator()\n\n    return user\n\n\n# router.py\n@router.get(\"/users/{user_id}/posts/{post_id}\", response_model=PostResponse)\nasync def get_user_post(\n    worker: BackgroundTasks,\n    post: Mapping = Depends(valid_owned_post),\n    user: Mapping = Depends(valid_active_creator),\n):\n\"\"\"Get post that belong the active user.\"\"\"\n    worker.add_task(notifications_service.send_email, user[\"id\"])\n    return post\n</code></pre>"},{"location":"raw_en/#6-follow-the-rest","title":"6. Follow the REST","text":"<p>Developing RESTful API makes it easier to reuse dependencies in routes like these:</p> <ol> <li><code>GET /courses/:course_id</code></li> <li><code>GET /courses/:course_id/chapters/:chapter_id/lessons</code></li> <li><code>GET /chapters/:chapter_id</code></li> </ol> <p>The only caveat is to use the same variable names in the path:</p> <ul> <li>If you have two endpoints <code>GET /profiles/:profile_id</code> and <code>GET /creators/:creator_id</code> that both validate whether the given <code>profile_id</code> exists,  but <code>GET /creators/:creator_id</code> also checks if the profile is creator, then it's better to rename <code>creator_id</code> path variable to <code>profile_id</code> and chain those two dependencies.</li> </ul> <pre><code># src.profiles.dependencies\nasync def valid_profile_id(profile_id: UUID4) -&gt; Mapping:\n    profile = await service.get_by_id(post_id)\n    if not profile:\n        raise ProfileNotFound()\n\n    return profile\n\n# src.creators.dependencies\nasync def valid_creator_id(profile: Mapping = Depends(valid_profile_id)) -&gt; Mapping:\n    if not profile[\"is_creator\"]:\n       raise ProfileNotCreator()\n\n    return profile\n\n# src.profiles.router.py\n@router.get(\"/profiles/{profile_id}\", response_model=ProfileResponse)\nasync def get_user_profile_by_id(profile: Mapping = Depends(valid_profile_id)):\n\"\"\"Get profile by id.\"\"\"\n    return profile\n\n# src.creators.router.py\n@router.get(\"/creators/{profile_id}\", response_model=ProfileResponse)\nasync def get_user_profile_by_id(\n     creator_profile: Mapping = Depends(valid_creator_id)\n):\n\"\"\"Get creator's profile by id.\"\"\"\n    return creator_profile\n</code></pre> <p>Use /me endpoints for users resources (e.g. <code>GET /profiles/me</code>, <code>GET /users/me/posts</code>)</p> <ol> <li>No need to validate that user id exists - it's already checked via auth method</li> <li>No need to check whether the user id belongs to the requester</li> </ol>"},{"location":"raw_en/#7-dont-make-your-routes-async-if-you-have-only-blocking-io-operations","title":"7. Don't make your routes async, if you have only blocking I/O operations","text":"<p>Under the hood, FastAPI can effectively handle both async and sync I/O operations.</p> <ul> <li>FastAPI runs <code>sync</code> routes in the threadpool and blocking I/O operations won't stop the event loop from executing the tasks.</li> <li>Otherwise, if the route is defined <code>async</code> then it's called regularly via <code>await</code> and FastAPI trusts you to do only non-blocking I/O operations.</li> </ul> <p>The caveat is if you fail that trust and execute blocking operations within async routes, the event loop will not be able to run the next tasks until that blocking operation is done.</p> <pre><code>import asyncio\nimport time\n\n@router.get(\"/terrible-ping\")\nasync def terrible_catastrophic_ping():\n    time.sleep(10) # I/O blocking operation for 10 seconds\n    pong = service.get_pong()  # I/O blocking operation to get pong from DB\n\n    return {\"pong\": pong}\n\n@router.get(\"/good-ping\")\ndef good_ping():\n    time.sleep(10) # I/O blocking operation for 10 seconds, but in another thread\n    pong = service.get_pong()  # I/O blocking operation to get pong from DB, but in another thread\n\n    return {\"pong\": pong}\n\n@router.get(\"/perfect-ping\")\nasync def perfect_ping():\n    await asyncio.sleep(10) # non-blocking I/O operation\n    pong = await service.async_get_pong()  # non-blocking I/O db call\n\n    return {\"pong\": pong}\n</code></pre> <p>What happens when we call:</p> <ol> <li><code>GET /terrible-ping</code></li> <li>FastAPI server receives a request and starts handling it</li> <li>Server's event loop and all the tasks in the queue will be waiting until <code>time.sleep()</code> is finished<ol> <li>Server thinks <code>time.sleep()</code> is not an I/O task, so it waits until it is finished</li> <li>Server won't accept any new requests while waiting</li> </ol> </li> <li>Then, event loop and all the tasks in the queue will be waiting until <code>service.get_pong</code> is finished<ol> <li>Server thinks <code>service.get_pong()</code> is not an I/O task, so it waits until it is finished</li> <li>Server won't accept any new requests while waiting</li> </ol> </li> <li>Server returns the response.<ol> <li>After a response, server starts accepting new requests</li> </ol> </li> <li><code>GET /good-ping</code></li> <li>FastAPI server receives a request and starts handling it</li> <li>FastAPI sends the whole route <code>good_ping</code> to the threadpool, where a worker thread will run the function</li> <li>While <code>good_ping</code> is being executed, event loop selects next tasks from the queue and works on them (e.g. accept new request, call db)<ul> <li>Independently of main thread (i.e. our FastAPI app),     worker thread will be waiting for <code>time.sleep</code> to finish and then for <code>service.get_pong</code> to finish</li> <li>Sync operation blocks only the side thread, not the main one.</li> </ul> </li> <li>When <code>good_ping</code> finishes its work, server returns a response to the client</li> <li><code>GET /perfect-ping</code></li> <li>FastAPI server receives a request and starts handling it</li> <li>FastAPI awaits <code>asyncio.sleep(10)</code></li> <li>Event loop selects next tasks from the queue and works on them (e.g. accept new request, call db)</li> <li>When <code>asyncio.sleep(10)</code> is done, servers goes to the next lines and awaits <code>service.async_get_pong</code></li> <li>Event loop selects next tasks from the queue and works on them (e.g. accept new request, call db)</li> <li>When <code>service.async_get_pong</code> is done, server returns a response to the client</li> </ol> <p>The second caveat is that operations that are non-blocking awaitables or are sent to the thread pool must be I/O intensive tasks (e.g. open file, db call, external API call).</p> <ul> <li>Awaiting CPU-intensive tasks (e.g. heavy calculations, data processing, video transcoding) is worthless since the CPU has to work to finish the tasks, while I/O operations are external and server does nothing while waiting for that operations to finish, thus it can go to the next tasks.</li> <li>Running CPU-intensive tasks in other threads also isn't effective, because of GIL. In short, GIL allows only one thread to work at a time, which makes it useless for CPU tasks.</li> <li>If you want to optimize CPU intensive tasks you should send them to workers in another process.</li> </ul> <p>Related StackOverflow questions of confused users</p> <ol> <li>https://stackoverflow.com/questions/62976648/architecture-flask-vs-fastapi/70309597#70309597</li> <li>Here you can also check my answer</li> <li>https://stackoverflow.com/questions/65342833/fastapi-uploadfile-is-slow-compared-to-flask</li> <li>https://stackoverflow.com/questions/71516140/fastapi-runs-api-calls-in-serial-instead-of-parallel-fashion</li> </ol>"},{"location":"raw_en/#8-custom-base-model-from-day-0","title":"8. Custom base model from day 0","text":"<p>Having a controllable global base model allows us to customize all the models within the app. For example, we could have a standard datetime format or add a super method for all subclasses of the base model.</p> <pre><code>from datetime import datetime\nfrom zoneinfo import ZoneInfo\n\nimport orjson\nfrom fastapi.encoders import jsonable_encoder\nfrom pydantic import BaseModel, root_validator\n\n\ndef orjson_dumps(v, *, default):\n    # orjson.dumps returns bytes, to match standard json.dumps we need to decode\n    return orjson.dumps(v, default=default).decode()\n\n\ndef convert_datetime_to_gmt(dt: datetime) -&gt; str:\n    if not dt.tzinfo:\n        dt = dt.replace(tzinfo=ZoneInfo(\"UTC\"))\n\n    return dt.strftime(\"%Y-%m-%dT%H:%M:%S%z\")\n\n\nclass ORJSONModel(BaseModel):\n    class Config:\n        json_loads = orjson.loads\n        json_dumps = orjson_dumps\n        json_encoders = {datetime: convert_datetime_to_gmt}  # method for customer JSON encoding of datetime fields\n\n    @root_validator()\n    def set_null_microseconds(cls, data: dict) -&gt; dict:\n\"\"\"Drops microseconds in all the datetime field values.\"\"\"\n        datetime_fields = {\n            k: v.replace(microsecond=0)\n            for k, v in data.items()\n            if isinstance(k, datetime)\n        }\n\n        return {**data, **datetime_fields}\n\n    def serializable_dict(self, **kwargs):\n\"\"\"Return a dict which contains only serializable fields.\"\"\"\n        default_dict = super().dict(**kwargs)\n\n        return jsonable_encoder(default_dict)\n</code></pre> <p>In the example above we have decided to make a global base model which:</p> <ul> <li>uses orjson to serialize data</li> <li>drops microseconds to 0 in all date formats</li> <li>serializes all datetime fields to standard format with explicit timezone</li> </ul>"},{"location":"raw_en/#9-docs","title":"9. Docs","text":"<ol> <li>Unless your API is public, hide docs by default. Show it explicitly on the selected envs only.</li> </ol> <pre><code>from fastapi import FastAPI\nfrom starlette.config import Config\n\nconfig = Config(\".env\")  # parse .env file for env variables\n\nENVIRONMENT = config(\"ENVIRONMENT\")  # get current env name\nSHOW_DOCS_ENVIRONMENT = (\"local\", \"staging\")  # explicit list of allowed envs\n\napp_configs = {\"title\": \"My Cool API\"}\nif ENVIRONMENT not in SHOW_DOCS_ENVIRONMENT:\n   app_configs[\"openapi_url\"] = None  # set url for docs as null\n\napp = FastAPI(**app_configs)\n</code></pre> <ol> <li>Help FastAPI to generate an easy-to-understand docs</li> <li>Set <code>response_model</code>, <code>status_code</code>, <code>description</code>, etc.</li> <li>If models and statuses vary, use <code>responses</code> route attribute to add docs for different responses</li> </ol> <pre><code>from fastapi import APIRouter, status\n\nrouter = APIRouter()\n\n@router.post(\n    \"/endpoints\",\n    response_model=DefaultResponseModel,  # default response pydantic model \n    status_code=status.HTTP_201_CREATED,  # default status code\n    description=\"Description of the well documented endpoint\",\n    tags=[\"Endpoint Category\"],\n    summary=\"Summary of the Endpoint\",\n    responses={\n        status.HTTP_200_OK: {\n            \"model\": OkResponse, # custom pydantic model for 200 response\n            \"description\": \"Ok Response\",\n        },\n        status.HTTP_201_CREATED: {\n            \"model\": CreatedResponse,  # custom pydantic model for 201 response\n            \"description\": \"Creates something from user request \",\n        },\n        status.HTTP_202_ACCEPTED: {\n            \"model\": AcceptedResponse,  # custom pydantic model for 202 response\n            \"description\": \"Accepts request and handles it later\",\n        },\n    },\n)\nasync def documented_route():\n    pass\n</code></pre> <p>Will generate docs like this: </p>"},{"location":"raw_en/#10-use-pydantics-basesettings-for-configs","title":"10. Use Pydantic's BaseSettings for configs","text":"<p>Pydantic gives a powerful tool to parse environment variables and process them with its validators.</p> <pre><code>from pydantic import AnyUrl, BaseSettings, PostgresDsn\n\nclass AppSettings(BaseSettings):\n    class Config:\n        env_file = \".env\"\n        env_file_encoding = \"utf-8\"\n        env_prefix = \"app_\"\n\n    DATABASE_URL: PostgresDsn\n    IS_GOOD_ENV: bool = True\n    ALLOWED_CORS_ORIGINS: set[AnyUrl]\n</code></pre>"},{"location":"raw_en/#11-sqlalchemy-set-db-keys-naming-convention","title":"11. SQLAlchemy: Set DB keys naming convention","text":"<p>Explicitly setting the indexes' namings according to your database's convention is preferable over sqlalchemy's.</p> <pre><code>from sqlalchemy import MetaData\n\nPOSTGRES_INDEXES_NAMING_CONVENTION = {\n    \"ix\": \"%(column_0_label)s_idx\",\n    \"uq\": \"%(table_name)s_%(column_0_name)s_key\",\n    \"ck\": \"%(table_name)s_%(constraint_name)s_check\",\n    \"fk\": \"%(table_name)s_%(column_0_name)s_fkey\",\n    \"pk\": \"%(table_name)s_pkey\",\n}\nmetadata = MetaData(naming_convention=POSTGRES_INDEXES_NAMING_CONVENTION)\n</code></pre>"},{"location":"raw_en/#12-migrations-alembic","title":"12. Migrations. Alembic","text":"<ol> <li>Migrations must be static and revertable. If your migrations depend on dynamically generated data, then make sure the only thing that is dynamic is the data itself, not its structure.</li> <li>Generate migrations with descriptive names &amp; slugs. Slug is required and should explain the changes.</li> <li>Set human-readable file template for new migrations. We use <code>*date*_*slug*.py</code> pattern, e.g. <code>2022-08-24_post_content_idx.py</code></li> </ol> <pre><code># alembic.ini\nfile_template = %%(year)d-%%(month).2d-%%(day).2d_%%(slug)s\n</code></pre>"},{"location":"raw_en/#13-set-db-naming-convention","title":"13. Set DB naming convention","text":"<p>Being consistent with names is important. Some rules we followed:</p> <ol> <li>lower_case_snake</li> <li>singular form (e.g. <code>post</code>, <code>post_like</code>, <code>user_playlist</code>)</li> <li>group similar tables with module prefix, e.g. <code>payment_account</code>, <code>payment_bill</code>, <code>post</code>, <code>post_like</code></li> <li>stay consistent across tables, but concrete namings are ok, e.g.</li> <li>use <code>profile_id</code> in all tables, but if some of them need only profiles that are creators, use <code>creator_id</code></li> <li>use <code>post_id</code> for all abstract tables like <code>post_like</code>, <code>post_view</code>, but use concrete naming in relevant modules like <code>course_id</code> in <code>chapters.course_id</code></li> <li><code>_at</code> suffix for datetime</li> <li><code>_date</code> suffix for date</li> </ol>"},{"location":"raw_en/#14-set-tests-client-async-from-day-0","title":"14. Set tests client async from day 0","text":"<p>Writing integration tests with DB will most likely lead to messed up event loop errors in the future. Set the async test client immediately, e.g. async_asgi_testclient or httpx</p> <pre><code>import pytest\nfrom async_asgi_testclient import TestClient\n\nfrom src.main import app  # inited FastAPI app\n\n\n@pytest.fixture\nasync def client():\n    host, port = \"127.0.0.1\", \"5555\"\n    scope = {\"client\": (host, port)}\n\n    async with TestClient(\n        app, scope=scope, headers={\"X-User-Fingerprint\": \"Test\"}\n    ) as client:\n        yield client\n\n\n@pytest.mark.asyncio\nasync def test_create_post(client: TestClient):\n    resp = await client.post(\"/posts\")\n\n    assert resp.status_code == 201\n</code></pre> <p>Unless you have sync db connections (excuse me?) or aren't planning to write integration tests.</p>"},{"location":"raw_en/#15-backgroundtasks--asynciocreate_task","title":"15. BackgroundTasks &gt; asyncio.create_task","text":"<p>BackgroundTasks can effectively run both blocking and non-blocking I/O operations the same way FastAPI handles blocking routes (<code>sync</code> tasks are run in a threadpool, while <code>async</code> tasks are awaited later)</p> <ul> <li>Don't lie to the worker and don't mark blocking I/O operations as <code>async</code></li> <li>Don't use it for heavy CPU intensive tasks.</li> </ul> <pre><code>from fastapi import APIRouter, BackgroundTasks\nfrom pydantic import UUID4\n\nfrom src.notifications import service as notifications_service\n\n\nrouter = APIRouter()\n\n\n@router.post(\"/users/{user_id}/email\")\nasync def send_user_email(worker: BackgroundTasks, user_id: UUID4):\n\"\"\"Send email to user\"\"\"\n    worker.add_task(notifications_service.send_email, user_id)  # send email after responding client\n    return {\"status\": \"ok\"}\n</code></pre>"},{"location":"raw_en/#16-typing-is-important","title":"16. Typing is important","text":"<p>FastAPI, Pydantic, and modern IDEs encourage to take use of type hints.</p> <p>Without Type Hints</p> <p></p> <p>With Type Hints</p> <p></p>"},{"location":"raw_en/#17-save-files-in-chunks","title":"17. Save files in chunks","text":"<p>Don't hope your clients will send small files.</p> <pre><code>import aiofiles\nfrom fastapi import UploadFile\n\nDEFAULT_CHUNK_SIZE = 1024 * 1024 * 50  # 50 megabytes\n\nasync def save_video(video_file: UploadFile):\n   async with aiofiles.open(\"/file/path/name.mp4\", \"wb\") as f:\n     while chunk := await video_file.read(DEFAULT_CHUNK_SIZE):\n         await f.write(chunk)\n</code></pre>"},{"location":"raw_en/#18-be-careful-with-dynamic-pydantic-fields","title":"18. Be careful with dynamic pydantic fields","text":"<p>If you have a pydantic field that can accept a union of types, be sure the validator explicitly knows the difference between those types.</p> <pre><code>from pydantic import BaseModel\n\n\nclass Article(BaseModel):\n   text: str | None\n   extra: str | None\n\n\nclass Video(BaseModel):\n   video_id: int\n   text: str | None\n   extra: str | None\n\n\nclass Post(BaseModel):\n   content: Article | Video\n\n\npost = Post(content={\"video_id\": 1, \"text\": \"text\"})\nprint(type(post.content))\n# OUTPUT: Article\n# Article is very inclusive and all fields are optional, allowing any dict to become valid\n</code></pre> <p>Solutions:</p> <ol> <li>Validate input has only allowed valid fields and raise error if unknowns are provided</li> </ol> <pre><code>from pydantic import BaseModel, Extra\n\nclass Article(BaseModel):\n   text: str | None\n   extra: str | None\n\n   class Config:\n        extra = Extra.forbid\n\n\nclass Video(BaseModel):\n   video_id: int\n   text: str | None\n   extra: str | None\n\n   class Config:\n        extra = Extra.forbid\n\n\nclass Post(BaseModel):\n   content: Article | Video\n</code></pre> <ol> <li>Use Pydantic's Smart Union (&gt;v1.9) if fields are simple</li> </ol> <p>It's a good solution if the fields are simple like <code>int</code> or <code>bool</code>, but it doesn't work for complex fields like classes.</p> <p>Without Smart Union</p> <pre><code>from pydantic import BaseModel\n\n\nclass Post(BaseModel):\n   field_1: bool | int\n   field_2: int | str\n   content: Article | Video\n\np = Post(field_1=1, field_2=\"1\", content={\"video_id\": 1})\nprint(p.field_1)\n# OUTPUT: True\nprint(type(p.field_2))\n# OUTPUT: int\nprint(type(p.content))\n# OUTPUT: Article\n</code></pre> <p>With Smart Union</p> <pre><code>class Post(BaseModel):\n   field_1: bool | int\n   field_2: int | str\n   content: Article | Video\n\n   class Config:\n      smart_union = True\n\n\np = Post(field_1=1, field_2=\"1\", content={\"video_id\": 1})\nprint(p.field_1)\n# OUTPUT: 1\nprint(type(p.field_2))\n# OUTPUT: str\nprint(type(p.content))\n# OUTPUT: Article, because smart_union doesn't work for complex fields like classes\n</code></pre> <ol> <li>Fast Workaround</li> </ol> <p>Order field types properly: from the most strict ones to loose ones.</p> <pre><code>class Post(BaseModel):\n   content: Video | Article\n</code></pre>"},{"location":"raw_en/#19-sql-first-pydantic-second","title":"19. SQL-first, Pydantic-second","text":"<ul> <li>Usually, database handles data processing much faster and cleaner than CPython will ever do.</li> <li>It's preferable to do all the complex joins and simple data manipulations with SQL.</li> <li>It's preferable to aggregate JSONs in DB for responses with nested objects.</li> </ul> <pre><code># src.posts.service\nfrom typing import Mapping\n\nfrom pydantic import UUID4\nfrom sqlalchemy import desc, func, select, text\nfrom sqlalchemy.sql.functions import coalesce\n\nfrom src.database import database, posts, profiles, post_review, products\n\nasync def get_posts(\n    creator_id: UUID4, *, limit: int = 10, offset: int = 0\n) -&gt; list[Mapping]: \n    select_query = (\n        select(\n            (\n                posts.c.id,\n                posts.c.type,\n                posts.c.slug,\n                posts.c.title,\n                func.json_build_object(\n                   text(\"'id', profiles.id\"),\n                   text(\"'first_name', profiles.first_name\"),\n                   text(\"'last_name', profiles.last_name\"),\n                   text(\"'username', profiles.username\"),\n                ).label(\"creator\"),\n            )\n        )\n        .select_from(posts.join(profiles, posts.c.owner_id == profiles.c.id))\n        .where(posts.c.owner_id == creator_id)\n        .limit(limit)\n        .offset(offset)\n        .group_by(\n            posts.c.id,\n            posts.c.type,\n            posts.c.slug,\n            posts.c.title,\n            profiles.c.id,\n            profiles.c.first_name,\n            profiles.c.last_name,\n            profiles.c.username,\n            profiles.c.avatar,\n        )\n        .order_by(\n            desc(coalesce(posts.c.updated_at, posts.c.published_at, posts.c.created_at))\n        )\n    )\n\n    return await database.fetch_all(select_query)\n\n# src.posts.schemas\nimport orjson\nfrom enum import Enum\n\nfrom pydantic import BaseModel, UUID4, validator\n\n\nclass PostType(str, Enum):\n    ARTICLE = \"ARTICLE\"\n    COURSE = \"COURSE\"\n\n\nclass Creator(BaseModel):\n    id: UUID4\n    first_name: str\n    last_name: str\n    username: str\n\n\nclass Post(BaseModel):\n    id: UUID4\n    type: PostType\n    slug: str\n    title: str\n    creator: Creator\n\n    @validator(\"creator\", pre=True)  # before default validation\n    def parse_json(cls, creator: str | dict | Creator) -&gt; dict | Creator:\n       if isinstance(creator, str):  # i.e. json\n          return orjson.loads(creator)\n\n       return creator\n\n# src.posts.router\nfrom fastapi import APIRouter, Depends\n\nrouter = APIRouter()\n\n\n@router.get(\"/creators/{creator_id}/posts\", response_model=list[Post])\nasync def get_creator_posts(creator: Mapping = Depends(valid_creator_id)):\n   posts = await service.get_posts(creator[\"id\"])\n\n   return posts\n</code></pre> <p>If an aggregated data form DB is a simple JSON, then take a look at Pydantic's <code>Json</code> field type, which will load raw JSON first.</p> <pre><code>from pydantic import BaseModel, Json\n\nclass A(BaseModel):\n    numbers: Json[list[int]]\n    dicts: Json[dict[str, int]]\n\nvalid_a = A(numbers=\"[1, 2, 3]\", dicts='{\"key\": 1000}')  # becomes A(numbers=[1,2,3], dicts={\"key\": 1000})\ninvalid_a = A(numbers='[\"a\", \"b\", \"c\"]', dicts='{\"key\": \"str instead of int\"}')  # raises ValueError\n</code></pre>"},{"location":"raw_en/#20-validate-hosts-if-users-can-send-publicly-available-urls","title":"20. Validate hosts, if users can send publicly available URLs","text":"<p>For example, we have a specific endpoint which:</p> <ol> <li>accepts media file from the user,</li> <li>generates unique url for this file,</li> <li>returns url to user,</li> <li>which they will use in other endpoints like <code>PUT /profiles/me</code>, <code>POST /posts</code></li> <li>these endpoints accept files only from whitelisted hosts</li> <li>uploads file to AWS with this name and matching URL.</li> </ol> <p>If we don't whitelist URL hosts, then bad users will have a chance to upload dangerous links.</p> <pre><code>from pydantic import AnyUrl, BaseModel\n\nALLOWED_MEDIA_URLS = {\"mysite.com\", \"mysite.org\"}\n\nclass CompanyMediaUrl(AnyUrl):\n    @classmethod\n    def validate_host(cls, parts: dict) -&gt; tuple[str, str, str, bool]:\n\"\"\"Extend pydantic's AnyUrl validation to whitelist URL hosts.\"\"\"\n        host, tld, host_type, rebuild = super().validate_host(parts)\n        if host not in ALLOWED_MEDIA_URLS:\n            raise ValueError(\n                \"Forbidden host url. Upload files only to internal services.\"\n            )\n\n        return host, tld, host_type, rebuild\n\n\nclass Profile(BaseModel):\n    avatar_url: CompanyMediaUrl  # only whitelisted urls for avatar\n</code></pre>"},{"location":"raw_en/#21-raise-a-valueerror-in-custom-pydantic-validators-if-schema-directly-faces-the-client","title":"21. Raise a ValueError in custom pydantic validators, if schema directly faces the client","text":"<p>It will return a nice detailed response to users.</p> <pre><code># src.profiles.schemas\nfrom pydantic import BaseModel, validator\n\nclass ProfileCreate(BaseModel):\n    username: str\n\n    @validator(\"username\")\n    def validate_bad_words(cls, username: str):\n        if username  == \"me\":\n            raise ValueError(\"bad username, choose another\")\n\n        return username\n\n\n# src.profiles.routes\nfrom fastapi import APIRouter\n\nrouter = APIRouter()\n\n\n@router.post(\"/profiles\")\nasync def get_creator_posts(profile_data: ProfileCreate):\n   pass\n</code></pre> <p>Response Example:</p> <p></p>"},{"location":"raw_en/#22-dont-forget-fastapi-converts-response-pydantic-object-to-dict-then-to-an-instance-of-responsemodel-then-to-dict-then-to-json","title":"22. Don't forget FastAPI converts Response Pydantic Object to Dict then to an instance of ResponseModel then to Dict then to JSON","text":"<pre><code>from fastapi import FastAPI\nfrom pydantic import BaseModel, root_validator\n\napp = FastAPI()\n\n\nclass ProfileResponse(BaseModel):\n    @root_validator\n    def debug_usage(cls, data: dict):\n        print(\"created pydantic model\")\n\n        return data\n\n    def dict(self, *args, **kwargs):\n        print(\"called dict\")\n        return super().dict(*args, **kwargs)\n\n\n@app.get(\"/\", response_model=ProfileResponse)\nasync def root():\n    return ProfileResponse()\n</code></pre> <p>Logs Output:</p> <pre><code>[INFO] [2022-08-28 12:00:00.000000] created pydantic model\n[INFO] [2022-08-28 12:00:00.000010] called dict\n[INFO] [2022-08-28 12:00:00.000020] created pydantic model\n[INFO] [2022-08-28 12:00:00.000030] called dict\n</code></pre>"},{"location":"raw_en/#23-if-you-must-use-sync-sdk-then-run-it-in-a-thread-pool","title":"23. If you must use sync SDK, then run it in a thread pool","text":"<p>If you must use a library to interact with external services, and it's not <code>async</code>, then make the HTTP calls in an external worker thread.</p> <p>For a simple example, we could use our well-known <code>run_in_threadpool</code> from starlette.</p> <pre><code>from fastapi import FastAPI\nfrom fastapi.concurrency import run_in_threadpool\nfrom my_sync_library import SyncAPIClient \n\napp = FastAPI()\n\n\n@app.get(\"/\")\nasync def call_my_sync_library():\n    my_data = await service.get_my_data()\n\n    client = SyncAPIClient()\n    await run_in_threadpool(client.make_request, data=my_data)\n</code></pre>"},{"location":"raw_en/#24-use-linters-black-isort-autoflake","title":"24. Use linters (black, isort, autoflake)","text":"<p>With linters, you can forget about formatting the code and focus on writing the business logic.</p> <p>Black is the uncompromising code formatter that eliminates so many small decisions you have to make during development. Other linters help you write cleaner code and follow the PEP8.</p> <p>It's a popular good practice to use pre-commit hooks, but just using the script was ok for us.</p> <pre><code>#!/bin/sh -e\nset -x\n\nautoflake --remove-all-unused-imports --recursive --remove-unused-variables --in-place src tests --exclude=__init__.py\nisort src tests --profile black\nblack src tests\n</code></pre>"},{"location":"raw_en/#bonus-section","title":"Bonus Section","text":"<p>Some very kind people shared their own experience and best practices that are definitely worth reading. Check them out at issues section of the project.</p> <p>For instance, lowercase00 has described in details their best practices working with permissions &amp; auth, class-based services &amp; views, task queues, custom response serializers, configuration with dynaconf, etc.  </p> <p>If you have something to share about your experience working with FastAPI, whether it's good or bad, you are very welcome to create a new issue. It is our pleasure to read it.</p>"}]}